## 1장: 기초 쌓기

> 일단 언어 법률가부터 전부 없애야 해.  
> 헨리 6세, 2부

기본적으로 C++은 컴파일언어이다. 그 과정은 컴파일러가 프로그래머가 작성한 소스 텍스트를 처리해 오브젝트 파일을 만든 뒤 파일을 링커와 합쳐 실행 프로그램을 만든다.

ISO C++ 표준은 두 종류의 엔티티를 정의한다.

- 내장 타입(char, int 등)과 루프와 같은 언어 핵심 기능들
- 컨테이너(vector, mpa 등)와 I/O 연산(`<<`나 getline() 등)같은 표준 라이브러리 컴포넌트

C++은 동적 타입의 언어이다. 모든 엔티티(객체, 값, 이름, 식)의 타입을 사용 시점에 컴파일러에게 알려야 한다. 따라서 객체에 적용할 수 있는 연산 집합과 메모리 레이아웃이 달라진다.

모든 C++ 프로그램은 `main()`이라는 전역 함수를 최소한/최대한 하나만 포함해야 한다. `import std;`는 선언한 표준 라이브러리를 사용할 수 있도록 준비하라고 컴파일러에게 지시한다. (`#include`와 다름 더 유용)

오버로딩 부분에 대한 내용은 타입검사기 부분을 참고하자. (타입으로 견고하게, 다형성으로 유연하게 책)

- 선언은 프로그램에게 엔티티를 알리고 타입을 명시하는 명령문이다. (즉, 실제 동작은 컴퓨터가 한다는 것을 알아야 함)
- 타입은 **가능한 값 집합**과 **연산 집합**을 정의한다.
- 객체는 어떤 타입의 값을 저장하는 **메모리 영역**이다.
- 값은 타입에 따라 다르게 해석되는 **비트 집합**이다.
- 변수는 **명명된 객체**이다

객체 초기화 리스트의 단골문제? 초기화 리스트 부분이다.

```c++
double d1 = 2.3;
double d2 {2.3};
double d3 = {2.3};
```

정보를 잃는 암묵적 축소 변환은 C 호환성에 따른 대가이다.

타입을 명시적으로 언급할 **특별할 이유가 없으면 auto를 사용한다.** 특별한 이유는 다음과 같다.

- 정의가 광범위해서 코드의 독자에게 타입을 분명히 알리고 싶을 때
- 초기자의 타입이 분명하지 않을 때
- 변수의 범위나 정밀도를 밝히고 싶을 때

```c++
vector<int> vec; // vec은 전역이다.

void fct(int arg) // fct는 전역이다 (전역 함수를 명명), arg는 지역이다. (정수 인수를 명명)

{
    string motto {"Who"}; //motto는 지역
    auto p = new Record{"Hume"}; // p는 명명되지 않은 Record를 가리킴
}

struct Record {
    string name;
}
```

*`C#`에는 실제로 Record라는 구조체같은 클래스가 있다.* 책에서 다루는 소멸과 생성은 C의 영역과 C++, 그리고 실제 사용되는 프로그램에 따라 달라진다. (언리얼의 경우) 또는 해당 객체가 RAII 스마터 포인터라면 또 다른 경우

C++는 두 가지 불변성 표기법을 지원한다.

- const: "이 값을 바꾸지 않겠다고 약속해"로 이해하면 된다. **인터페이스를 명시할 때 주로 사용한다.**
- constexpr: "컴파일 타임에 평가된다"로 이해하면 된다.

c++에서 배열은 기본적으로 "메모리 내 인접한 객체 시퀀스"의 추상화이다.
