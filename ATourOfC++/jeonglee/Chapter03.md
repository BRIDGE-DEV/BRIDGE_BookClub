## 3장: 모듈성

C++ 프로그램된 함수, 사용자 정의 타입, 클래스 계층 구조, 템플릿 등 별도로 개발된 여러 부분으로 구성된다. 이렇게 **많은 부분을 관리하는 핵심은 서로의 인터렉션을 명확하게 정의**하는 것이다. **가장 중요한 첫 번째 단계로서 한 요소 내에서 인터페이스와 구현을 구분해야 한다.**

C++은 사용자 코드에 사용할 타입과 함수의 선언만 보여지는 분리컴파일 개념을 지원한다.

- 헤더파일: 헤더 파일이라는 별개의 파일에 선언을 넣은 후, 선언이 필요한 곳에서 헤더 파일명으로 헤더 파일을 `#include`한다.
  - *C#과 큰 차이점이기도 하다. C언어 계열의 특성으로 헤더 파일을 통한 정의와 구현의 분리가 이뤄진다.*
- 모듈: module 파일을 정의해 별도로 컴파일한 후, 필요한 곳에서 import한다. 명시적으로 export한 선언만이 그 module을 import한 곳에서 사용 가능하다.
  - *C#의 네임스페이스와 유사하지만, C++ 모듈은 컴파일 단위로서 더 강력한 기능을 제공한다.*

**헤더파일과 `#include`는 모듈성을 시뮬레이션하는 아주 오래된 방법이며, 몇 가지 심각한 단점을 지닌다.**

- **컴파일 시간**: 101개의 변역 단위에서 `header.h`를 `#include`하면 컴파일러는 `header.h`를 101번 처리한다.
  - 번역 단위: 독립적으로 컴파일되는 `.cpp`파일(이 파일에서 `#include`하는 `h`파일 포함)
- **순서 종속성**: `header2.h`보다 `header1.h`를 먼저 `#include`하면 `header1.h`에 들어 있는 선언과 매크로가 `header2.h` 내 코드의 의미를 바꿀 수 있다. 반대로 `header1.h`보다 `header2.h`를 먼저 `#include`하면 `header2.h`가 `header1.h`내 코드에 영향을 미칠 수 있다.
- **비일관성**: 타입이나 함수 같은 엔티티를 한 파일에 정의한 후 조금 다르게 또 다른 파일에 정의하면 고장이나 알아채기 어려운 오류로 이어질 수 있다. 이러한 문제는 우연히 혹은 고의로 엔티티를 한 헤더가 아니라 두 소스 파일에 별도로 선언하거나 헤더 파일 간 순서 종속성을 통해 선언할 때 발생한다.
- **이행성**: 헤더 파일 내 선언 표현에 필요한 모든 코드는 그 헤더 파일에 제시해야 한다. 이렇게 하지 않으면 헤더 파일이 다른 헤더를 `#include`해 코드가 거대해지고, 이로 인해 의도했든 우연이었든 헤더 파일의 사용자는 이러한 세부 구현에 의존할 수밖에 없게 된다.

C++20부터 드디어 언어 단에서 모듈성을 직접적으로 표현하는 방법을 지원하기 시작했다.

- 모듈의 특징
  - 모듈은 **딱 한 번 컴파일**된다.
  - 두 모듈은 의미에 영향을 주지 않으면서 **어떤 순서로든 임포트**할 수 있다.
  - 모듈로 `import`하거나 `#include`하면 모듈의 사용자는 암묵적으로 그 모듈에 접근할 수 없다. 즉, import는 이행적이 아니다.

`import std;`는 `#include <iostream>`보다 10배 더 빨리 컴파일된다. std 모듈은 <iostream> 헤더보다 정보가 10배 이상 많은 표준 라이브러리 전체를 포함하는데도 더 빠르다. 헤더는 직접적으로 혹은 간접적으로 표현하는 것을 전부 컴파일러에게 전달하는 반면, 모듈은 인터페이스만 export하기 때문이다.

함수, 클래스, 열거 외에 C++는 여러 선언을 한데 묶어 서로의 이름이 충돌하지 않도록 표현하는 메커니즘인 네임스페이스를 지원한다.

함수와 정보를 주고받는 것이 너무나 중요하기에 그 방법도 다양하다. 다음을 핵심적으로 고려해야 한다.

- 객체를 복사하거나 공유하는가?
- 객체를 공유한다면 가변인가?
- "빈 객체"를 남기고 객체를 이동시키는가?

인수 전달이든 값 반환이든 기본 동작은 "복사하기"이지만 지나치게 자주 복사할 경우 암묵적으로 **이동`move`**으로 최적화할 수 있다. 반대로 값 반환은 지역변수는 함수를 반환하는 시점에 사라지니 지역변수로의 포인터나 **참조를 반환**해서는 안된다.

- [Item 21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자](https://fkdl0048.github.io/cpp/cpp_Effective21/)
- [Item 20: ‘값에 의한 전달’보다는 ‘상수객체 참조자에 의한 전달’ 방식을 택하는 편이 대개 낫다](https://fkdl0048.github.io/cpp/cpp_Effective20/)

*해당 내용에 대한 깊은 설명 참조*

후위반환 타입을 이 책에서 처음 접한 것 같다. 람다와 비슷한 생김새를 가졌으며, 책에서도 논리적이긴 하지만 전통성이 더 강하기 때문에 책에서도 기존 방식의 반환을 사용한다.
