## 18장: 동시 실행

동시 실행(Concurrency), 즉 몇 가지 태스크를 동시에 실행하는 기술은 처리량을 늘리거나 응답성을 높이는 데 널리 쓰인다. *대부분의 언어에서 지원한다.* C++에서는 적절한 메모리 모델과 원자 연산 집합으로 한 주소 공간에서 여러 쓰레드를 동시에 실행할 수 있도록 한다.

- <thread>의 mutex, lock연산

동시 실행을 만병통치약으로 여겨서는 안되고 할 수 있다면 태스크를 순차적으로 수행하는 편이 일반적이고 더 빠르고 간편하다. **한 스레드로 정보를 전달하는 것 자체가 비용이 클 수 있다.**

**다른 계산과 동시에 실행될 가능성이 있는 계산을 태스크라고 부른다.** 프로그램 수준에서는 스레드라 표현한다. 다른 태스크와 동시에 실행되는 태스크를 만드려면 가장 먼저 그 태스크를 인수로 넣어 thread를 생성한다.

`t1.join();`은 c#에선 `await t1;`와 같은 느낌일까? RAII의 일종으로 생각한다.

```c++
void f()
{
    cout << "Hello ";
}

struct F{
    void operator()() {cout << "Parallel World!\n"; }
};

jthread t1(f);
jthread t2(F{});
```

이와 같은 코드는 끔찍한 오류를 발생시킨다. f와 F{}는 동기화 없이 각각 객체 cout를 사용하기 때문에 두 태스크 내 각 연산의 실행 순서가 불명확하므로 출력될 결과를 예측할 수 없으며, 프로그램을 실행할 때 마다 다를 수 있다.

`PaHerallllel o world!`

이러한 문제를 막고자 한다면 `osyncstream`을 사용하면 된다.

mutex는 운영체제까지 참조하는 중량 메커니즘이다. 데이터 경합 없이 임의의 작업량을 처리할 수 있다. (`shared_lock`, `unique_lock`) 하지만 소량의 작업은 `atomic`변수라는 훨씬 간단하고 저렴한 메커니즘으로 가능하다.

책에서 .get에 대한 예제를 다룰 때 예외를 말하는데 역시 동시 실행 부분에선 예외 처리가 필수적일 것 같다.
