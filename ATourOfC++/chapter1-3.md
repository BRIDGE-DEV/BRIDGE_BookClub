# Chapter 1

초기화와 대입은 다르다: c#을 하다가 오면 엥 싶은 지점 중 하나인 것 같다.

초기화를 하면 constructor가 호출되고, 대입을 하면 copy constructor가 호출된다. 두 줄에 나눠 쓰면 둘 다 호출되는 불상사를 겪을 수도 있다..

그리고 {}를 이용한 초기화도 역시 새 c++, 특히 스트로스트룹 선생님이 요즘 미는(?) 방법으로 보인다. int와 float의 암시적 변환을 막을 수 있어 c의 가장 큰 문제점 중 하나로 지적받는 부분을 피해갈 수 있는 좋은 방법이라고 생각한다. (여러분들은 어떻게 생각하시는지. 개인적으론 쓰면 좋을 것 같은데 다들 아직 잘 안쓰다보니..)

nullptr: 역시 과도기적인 코드에서 NULL을 더 많이 사용하는 것을 볼 수 있다. 책에서 나온대로 0과 NULL을 헷갈리는 문제를 해결할 수 있다. 이 문제는 c++의 NULL의 정의가 c와 다른 점에서 비롯된다. c에서 NULL은 `(void *)0`으로 정의된 반면, c++은 그냥 `0`으로 정의되어 있다. 그 이유는 c++에서는 c와 다르게 char *에 void *를 대입할 수 없게끔 타입 검사가 이루어지기 때문에, char *p = NULL이 컴파일되기 위해 NULL이 그냥 0으로 정의되어야 하는 것이다. 이러한 문제가 있기 때문에 nullptr을 이용하는게 좋다.
반대로 c++에서는 c에서 불가능한 `int i = NULL`이라는 코드가 컴파일된다. (대부분의 컴파일러가 경고를 날려주긴 한다)

`for (int i = 0; i < n; ++i)` 대신에 `for (int i = 0; i != n; ++i)`를 쓰는게 뭔가 눈에 띄였다.

또한 `float f = 1` vs `float f{1}`처럼. 원래 하던 익숙하고 보통 통하는 방식 vs 새로운 방식? 각 방법의 장단점과 이 책에 나온 새 문법에 대해 얘기해보면 좋을 것 같습니다. 또한 언어에서 위처럼 같은 일을 하더라도 방법이 여러가지인 점에 대해서 어떻게 생각하시는지 궁금합니다.

# Chapter 2

이 챕터를 c++ 만든 사람이 설명해주니 왜 struct와 class가 둘 다 존재하는지 이해가 된다. 그러니까 struct는 기존 c 스타일의 구조체와 같이 사용하고 싶을 때 쓰고, class는 객체지향적으로 작업할 때 사용하는 것으로 그 뜻이 조금의 차이가 있는 것 같다. 물론 실질적으로는 기본으로 private/public인것 말고는 아무 차이도 없지만!

union의 경우에는... 다른 언어들처럼 tagged union(union struct)이 바로 제공되지 않아서 프로그래머가 알아서 접근을 해야 하는 점이 좀 아쉬운 것 같다. oop로 알아서 해야 한다는 점.. variant도 다른 언어에 비하면 문법이 복잡하고 약한 것 같다.

# Chapter 3

header file을 쓰는 방법이 그냥 아주 오래된 방법이고 매우 나쁜 방법처럼 소개하는데, 개인적인 생각으로는 이게 c++이 진작에 c++에 맞는 새 방법을 만들었어야 한다고 본다.

나는 c가 당시에 수많은 하드웨어 아키텍쳐를 지원하기 위해서 이런 형태가 됐다고 생각한다. 헤더 파일은 같지만, 다른 플랫폼에서는 안의 c 파일은 하드웨어의 다른 부분과 상호작용하기 위하여 꽤 다르게 작성될 수 있다는 것이다. 또한 둠에서 봤던 예시처럼 인터페이스만 제공하고 한 부분만 각 플랫폼에 맞게끔 c 파일을 작성하는 부분도 그렇다. 하지만 c++에서 와서는 cpp와 h파일이 1:1로 보통 대응하기 때문에 좀 무색해진 부분도 있다. 그냥 헤더 파일을 너무 안좋게만 비추는 것 같아서 개인적인 생각을 써 봤다. 그러니까 한 프로젝트 안에서보다는, 하나의 정해진 스탠다드에 맞춰 여러 플랫폼 혹은 사람이 다른 구현을 제공하기에는 헤더 파일만한 게 없다는 생각이다.

솔직히 cpp 파일과 h파일을 분리하고 굳이 같은 코드를 두 번씩 쓰는 불상사가 모듈의 등장으로 사라졌다니 굉장히 다행이다. 하지만 컴파일러가 이제야 c++20 구현을 다해가는 느낌인데, 그전에 다른 언어들에게 대체당하지나 않으면 다행일 것 같다.. 개인적으로는 진짜 모듈은 진짜 옳은 방향인것 같다.

함수 인자 전달에서 복사해도 좋은 크기를 대충 2~3 ptr 크기라고 책에 나왔다. 우리가 쓰는 컴퓨터는 8바이트이니, 16~24바이트라고 보면 되는데.. 이건 사실 책에서 나온대로 시간을 재고 어셈블리를 뽑아 봐야 실질적으로 성능 차이가 어떤 지 알 수 있는 것 같다. 큰 레지스터(128, 256짜리 레지스터)로 한 번에 전해질지 아니면 여러개로 쪼개지거나 다른 방법으로 전해질지는 모른다. 대충 16바이트까지는 그냥 값으로 전달해도 문제 없다고 볼 수 있지 않을까.

tmi) go에서 함수의 로컬 변수를 레퍼런스로 반환해도 문제가 없는건 좀 충격이었다.. 알아서 박싱해준다고 한다.

개인적인 생각으로는 함수에서 새 오브젝트를 만들어서 리턴해주는게 문제는 없다고 생각하는데, 함수 이름이 add인게 좀 문제인 것 같다. 이용자는 아무래도 아무 생각 없이 쓰고 free할 생각을 못한다. 이름이 add_and_construct같은 다른 이름이었으면 괜찮지 않았을까? 애초에 매트릭스를 더하는데 이처럼 포인터로 돌려주는 것도 참 이상한 것 같다! 그 다음에 드는 생각은 차라리 out parameter를 두는것도 나쁘지 않았겠다 싶다. 하지만 똑똑한 현대 컴파일러들은 알아서 해 주니까 걱정할 필요가 없다.

이 auto f() -> int의 방법은 매우 rust랑 유사하다는 생각이 든다 fn f() -> i32와 완전 동일하다. c 언어 스탠다드에도 나오지만 int를 리턴하는 함수를 int 타입의 확장 개념으로 생각했다. 그래서 그 타입이 앞에 나오게 쓰인 것으로 보인다. 현대에 와서는 타입을 앞에 쓰는게 맞다고 생각하는 언어는 거의 없는 것 같다.

c:
int foo();
pascal:
function foo(): int
c++:
auto foo() -> int
go:
func foo() int
rust:
fn foo() -> int
zig:
fn foo() int

