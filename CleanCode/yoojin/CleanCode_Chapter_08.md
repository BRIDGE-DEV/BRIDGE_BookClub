# 8장 경계

## 느낀점
나는 서비스관련 개발을 하지는 않고 있어서 그런지 아직 외부 패키지 의존성에서 나오는 제약들은 겪어보지는 못한 것 같다. 또한, 외부 패키지를 우리가 조금 뜯어 고칠수도 있으므로, 우리의 입맛에 맞게 외부 패키지를 바꿀 수는 있는데, 문제는 다른 사람이 이러한 뜯어고친 외부 패키지를 우리도 사용해야 할 경우, 번거로워진다는 점이 있다는 것 같다.

## 논의사항
외부 패키지의 버전 업데이트가 됐는데 docs 업데이트는 되지 않아서 고생하신 경험이 있으신가요?


## 내용 요약
외부의 코드들을 우리 코드에 깔끔하게 통합하는 것도 중요하다. 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교에 대한 내용을 서술하고 있다.

**외부 코드 사용하기**

Map과 같이 경계 인터페이스를 사용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. 그리고 여기저기로 넘기지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

**경계 살피고 익히기**

외부 패키지는 우리의 책임이 아닌 부분이지만, 우리를 위해 테스트를 하는 것은 중요하다. 라이브러리에 대한 사용법을 doc에서 읽고, 예상대로 동작하는 지 확인한다. 그렇지만 이것이 우리 코드의 버그인지 라이브러리의 버그인지 찾아내는 것은 쉽지 않다. 그럴 때는 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히자. 이를 학습 테스트라고 부른다. 통제된 환경에서 API를 제대로 이해하는지를 확인한다.

**log4j 익히기**

외부 라이브러리를 사용하려고 할 때, 문서를 자세히 읽기 전 첫번째 테스트 케이스를 작성한 뒤 테스트 해본다. 그래서 그 뒤에 여러 오류들에 직면하면서 구글링을 통해 테스트를 돌린 끝에 내가 원하는 결과를 얻을 수 있다. 이런 과정동안에 외부 라이브러리가 돌아가는 방식을 많이 이해할 수 있으며, 관련한 초기 방법들을 지식으로 익혔다면 이 지식들을 클래스로 캡슐화한다 그 이후에는 경계인터페이스를 자세히 몰라도 된다.

**학습 테스트는 공짜 이상이다.**

학습 테스트는 이해도를 높여주는 정확한 실험이다. 투자하는 노력보다 얻는 성과가 더 크며, 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.

패키지가 새 버전이 나올 때마다 우리 코드와 호환이 되지 않는다면 학습 테스트가 이를 알려줄 수 있다. 아무튼 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트는 패키지의 새 버전으로 이전하기 쉬워지며, 그렇지 않으면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠질 수 있다.

**아직 존재하지 않는 코드를 사용하기**

**아는 코드와 모르는 코드를 분리하는 경계.**

협업을 진행할 때, 서로의 맡은 업무가 서로 다를 경우, 경계를 너머 미치지 못하는 코드 영역은 보이지 않을 수 있다. 그럴 때는 서로 가장 멀리있는 곳부터 구현을 시작할 수도 있다. 목적이 분명하다면, 우리가 바라는 인터페이스를 만들고, 인터페이스를 전적으로 통제시키면 된다. 그리고 Adapter 패턴으로 API 사용을 캡슐화 하면, API가 바뀔 때의 수정할 코드를 한 곳으로 모은다. 
이러한 설계를 통해 테스트도 편하게 할 수 있고, 경계 테스트 케이스를 생성해 우리가 API를 올바르게 사용하는지 알 수 있다.

**깨끗한 경계**

* 소프트웨어 설계가 우수하다면 변경하는 데 많은 시간과 투자와 재작업이 필요하지 않다. 

* 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 주의하자.

* 경계에 위치하는 코드는 깔끔히 분리해야 하며, 기대치를 정의하는 테스트 케이스도 작성한다. 

* 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 좋다.

* 외부 패키지를 호출하는 코드를 줄여 경계를 관리하자.

* 새로운 클래스로 경계를 감싸자

* Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.

    → 코드 가독성과, 경계 인터페이스를 사용하는 일관성, 외부 패키지가 변했을 때 변경할 코드의 양 또한 개선된다.