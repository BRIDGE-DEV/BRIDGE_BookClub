## 3장 함수

### 작게 만들어라!

함수는 작게 만들어야 한다. 작은 함수는 이해하기 쉽고, 수정하기도 쉽다.

함수를 작게 만들기 위해 가능한 한 많은 기능을 분리하고, 각 함수는 한 가지 기능만 수행하도록 한다.

#### 블록과 들여쓰기

코드 블록은 가급적 짧게 유지하고, 들여쓰기를 사용해 코드를 읽기 쉽게 만들어야 한다.

### 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

함수는 오직 한 가지 기능만 수행해야 한다.

한 가지 기능만 수행하도록 하면 코드의 재사용성이 높아지고, 테스트하기도 쉬워진다.

#### 함수 내 섹션

```cs
// 나쁜 예
void doSomething() {
    // 섹션 1
    // 섹션 2
}

// 좋은 예
void doSomething() {
    section1();
    section2();
}
```

함수 내에 섹션을 나누지 말고, 각 섹션을 작은 함수로 분리해야 한다.

### 함수 당 추상화 수준은 하나로!

함수 내에서 추상화 수준을 일관되게 유지해야 한다.

추상화 수준이 일치하지 않으면 코드를 이해하기 어렵고, 수정하기도 어렵다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

```cs
void main() {
    function1();
    function2();
}
void function1() {
    // ...
}
void function2() {
    // ...
}
```
함수 호출 순서를 위에서 아래로 나열하며, 호출되는 함수는 호출하는 함수 바로 아래에 배치해야 한다.

### 서술적인 이름을 사용하라!

함수 이름은 해당 함수가 수행하는 기능을 명확하게 설명해야 한다.

서술적인 이름을 사용하면 코드를 읽는 사람이 함수의 목적을 쉽게 이해할 수 있다.

### 함수 인수

```cs
// 나쁜 예
void createUser(string name, string email, string password) {
    // ...
}

// 좋은 예
class User {
    string name;
    string email;
    string password;
}
void createUser(User user) {
    // ...
}
```

함수 인수는 최대한 적게 사용해야 한다. 인수가 많을수록 함수를 이해하기 어렵다.

인수를 줄이기 위해 객체를 사용하거나, 인수를 묶어 새로운 객체를 만드는 방법을 사용한다.

#### 많이 쓰는 단항 형식

단항 연산자를 사용해 함수를 작성할 때는 형식을 통일시켜야 한다.

#### 플래그 인수

```cs
// 나쁜 예
void doSomething(boolean flag) {
    if (flag) {
        // ...
    } else {
        // ...
    }
}
// 좋은 예
void doSomethingA() {
    // ...
}
void doSomethingB() {
    // ...
}
```

플래그 인수는 피해야 한다.

대신, 명확한 의미를 가진 여러 함수로 분리해야 한다.

#### 이항 함수

이항 함수는 두 개의 인수를 받는 함수로, 가능하면 줄이려고 노력해야 한다.

#### 삼항 함수

삼항 함수는 세 개의 인수를 받는 함수로, 이항 함수보다 이해하기 어렵다.

가능하면 줄이려고 노력해야 한다.

#### 인수 객체

```cs
class Point {
    int x;
    int y;
}
void setCoordinates(Point point) {
    // ...
}
```
인수가 많을 경우, 인수들을 객체로 묶어서 전달하는 것이 좋다.

#### 인수 목록

떄론 인수 개수가 가변적인 함수도 필요하다.

가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다.

#### 동사와 키워드
```cs
void saveFile(String filename) {
    // ...
}
```
함수 이름에 동사와 키워드를 사용하여 함수의 목적을 명확히 표현해야 한다.

또한 인수의 순서를 맞춰 작성하는 것이 좋다.

### 부수 효과를 일으키지 마라!

함수는 가능한 한 부수 효과가 없도록 작성한다.

부수 효과가 없는 함수는 코드를 이해하기 쉽고, 테스트하기도 쉬워진다.

#### 출력 인수

출력 인수는 피해야 한다.

대신, 함수가 속한 객체 상태를 변경하는 방식을 택한다.

### 명령과 조회를 분리하라

```cs
// 나쁜 예
bool setAndCheckFlag(bool newFlagValue) {
    flag = newFlagValue;
    return flag;
}
// 좋은 예
void setFlag(bool newFlagValue) {
    flag = newFlagValue;
}
bool isFlagSet() {
    return flag;
}
```

함수는 상태를 변경하는 명령과 상태를 조회하는 쿼리를 동시에 수행하지 않아야 한다.

명령과 조회를 분리함으로써 함수의 목적이 명확해지고, 코드를 이해하고 테스트하기 쉬워진다.

### 오류 코드보다 예외를 사용하라

```cs
// 나쁜 예
int readFile(string filePath) {
    if (!File.Exists(filePath)) {
        return -1;
    }

    // 파일 읽기 코드
    return 0;
}

// 좋은 예
void readFile(string filePath) {
    if (!File.Exists(filePath)) {
        throw new FileNotFoundException();
    }

    // 파일 읽기 코드
}
```

함수가 작업을 수행할 수 없는 경우, 오류 코드를 반환하는 대신 예외를 발생시켜라.

예외를 사용하면 오류 처리 코드를 별도로 작성할 수 있어 함수가 깔끔해진다.

#### Try/Catch 블록 뽑아내기
```cs
void doSomething() {
    try {
        riskyOperation();
    } catch (Exception e) {
        handleException(e);
    }
}
```
오류 처리는 별도의 함수로 분리하고, try/catch 블록을 최소화해야 한다.

#### 오류 처리도 한 가지 작업이다.

오류 처리에만 집중하고, 다른 작업을 수행하지 않는 함수를 작성해야 한다.

#### Error.java 의존성 자석
```cs
// 나쁜 예
public class Errors {
    public static final int FILE_NOT_FOUND = 1;
    // ...
}
// 좋은 예
public class FileNotFoundException extends Exception {
    // ...
}
```
오류 코드를 일일이 정의하는 대신, 예외 클래스를 사용하여 오류를 처리하는 것이 좋다.

### 반복하지 마라!

코드에서 중복을 최소화하라.

중복 코드는 버그 발생의 원인이 되고, 코드 수정이 어려워진다.

### 구조적 프로그래밍

함수는 단일 입구(single-entry)와 단일 출구(single-exit) 원칙을 따르는 것이 좋다.

이 원칙을 따르면 코드의 흐름을 쉽게 파악할 수 있고, 예외 처리가 간편해진다.

### 함수를 어떻게 짜죠?

처음에는 함수를 만드는 것에 집중한다. 이 때 코드는 길고 복잡해질 수 있다.

그런 다음 리팩토링을 통해 함수를 작게 나누고, 목적이 명확한 함수로 만든다.

### 결론

대가 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다.

규칙을 잘 따라 이야기를 풀어갈 수 있도록 하자.

### 느낀점

함수를 생각보다 아주 작은 단위로 쪼개야 한다는 사실에 놀랐다.

막상 쪼개보니 생각보다 가독성이 좋아지는 것 같아 두번 놀랐다.

인수를 줄이는 것도 쉽지 않은 듯 하다,,

### 논의사항

함수를 너무 작은 단위로 쪼갠다면 중괄호 같은 부분 때문에 오히려 가독성이 더 안좋아질 수도 있지 않을까요?

이 부분에 대해 어떻게 생각하는지 궁금합니다.