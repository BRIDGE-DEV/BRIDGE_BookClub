## 1장 깨끗한 코드  

이 책을 읽는 이유는 크게 두가지로 프로그래머이거나 성장하는 프로그래머이고 싶어서 정도로 정리될 것 같다.

앞으로 등장하는 코드를 다양한 각도에서 살펴보며 좋은코드와 나쁜코드를 구별하는 능력과 나쁜 코드를 좋은 코드로 바꾸는 능력까지..!  

### 코드가 존재하리라

시작부터 ChatGPT를 까고 시작하는.. 마틴아저씨는 여기까지 생각했을까..?

최근 읽기 시작한 `소프트웨어 아키텍처 101`에서도 AI는 설계, 요구사항 분석 등 다양한 환경에 맞는 트레이드오프까지는 대체할 수 없는 영역으로 보고 있다.

다양한 프레임워크, 언어가 등장하면서 특정 분야에 맞는 특화된 프로그래밍 언어가 등장하고 있다.

무려 2008년에 이 책을 집필했다고 해도.. 15년을 예측하고 있는 듯 하다..

말 그대로 언어마다 새로운 기능들이 나오면서 추상화 수준도 높아지고 점점 high 레벨의 언어들이 등장하고 있다.

> 궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심한다.

### 나쁜 코드

> 나쁜 코드는 나쁜 코드를 만든다.

* 켄트 백

> "이 책은 좋은 코드가 중요하다는 다소 미약한 전제에 기반한다."

우리는 좋은코드가 좋다는 사실을 왜 알고 있을까?  

앞서 나쁜코드에 대한 경험이 있기 때문이다.  

그렇다면 왜 다시 나쁜코드를 짜는 문제에 빠지는 걸까??  

급해서, 서두르느라, 나중에 고쳐야지.. 등등 여러가지 이유가 있을 것이다.

하지만 이제는 알아야 한다, 나중은 결코 오지 않는다.

*르블랑의 법칙(leblanc's Law) ~~WQRE 콤보~~*

가장 느린길이 가장 빠른 길이다..  

이제는 아는 것 같다 초반에 급하게 설계하지 않고 나름 탄탄하게 쌓아 올려야 미래의 내가 고생하지 않는 것 을..

하지만, 여타 솔루션을 해결하기 위한 애플리케이션이나 게임도 그렇듯 요구사항을 완벽하게 분석하여 설계할 수 없다.  

그렇다면 계속 나쁜 코드를 생산해야하는가.. 에 대한 대답은 NO..!  

계속 인지하면서 좋은 코드를 쓰기 위해 노력만 해도 크게 달라진다.

### 나쁜 코드로 치르는 대가

2~3년이 지난 프로젝트에 참여하게 되면 흔히 레거시코드, 쓰레기 코드등을 만날 수 있는데 대부분의 프로그래머가 그 때 해당 사람을 속으로 욕하거나 비판한다.  

나도 과거에는 그랬던 것 같지만 사실 그 코드는 그 상황에서 최선이였을 것이다.  

내가 짠 최선의 코드를 다른 사람의 비판적인 시각엔 쓰레기 코드가 될 수 있듯이 관점의 차이나 그 때에 급박한 상황 or 기술 부채등의 원인일 것이다.

나쁜코드가 쌓일수록 팀 자체의 생산성은 떨어진다.  

인디게임팀은 더 심한 것 같다. 1년을 개발한 프로젝트를 인수인계 받는다고 한다면 정말 머리가 아프다..  

다른 시스템을 개발하는 것과 별개로 해당 코드에서 이어 나가야 하는 그런 경험들은 거의 해독에 가깝다.  

원대한 재설계처럼 선택과 집중을 해야한다.  

레거시를 받아들이는 차이점인데 실제로 해당 시스템을 다시 만드는 것과 리팩터링의 차이는 그렇게 크지 않다..  

처음 설계부터 잘 만들어진 소프트웨어는 최적화를 따로 하지 않기 때문에 주어진 자리에서 이걸 그냥 끝내야지라는 생각이 들면 그냥 끝내는 게 맞고..  

리팩터링이나 리소스만 살려서 다시 제작한다고 한다면 그 길을 가는게 맞는 것 같다.

#### 태도

수많은 외부 압박에도 프로그래머는 자신의 미래를 위해..? 프로페셔널한 모습을 보여야 한다.  

현재 구조에서 고민이 많이 필요하고 시간이 많이 들어간다면 충분한 논의 끝에 구조를 잡아가는게 좋다.  

만약 급하게 구현한다면.. 역 피라미드 구조를 만들어야 할 수도 있다.

> 그들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 그들의 책임이기 때문이다.

개발자 정신을 가져야 하는 이유이다.  

그들은 자신의 일을 하는 것이다.

불화나 마찰이 싫다고 해서 급하게 결과물을 만들어 내는 것 또한 전문가 답지 못하다..!

##### 원초적 난제

나쁜 코드를 양산하면 기한을 맞추지 못하고 오히려 엉망진창인 상태로 인해 속도가 곧바로 늦어지고, 결국 기한을 놓친다.  

기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, **언제나 코드를 깨끗하게 유지하는 습관**이다.

##### 깨끗한 코드라는 예술?

깨끗한 코드란 무엇일까?  

깨끗한 코드를 구현하는 행위는 마치 그림을 그리는 행위와 비슷하다..  

비슷한 예로 100명이 같은 기능을 개발한다고 해도 내부 설계는 전부 다 다를 것이다.  

여기서 1등으로 깨긋한 코드를 고를 수 있을까??  

어느정도 트레이드오프를 생각해서 상위정도는 선택할 수 있지만 상당히 주관적인 부분이 있다.

다시 말해, 깨끗한 코드를 작성하는 프로그래머는 빈 캔퍼스를 우와한 작품으로 바꿔가는 화가와 같다.

##### 깨끗한 코드란?

노련한 프로그래머의 의견들.

* 비야네 스트롭스트룹

*이름 웃기다.*

> 나는 우아하고 효율적인 코드를 좋아한다.  
> 논리가 간단해야 버그가 숨어들지 못한다.  
> 의존성을 최대한 줄여야 유지보수가 쉬워진다.  
> 오류는 명백한 전략에 의거해 철저히 처리해야 한다.  
> 성능을 최적으로 유지해야 사람들이 워칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.  
> 깨긋한 코드는 한 가지를 제대로 한다.

`우아한`: 외양이나 태도가 기품 있고 단아하며 보기에 즐거운; 교모하고 단순해 보기에 즐거운

두 가지 측면을 강조한다. 보기에 즐거운 코드 그리고 효율적인 코드  

또한 가장 중요한 부분이 나와있는데 **나쁜코드는 나쁜코드를 유혹한다.**  

비슷한 심리효과로 깨진 유리창 이론이 있다..  

프로그래머들이 대충 넘어가는 부분 중 하나가 오류 처리이다.  

메모리누수, 경쟁 상태, 일관성 없는 명명법이 또 다른 예이다.  

한마디로 요약하자면 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드이다.  

항상 느끼는 부분이지만 이런 감각, 세세한 부분이 정말 중요하다는 사실이다.

게임에서도 플레이어가 완성도를 느끼는 부분도 세세한 디테일에서 온다고 생각하고 좋은 코드 또한 감각적인 부분이 필요하다고 생각된다.  

이런 부분이 애자일에서 다루는 가장 중요한 `반복`이 아닐까?

한가지 역할을 잘한다는 것은 그만큼 클래스, 메서드가 세분화되어 낮은 레벨로서 동작한다는 것이고 이는 즉, 객체지향 개념에도 부합한다.  

* 그래디 부치  

> 깨끗한 코드는 단순하고 직접적이다.  
> 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.  
> 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.  
> 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.  

가장 공감이 되는 말 `깨끗한 코드는 잘 쓴 문장처럼 읽힌다.`라는 부분이다.  

게임쪽 코드에서는 질 좋은 코드를 많이 본적 없지만 최근에 객체지향 아키텍처에 잘 맞는 코드를 본적이 있다.

정말 글을 읽듯이 내용이 한눈에 들어오고 잘 짰다는 생각이 가득했다가..  

객체지향 관련 글을 읽어보고 쉽게 교조주의에 빠지면 안된다는 생각이 들었다.  

만약 내가 디자인 패턴을 공부한다면 해당 디자인 패턴을 공부하기 위해 프로젝트에 적용시키는 것은 바보같은 짓이다.  

디자인 패턴은 정말 필요할 때 적용해야한다.  

이러한 가독성 좋은 코드들은 주석이 따로 필요 없으며 추상 계층도 정리가 잘 되어 있으며 기본적으로 복잡한 상속구조를 가지지 않는다.  

코드는 추측이 아니라 사실에 기반해야 한다.  

반드시 필요한 내용만을 담아야 한다.  

코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야 한다.  

* 큰 데이브 토마스

> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.  
> 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.  
> 깨끗한 코드에는 의미 있는 이름이 붙는다.  
> 특정 목적을 달성하는 방법은 하나만 제공한다.  
> 의존성은 최소이며 각 의존성을 명확히 정의한다.  
> API는 명확하며 최소로 줄였다.  
> 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.

마찬가지로 **가독성**의 중요성과 깨끗한 코드는 작성자가 아닌 다른 사람도 읽고 고치기 쉽다고 강조한다.  

여기서 다른 사람에 대한 나의 생각은 `좋은 코드 나쁜 코드`를 읽을 때 나왔던 말처럼 1년 뒤의 나도 다른 사람이다.  

당장 2주전에 짠 코드를 봐도 제대로 못 읽는데.. 같은 사람이라고 할 수 있을까?  

코드를 작성할 때는 나만 보는 코드라는 생각은 버리고 미래의 나, 다른 사람까지 읽기 쉽고 수정이 편한 코드를 작성해야 한다.  

TDD.. 진짜로 프로젝트에 도입해보고 싶다는 생각은 있지만 먼저 `단위테스트`관련 책과 공부를 하고 진행하고 싶다.  

유니티는 원활한 테스트를 위해 Test Runner라는게 있지만.. 정보도 적고 라이브러리 아니면 실제 프로젝트에 적용되는 경우는 많이 보지 못했다.  

* 마이클 페더스  

> 깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 있다.  
> 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다.  
> 고치려고 살펴봐도 딱히 손 댈 곳이 없다.  
> 작성자가 이미 모든 사항을 고려했으므로, 고칠 궁리를 하다보면 언제나 제자리로 돌아온다.  
> 그리고는 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.  

한마디로 요약하자면 **주의**다.  

이 책의 주제이며 우리가 앞으로 행해야 하는? 행해야 할 것이다.

*인지하며 작성하자*

* 론 제프리스  

> 최근 들어 나는 켄트 벡이 제안한 단순한 코드 규칙으로 구현을 시작한다.  
> 중요한 순으로 나열하자면 간단한 코드는  
>
> * 모든 테스트를 통과한다.
> * 중복이 없다.
> * 시스템 내 모든 설계 아이디어를 표현한다.
> * 클래스, 메서드, 함수등을 최대한 줄인다.

중복을 행하고 있다면 코드가 아이디어를 제대로 표현하지 못한다는 증거이다.  

이러한 증거가 발견되면 문제의 아이디어를 명확하게 표현하려고 해야 한다.

표현력은 의미있는 이름을 뜻하기도 하지만 객체 자체의 보여주는 부분또한 표현력으로 볼 수 있다.  

한가지 객체가 너무 많은 기능을 담당하면 표현력이 떨어지고, 한가지 기능만 담당하면 표현력이 높아진다.

따라서 중복과 표현력만 신경을 써도 깨끗한 코드에 한발짝 다가갈 수 있다.  

요약: 중복을 피해라. 한 기능만 수행해라. 제대로 표현해라. 작게 추상화하라

* 워드 커닝햄  

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.  
> 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.  

짐작 했던 기능.. 대부분 중복되는 내용처럼 한가지 언어이기 때문에 가독성이 정말 정말 중요하다는 걸 강조한다.  

* 밥 아조씨  

장을 시작하기 앞서 자신의 의견을 이 책에서 진리처럼 설명을 한다는 말을 한다.  

이 방법은 절대적인 방법이 아니며 단순한 접근법이다.  

더 좋은 더 나은 코드를 만들기 위해 고민하여 작성된 책.  

> 우리 생각이 절대적으로 '옳다'라는 단정은 금물이다.  

쉽게 확증편향, 교조주의에 빠지지 않도록 주의하자.  

성장을 하기 위해선 그냥 받아들이는 것이 아닌 부정하고 반대하라.(너무 과격한 감이 있지만 비판적인 시각을 가져야 더 큰 배움을 얻는 듯 하다..)  

### 우리는 저자다  

다른 개발책에서도 나오는 이야기지만(프로그래머의 뇌, 좋은 코드 나쁜 코드) 대부분의 프로그래머는 코드를 작성하는 시간보다 읽는 시간이 압도적으로 많다.  

주변 코드를 읽지 않으면 새 코드를 짜지 못한다.  

주변 코드를 읽으면 새 코드도 짜기 쉽다.  

주변 코드가 읽기 어려우면 새 코드도 짜기 어렵다..!  

생각난 일화로.. 회사에서도 천줄 씩 커밋하는 개발자보다 4~5줄 고치고 명확한 커밋을 날리는 개발자가 더 유능하다고 한다.  

### 보이스카우트 규칙  

하루 아침에 잘 짠 코드는 전부가 아니다.  

시간이 지나도 언제나 깨끗하게 유지해야 한다.  

우리는 코드의 퇴보를 막아야 한다.  

> 캠프장을 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라

내가 무슨 작업을 한다고 세분화를 거쳐서 내용을 작성 했다.  

이후 해당 내용으로 코딩을 진행하다가 수정 사항이 생겨 즉각적으로 코드에 반영을 했을 때, 이후에 해당 내용을 작업 내용에 반영해야 한다.  

요즘에 이것에 대한 중요성을 많이 느끼고 있으며 틀렸다는 생각은 들지 않는다.  

코드를 작성하여 동작할 때 기분이 좋을려면 계속 좋은 코드 위에 코드를 쌓아야 한다.  

나쁜 코드는 쉽게 전염, 유혹되기 때문에..

### 프리퀄과 원칙  

SOLD 원칙을 이야기 하고 있다.  

### 결론  

예술에 대한 책을 읽는다고 예술가가 되지 않는다.  

책은 단지 다른 예술가가 사용하는 도구와 기법, 그리고 생각하는 방식을 소개할 뿐이다.  

### 느낀점

등장하는 얼굴들이 확신의 개발자 상..  

객체지향, TDD, 클린코드, 리팩토링, 디자인패턴, 소프트웨어공학, 애자일 등등..

다양한 이야기를 담고 있어서 좋았다.  

무조건 읽어야지 읽어야지 했는데 읽기 시작하니까 재밌어서 읽기 잘했다는 생각..++

#### 논의사항

자신만의 좋지 못한 구조를 가져간 경험이 있나요?  

그 이유가 궁금합니다..  

급해서, 프로젝트에 애정이 없어서, 나중에 할려고 등등..  
