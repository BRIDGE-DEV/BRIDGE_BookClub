# 오브젝트

## 11장. 합성과 유연한 설계

상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다.

상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 데 비해 합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.

상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.

상속 관계는 **is-a 관계**라고 부르고 합성 관계는 **has-a 관계**라고 부른다.

상속과 합성은 코드 재사용이라는 동일한 목적을 가진다는 점을 제외하면 구현 방법부터 변경을 다루는 방식에 이르기까지 모든 면에서 도드라진 차이를 보인다.

<br>

합성은 구현에 의존하지 않는다는 점에서 상속과 다르다.

합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.

따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게 된다.

<br>

상속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다.

이 차이점은 생각보다 중요한데, 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있기 때문이다.

따라서 상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.

<br>

물론 상속보다 합성을 이용하는 것이 구현 관점에서 좀 더 번거롭고 복잡하게 느껴질 수도 있다.

하지만 설계는 변경과 관련된 것이라는 점을 기억하라.

변경에 유연하게 대처할 수 있는 설계가 대부분의 경우에 정답일 가능성이 높다.

따라서 다음과 같이 정리할 수 있다.

> (코드 재사용을 위해서는) 객체 합성이 클래스 상속보다 더 좋은 방법이다.

<br>

상속과 합성은 재사용의 대상이 다르다.

상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 인터페이스에 대한 의존성으로 변경할 수 있다.

따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다.

다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.

_대부분의 경우에 상속 대신 합성을 사용할 수 있을까? 앞의 phone 예제에서도?_

```
객체지향 시스템에서 기능을 재사용할 수 있는 가장 대표적인 기법은 클래스 상속과 객체 합성이다.

서브클래싱에 의한 재사용을 화이트박스 재사용이라고 부른다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트박스인 셈이다.

객체를 합성하려면 합성할 객체들의 인터페이스를 명확하게 정의해야만 한다. 이런 스타일의 재사용을 블랙박스 재사용이라고 하는데, 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.
```

_정처기 시험범위에 화이트박스 테스트와 블랙박스 테스트가 나오는데.. 두루 사용되는 용어인가보다_

<br>

### 01. 상속을 합성으로 변경하기

코드 재사용을 위해 상속을 남용했을 때 직면할 수 있는 세 가지 문제점이 있다.

- 불필요한 인터페이스 상속 문제
- 메서드 오버라이딩의 오작용 문제
- 부모 클래스와 자식 클래스의 동시 수정 문제

합성을 사용하면 상속이 초래하는 세 가지 문제점을 해결할 수 있다.

상속을 합성으로 바꾸는 방법은 매우 간단한데 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.

<br>

// #### 불필요한 인터페이스 상속 문제: java.util.Properties와 java.util.Stack

#### 메서드 오버라이딩의 오작용 문제: InstrumentedHashSet

Set의 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 HashSet 인스턴스에게 동일한 메서드 호출을 그대로 전달함 => **포워딩(forwading)**

동일한 메서드를 호출하기 위해 추가된 메서드 => **포워딩 메서드(forwarding method)**

포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법이다.

<br>

#### 부모 클래스와 자식 클래스의 동시 수정 문제: PersonalPlaylist

(이 경우에는 합성으로 변경하더라도 가수별 노래 목록을 유지하기 위해 Playlist와 PersonalPlaylist를 함께 수정해야함)

그렇다고 하더라도 여전히 상속보다는 합성을 사용하는 게 더 좋은데, 향후에 (Playlist의) 내부 구현을 변경하더라도 파급효과를 최대한 (PersonalPlaylist) 내부로 캡슐화할 수 있기 때문이다.

대부분의 경우 구현에 대한 결합도나는 인터페이스에 대한 결합이 더 좋다는 사실을 기억하라.

<br>

상속과 비교해서 합성은 안정성과 유연성이라는 장점을 제공한다고 말했다. 지금까지는 합성을 사용해서 변경에 불안정한 코드를 안정적으로 유지하는 방법을 살펴봤다.

이제 두 번째 장점인 유연성을 살펴보자. 이 경우에도 핵심은 동일하다. 구현이 아니라 인터페이스에 의존하면 설계가 유연해진다는 것이다.

<br>

### 02. 상속으로 인한 조합의 폭발적인 증가

상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다.

가장 일반적인 상황은 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우다.

일반적으로 다음과 같은 두 가지 문제점이 발생한다.

- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
- 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

합성을 사용하면 상속으로 인해 발생하는 클래스의 증가와 중복 코드 문제를 간단하게 해결할 수 있다.

<br>

#### 기본 정책과 부가 정책 조합하기

(phone 예제에 새로운 요구사항-부가 정책-을 추가해보자)

// #### 상속을 이용해서 기본 정책 구현하기

#### 기본 정책에서 세금 정책 조합하기

부모 클래스의 메서드를 재사용하기 위해 super 호출을 사용하면 원하는 결과를 쉽게 얻을 수는 있지만 자식 클래스와 부모 클래스 사이의 결합도가 높아지고 만다.

결합도를 낮추는 방법은 자식 클래스가 부모 클래스의 메서드를 호출하지 않고도 부모 클래스에 추상 메서드를 제공하는 것이다.

<br>

부모 클래스에 추상 메서드를 추가하면 모든 자식 클래스들이 추상 메서드를 오버라이딩해야 하는 문제가 발생한다.

자식 클래스의 수가 적다면 큰 문제가 아니겠지만 자식 클래스의 수가 많을 경우에는 꽤나 번거로운 일이 될 수밖에 없다.

<br>

모든 추상 메서드의 구현이 동일하다는 사실에도 주목하기 바란다.

유연성은 유지하면서도 중복 코드를 제거할 수 있는 방법은 추상 메서드에 대한 기본 구현을 함께 제공하는 것이다.

<br>

// #### 기본 정책에 기본 요금 할인 정책 조합하기

#### 중복 코드의 덫에 걸리다

(부가 정책은 자유롭게 조합할 수 있어야 하고 적용되는 순서 역시 임의로 결정할 수 있어야 함
=> 상속을 통해 해결하려면 모든 가능한 조합별로 자식 클래스를 하나씩 추가하는 것임)

(이런 상속 계층은 복잡해보인다는 단점도 있으나 더 큰 문제는 새로운 정책을 추가하기 어렵다는 것)

상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 **클래스 폭발(class explosion)** 문제 또는 **조합의 폭발(combinational explosion)** 문제라고 부른다.

클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생하는 문제다.

컴파일타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에 자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것뿐이다.

<br>

클래스 폭발 문제는 새로운 기능을 추가할 때뿐만 아니라 기능을 수정할 때도 문제가 된다.

여러 클래스 안에 중복돼있는 코드를 수정하려면 모든 클래스를 찾아 동일한 방식으로 수정해야 할 것이다.

이 클래스 중에서 하나라도 누락한다면 세금이 부과되지 않는 버그가 발생하고 말 것이다.

<br>

이 문제를 해결할 수 있는 최선의 방법은 상속을 포기하는 것이다.

<br>

### 03. 합성 관계로 변경하기

상속 관계는 컴파일타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.

따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야 한다. (=> 클래스 폭발)

<br>

합성은 컴파일타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.

합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.

<br>

(8장에서 컴파일타임 의존성과 런타임 의존성의 거리가 멀수록 설계가 유연해진다고 했던 것을 기억하라.)

상속을 사용하는 것은 컴파일타임의 의존성과 런타임의 의존성을 동일하게 만들겠다고 선언하는 것이다.

따라서 상속을 사용하면 부모 클래스와 자식 클래스 사이의 관계가 정적으로 고정되기 때문에 실행 시점에 동적으로 관계를 변경할 수 있는 방법이 없다.

<br>

상속과 달리 합성 관계는 런타임에 동적으로 변경할 수 있다.

합성을 사용하면 컴파일타임 의존성과 런타임 의존성을 다르게 만들 수 있다.

(사실 8장에서 살펴본 유연한 설계를 만들기 위한 대부분의 의존성 관리 기법은 상속이 아닌 합성을 기반으로 한다.)

클래스 폭발 문제를 해결하기 위해 합성을 사용하는 이유는 런타임에 객체 사이의 의존성을 자유롭게 변경할 수 있기 때문이다.

<br>

합성을 이용하면 구현 시점에 정책들의 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계ㅡㄹ 유연하게 변경할 수 있게 된다.

상속이 조합의 결과를 개별 클래스 안으로 밀어 넣는 방법이라면 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법을 사용하는 것이라고 할 수 있다.

컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점인 것이다.

<br>

물론 컴파일 타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상승하기 때문에 코드를 이해하기 어려워지는 것 역시 사실이다.

하지만 설계는 변경과 유지보수를 위해 존재한다는 사실을 기억하라.

설계는 트레이드오프의 산물이다.

대부분의 경우에는 단순한 설계가 정답이지만 변경에 따르는 고통이 복잡성으로 인한 혼란을 넘어서고 있다면 유연성의 손을 들어주는 것이 현명한 판단일 확률이 높다.

<br>

아이러니하게도 변경하기 편리한 설계를 만들기 위해 복잡성을 더하고 나면 원래의 설계보다 단순해지는 경우를 종종 볼 수 있다.

<br>

// #### 기본 정책 합성하기
// #### 부가 정책 적용하기
#### 기본 정책과 부가 정책 합성하기

합성은 상속을 사용항 설계보다 복잡하고 정해진 규견에 따라 객체를 생성하고 조합해야 하기 때문에 처음에는 코드를 이해하기 어려울 수도 있다.

하지만 일단 설계에 익숙해지고 나면 객체를 조합하고 사용하는 방식이 상속을 사용한 방식보다 더 예측 가능하고 일관성이 있다는 사실을 알게 될 것이다.

<br>

#### 새로운 정책 추가하기

합성을 통해 우리는 오직 하나의 클래스만 추가하고 런타임에 필요한 정책들을 조합해서 원하는 기능을 얻을 수 있다.

이 설계를 필요한 조합의 수만큼 매번 새로운 클래스를 추가해야 했던 상속과 비교해보라.

왜 많은 사람들이 그렇게 코드 재사용을 위해 상속보다는 합성을 사용하라고 하는지 그 이유를 이해할 수 있을 것이다.

<br>

더 중요한 것은 요구사항을 변경할 때 오직 하나의 클래스만 수정해도 된다는 것이다.

변경 후의 설계는 단일 책임 원칙을 준수하고 있는 것이다.

<br>

#### 객체 합성이 클래스 상속보다 더 좋은 방법이다

객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법은 상속이다.

하지만 상속은 코드 재사용을 위한 우아한 해결책은 아니다.

상속은 부모 클래스의 세부적인 구현에 자식 클래스를 강하게 결합시키기 때문에 코드의 진화를 방해한다.

<br>

코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 합성을 이용하는 것이다.

상속이 구현을 재사용하는 데 비해 합성은 객체의 인터페이스를 재사용한다.

<br>

여기서 한 가지 의문이 들 것이다. 그렇다면 상속은 사용해서는 안 되는 것인가? 상속을 사용해야 하는 경우는 언제인가?

이 의문에 대답하기 위해서는 먼저 상속을 구현 상속과 인터페이스 상속의 두 가지로 나눠야 한다는 사실을 이해해야 한다.

그리고 이번 장에서 살펴본 상속에 대한 모든 단점들은 구현 상속에 국한된다는 점 또한 이해해야 한다.

<br>

### 04. 믹스인

**믹스인(minin)** 은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다.

합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.

<br>

믹스인이 상속과 유사해보일 수 있지만 둘은 다르다.

상속의 진정한 목적은 자식 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것이다.

반면 믹스인은 말 그대로 코드를 다른 코드 안에 섞어 넣기 위한 방법이다.

<br>

하지만 상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성할 수 있다.

뒤에서 살펴보겠지만 믹스인은 코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지 않는다.

믹스인은 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법이다.

<br>

처음 믹스인을 접하면 개념을 이해하기가 다소 어려울 수도 있는데 코드를 섞어 넣는다는 기본 개념을 구현하는 방법이 언어마다 다르기 때문이다.

그 방법이 무엇이건 코드를 다른 코드 안에 유연하게 섞어 넣을 수 있다면 믹스인이라고 부를 수 있다.

<br>

믹스인은 Flavors라는 언어에서 처음으로 도입됐고 이후 Flavors의 특징을 흡수한 CLOS에 의해 대중화됐다.

(여기서는 스칼라 언어에서 제공하는 트레이트(trait)를 이용해 믹스인 구현)

_가볍게 읽어보고 패스_
_C#에 대해서도 검색해보니 구현 방식을 제공하는 건 아닌 듯_

<br>

### 생각

이번 장을 읽고 구현 상속을 사용했던 부분을 가능하면 합성으로 리팩터링하려고 했다.

물론 가능한 방법이 떠올랐으나 하지 않는 편이 낫겠다고 스스로 결론을 내렸다.

강하게 결합되어 있는 것도 맞고, 우아한 방법도 아니지만 변경 가능성이 매우 적은 부분이라 유연성이 필요 없고 코드가 명확한 게 낫다고 생각했기 때문이다.

(예전 논의 때 이야기 한 프로퍼티 캡슐화와 유사하게 현재 프로젝트에 맞는 방식을 선택했다고 생각한다.)

하지만 책에서 다룬 방식은 사이즈가 더 큰 설계, 변동 가능성이 더 큰 설계에서 분명이 필요하리라 생각된다.

_너무 작은 단위의 게임만 만들어봤나 싶기도 하다._

그래도 다른 방법이 있다는 것을 인지한 것 자체로도 나중에 설계를 할 때 큰 도움이 될 것이라고 생각한다.

### 논의사항

_(영 생각이 안나서 이번엔 패스하겠습니다..)_