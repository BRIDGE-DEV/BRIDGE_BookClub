# CHAPTER02_객체지향프로그래밍

# 정리

---

## **협력, 객체, 클래스**

- 객체지향은 말 그대로 “객체”에 집중해야 한다.흔히 객체지향 프로그래밍을 하면서 클래스에 집중하는 실수를 범한다. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 즉, 어떤 객체들이 어떤 상태와 행동을 가지는 지를 먼저 결정해야, 이를 토대로 올바른 클래스를 만들 수 있다.
- 어떤 기능을 수행하기 위해선 **객체 간 협력이 반드시 필요하다.**객체는 고립된 존재가 아닌, 공동체의 일원으로서 서로 협력하는 존재이다.객체를 협력자로 바라보면, 하나의 객체가 맡는 책임이 줄어들고, 이는 곧 유연하고 확장 가능한 설계로 이어진다.

### **도메인의 구조를 따르는 프로그램 구조**

> 도메인(domain)이란 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 일컫는 말이다.
> 

객체지향 프로그래밍의 강력함은 요구사항을 분석하는 초기 단계부터, 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있는 데에서 나온다.

요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에, 도메인을 구성하는 개념들이 프로그램 객체와 클래스로 매끄럽게 연결될 수 있다.

![https://ngwoon.github.io/assets/images/post/Book/objects/2022-03-27-chapter2/%EC%98%81%ED%99%94_%EC%98%88%EB%A9%94_%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84_%EA%B5%AC%EC%84%B1%ED%95%98%EB%8A%94_%ED%83%80%EC%9E%85%EB%93%A4%EC%9D%98_%EA%B5%AC%EC%A1%B0.jpg](https://ngwoon.github.io/assets/images/post/Book/objects/2022-03-27-chapter2/%EC%98%81%ED%99%94_%EC%98%88%EB%A9%94_%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84_%EA%B5%AC%EC%84%B1%ED%95%98%EB%8A%94_%ED%83%80%EC%9E%85%EB%93%A4%EC%9D%98_%EA%B5%AC%EC%A1%B0.jpg)

![https://ngwoon.github.io/assets/images/post/Book/objects/2022-03-27-chapter2/%EB%8F%84%EB%A9%94%EC%9D%B8_%EA%B0%9C%EB%85%90%EC%9D%98_%EA%B5%AC%EC%A1%B0%EB%A5%BC_%EB%94%B0%EB%A5%B4%EB%8A%94_%ED%81%B4%EB%9E%98%EC%8A%A4_%EA%B5%AC%EC%A1%B0.jpg](https://ngwoon.github.io/assets/images/post/Book/objects/2022-03-27-chapter2/%EB%8F%84%EB%A9%94%EC%9D%B8_%EA%B0%9C%EB%85%90%EC%9D%98_%EA%B5%AC%EC%A1%B0%EB%A5%BC_%EB%94%B0%EB%A5%B4%EB%8A%94_%ED%81%B4%EB%9E%98%EC%8A%A4_%EA%B5%AC%EC%A1%B0.jpg)

## **인터페이스, 구현 분리**

객체의 내부와 외부를 명확히 구분할수록 객체의 자율성이 높아지고, 프로그래머의 구현 자유도가 높아진다.

**캡슐화**와 **접근 제어**를 통해 객체의 내부, 외부를 명확히 구분할 수 있다.

- 캡슐화 (encapsulation)
    - 데이터와 기능(프로세스)을 객체 내부로 함께 묶는 것 데이터 = 객체의 상태(status) 기능 = 객체의 행동(behavior)
- 접근 제어 (access control)
    - 외부에서의 접근을 통제하는 기능
    - 접근 수정자(access modifier) ***를 통해 실현할 수 있다.

캡슐화와 접근 제어를 통해 객체는 두 부분으로 나뉜다.

- 인터페이스
    - 외부에서 접근 가능한 부분
- 구현
    - 외부에서 접근 불가능한 부분

이처럼 객체의 내부와 외부를 분리하면 다음과 같은 이점이 있다.

- 외부 객체는 이 객체의 내부 구현을 몰라도 된다. 단지 메세지를 전달하고, 원하는 응답을 받으면 된다.
- 외부 객체에서 실수로 이 객체의 데이터를 조정하는 일을 방지할 수 있다.
- 이 객체의 내부 구현을 변경할 일이 있어도, 인터페이스만 유지한다면 그것이 외부 객체에 영향을 주지 않는다.

### **객체의 협력이란**

절차 지향에서는 함수를 “호출” 한다고 표현하지만, **객체 지향에서는 “메세지를 전달” 한다고 표현한다.**

객체가 다른 객체와 상호 작용하기 위해 메세지를 전송하면, 그 메세지를 수신한 객체는 메세지를 처리할 방법을 자율적으로 결정한다. 객체가 메세지를 처리하는 자신만의 방법을 **메서드**라고 한다.

> **메세지와 메서드는 분명히 다른 개념이다.**
> 
> 
> 메세지는 처리가 요구되는 작업 자체를 의미하고, 메서드는 메세지의 처리 방법을 의미한다.
> 
> 메세지와 메서드의 구분에서 **다형성 (polymorphism)** 의 개념이 출발한다.
> 

자바와 같은 정적 타입 언어는 컴파일 시 메서드가 고정되므로, 객체가 메세지 처리 방법을 자율적으로 결정한다는 말이 어색하게 보일 수 있다.

하지만 Ruby나 Smalltak와 같은 동적 타입 언어에서는 런타임 시 다양한 메서드로 메세지를 처리할 수 있다는 점을 알고 넘어가자.

## **상속과 다형성**

Movie 클래스를 만들 때, 생성자로 DiscountPolicy 타입의 매개변수를 받았다. DiscountPolicy는 추상클래스일 뿐 구현체가 아니다. 그렇다면 프로그램 실행 시 Movie 객체의 할인 정책은 어떻게 결정되는 걸까? 여기서 객체지향의 특징인 상속과 다형성의 개념이 활용된다.

## **컴파일 시간 의존성과 실행 시간 의존성**

어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 갖거나, 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

코드 수준에서 보면, Movie 클래스는 DiscountPolicy에만 의존하고 있다.

그러나 런타임 시점에서 보면, Movie 객체가 생성될 때 생성자에 AmountDiscountPolicy나 PercentDiscoutPolicy 객체를 전달하고 있다.

이렇게 코드 수준에서의 의존성과 런타임 수준에서의 의존성이 서로 다를 수 있다.

= 클래스 의존성과 객체 의존성이 다를 수 있다.

**상속**을 통해 자식 클래스는 부모 클래스가 갖고 있는 모든 인터페이스를 소유한다. 즉, 자식 클래스는 부모 클래스를 대신할 수 있다.

Movie 객체는 DiscountPolicy 객체에게 “할인할 금액을 알려줘 (calcDiscountAmount)” 라는 메세지를 보낼 뿐, 런타임 시 어떤 객체가 이 메세지를 처리하는지는 관심이 없다. 그저 그 메세지를 정상적으로 처리하고, 올바른 응답을 돌려주면 된다.

영화별 할인 정책에 따라 금액 할인 정책을 사용하는 영화는 AmountDiscountPolicy 객체가 메세지를 처리할 것이고, 비율 할인 정책을 사용하는 영화는 PercentDiscountPolicy 객체가 메세지를 처리할 것이다.

이렇듯 Movie 객체는 동일한 메세지를 전송하지만, 실제로 어떤 메서드가 실행될 것인지는 메세지를 수신하는 객체의 클래스가 무엇인지에 따라 달라진다. 즉, 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 **다형성**이라고 한다.

> 다형성은 메세지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 런타임 시점에 결정한다. 이를 지연 바인딩 (lazy binding) 혹은 동적 바인딩 (dynamic binding) 이라 한다.
> 
> 
> 반대로 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 **초기 바인딩 (early binding)** 혹은 **정적 바인딩 (static binding)** 이라 한다.
> 

## **추상화와 유연성**

추상화를 사용하면 두 가지 이점을 얻을 수 있다.

- 요구사항의 정책을 높은 수준에서 서술할 수 있다.
- 유연한 설계가 가능하다.

### **NoneDiscountPolicy의 추가**

실습 링크 - movie-reservation/just-add-none-discount-policy branch

영화 예매 시스템의 요구사항에는 “할인 정책을 적용하지 않을 수도 있다.” 라는 항목도 있었다. 이를 위해 DiscountPolicy를 상속한 NoneDiscountPolicy를 만들었다.

이 코드에는 한 가지 문제점이 있는데, NoneDiscountPolicy에서 오버라이딩한 getDiscountAmount에 메세지가 도달하지 못한다. 애초에 DiscountPolicy의 calcDiscountAmount에서 할인 조건이 없다면 할인 금액을 0원으로 책정해 버렸기 때문이다.

DiscountPolicy가 NoneDiscountPolicy의 책임까지 도맡아 버린 상황이다. 이는 잘못된 설계이며, 개선안이 필요하다. 그 개선안은 아래와 같다.

![https://ngwoon.github.io/assets/images/post/Book/objects/2022-03-27-chapter2/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C_%EA%B5%AC%ED%98%84%ED%95%9C_DiscountPolicy_%EA%B3%84%EC%B8%B5.jpg](https://ngwoon.github.io/assets/images/post/Book/objects/2022-03-27-chapter2/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C_%EA%B5%AC%ED%98%84%ED%95%9C_DiscountPolicy_%EA%B3%84%EC%B8%B5.jpg)

## **상속, 합성**

- 상속 부모 클래스의 구현 코드를 재사용하기 위해 상속을 활용하는 것을 **구현 상속** 또는 **서브클래싱**이라 한다. 서브클래싱의 문제에는 두 가지가 있다.
    - 캡슐화 위반
        - 자식 클래스가 부모 클래스의 내용을 자세히 알아야 된다.
        - 이 때문에 자식 클래스가 부모 클래스에 강하게 결합되고, 부모 클래스의 변경이 자식 클래스에 영향을 미칠 확률이 높아진다.
    - 유연하지 못한 설계
        - 상속은 부모 클래스와 자식 클래스의 관계를 컴파일 시점에 결정한다. 즉, 런타임 시점의 동적 바인딩이 불가능하다.
        - Movie 클래스를 상속한 AmountDiscountMovie와 PercentDiscountMovie 클래스를 사용하는 설계에서는, 런타임 시점에서 영화의 금액 할인 정책과 비율 할인 정책을 자유롭게 변경하기 어렵다.
- 합성인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 말한다.Movie 클래스는 DiscountPolicy 인터페이스를 멤버 변수로 갖는다. 런타임 시점에 DiscountPolicy에 어떤 인스턴스가 담겨 있던, 그 인스턴스가 calcDiscountAmount 메세지를 정상적으로 처리할 수 있다면 Movie는 아무런 상관이 없다. 합성은 서브클래싱의 단점 두 가지를 모두 보완할 수 있다.
    - 재사용이 필요한 코드를 독립적으로 분리하므로, 캡슐화를 위반하지 않는다.
    - 의존 인스턴스를 비교적 쉽게 교체할 수 있으므로, 유연한 설계라고 볼 수 있다.

> 상속은 클래스를 통해 강하게 결합되지만, 합성은 메세지를 통해 느슨하게 결합된다.
> 

# 논의사항

---

설계는 균형의 예술. 트레이드 오프의 산물.

무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.

이 문장들을 보고 나는 과연 트레이드 오프를 잘 하고 있는지 다시 한번 생각하는 계기가 됐습니다.여러분은 트레이드 오프를 잘 하고 계신가요? 저 같은 경우 사실 책에서나 강의에서나 좋다고 하는 기준을 그냥 적당히 따라하려고 노력하는 수준의 불과한데요. 각자의 트레이드 오프의 기준이 있다면 궁금합니다.