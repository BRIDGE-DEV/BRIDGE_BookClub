# CHAPTER01_객체설계

# 정리

---

## 소프트웨어 모듈의 목적 세 가지

1. **실행 중 제대로 동작**해야 한다.
2. 모듈은 **변경을 위해 존재**한다. 즉, 변경하기 어려운 모듈은 제대로 동작하더라도 리팩토링할 필요가 있다.
3. 코드를 **읽는 사람이 이해하기 편해**야 한다. 즉, 코드의 흐름이 상식선에서 예상 가능한 코드여야 한다.

## **소극장 티켓 판매**

- Theater 클래스는 Audience, Bag, Ticket, TicketOffice 무려 네 개의 클래스에 의존하고 있다. 이 중 하나의 코드가 변경되면, Theater 클래스도 변경되어야 할 확률이 높다.
- Theater 클래스의 enter()를 보고, 어떤 과정으로 진행되는건지 한 눈에 이해하기 어렵다. 목적1은 만족하지만, 목적 2, 3은 만족하지 못한다.
- 이같은 문제가 발생하는 이유는 “예상을 빗나가는 코드” & “변경에 취약” 하기 때문이다. 
Theater의 enter() 내부를 살펴보면, Audience와 TicketSeller는 수동적이다. **객체지향 패러다임에서 객체는 자신의 데이터를 자신이 직접 관리해야 한다.** 현재 코드는 Theater는 “절차” 를 갖고 있고, 나머지 클래스들은 단지 “데이터” 로써의 역할만 수행하는 **절차지향적 패러다임**이다.
- **해결 방법**
    - 객체가 **자율적**으로 자신의 데이터를 자신이 관리하게 하기.
        - **캡슐화**를 이용해 객체의 데이터를 숨기고, 외부에 인터페이스를 제공.
        - 객체의 자율성을 높이면 객체 간 결합도 및 의존성은 낮아지고, 응집도는 상승한다.

## **객체지향 패러다임 설계의 핵심**

- **객체의 자율성**을 높이자! 자율성을 높인다는 건, 객체가 **자신의 데이터를 자신이 직접 관리**하는 것이다. 아울러 **캡슐화**를 통해 **외부에는 반드시 필요한 메서드(인터페이스)만 노출**하자. 객체의 자율성을 높이면, 객체 간 **의존성과 결합도는 낮아지고 응집도는 상승**한다. 실세계에서는 수동적인 객체라도, **프로그래밍 세계에서 모든 객체는 자율적**이어야 한다. **(= 의인화)**
- 객체는 자신의 책임(역할)만 관리하고, **그 외 관심사는 다른 객체에게 요청**한다.
- 어느 정도 객체지향 패러다임에 맞게 설계를 했다면, 이후부터는 **trade-off**이다. 객체지향적으로 설계하면 의존성이 항상 낮아지는 것은 아니다. (ex. 예제 코드에서, TicketOffice와 Audience의 의존성이 추가된 상황)

# 논의사항

---

여러분은 처음 코드를 짜기 시작할 때 각 객체의 역할과 책임을 생각하며 코드를 짜 나가시나요? 코드 설계 및 구현 방식은 어떤 식으로 진행하시는지 궁금합니다. 

정답이 따로 있지는 않겠지만, 코드를 짜다 막히면 문득 다른 사람들은 어떤 식으로 코드를 시작해 나가는지 궁금해질 때가 있거든요. 배워가고 싶습니다.

일단 저의 경우는 머릿속이나 글로 완벽히 구조를 그리고 코딩을 시작해 본 적은 한번도 없습니다.

저 같은 경우는 일단 머릿속에 떠오르는 대로 하나의 스크립트에 모든 기능을 넣은 뒤, 책임을 분리 해야 할 것 같은 시점이 오면(가독성이 현저히 떨어지게 되면) 하나 씩 분리해가면서 스크립트를 생성하곤 합니다. 좋은 방법이라고 볼 수는 없겠네요.. 여기서도 MBTI P 80%의 성격이 드러나나 봅니다.