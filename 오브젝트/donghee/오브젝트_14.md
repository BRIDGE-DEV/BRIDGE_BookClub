# 14장 일관성 있는 협력

## 정리

객체는 협력을 위해 존재한다. 협력은 객체가 존재하는 이유와 문맥을 제공한다. 잘 설계된 애플리케이션은 이해하기 쉽고, 수정이 용이하며, 재사용 가능한 협력의 모임이다.

유사한 요구사항을 계속 추가해야 하는 상황에서 각 협력이 서로 다른 패턴을 따를 경우에는 전체적인 설계의 일관성이 서서히 무너지게 된다.

객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다. 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다. 일관성 있는 설계가 가져다 주는 큰 이익은 코드가 이해하기 쉬워진다는 것이다.

가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라. 유사한 기능을 구현하기 위해 유사한 협력 방식을 따를 경우 코드를 이해하기 위해 필요한 것은 약간의 기억력과 적응력뿐이다.

### 01 핸드폰 과금 시스템 변경하기

**기본 정책 확장**

일반 요금제와 심야 할인 요금제, 두 가지이던 기본 정책을 4가지 방식으로 확장하자.

- 고정요금 방식: 일정 시간 단위로 동일한 요금 부과
- 시간대별 방식: 각 구간별로 서로 다른 요금 부과
- 요일별 방식: 요일별로 요금 차등 부과
- 구간별 방식: 전체 통화 시간을 일정한 통화 시간에 따라 나누고 각 구간별로 요금 차등 부과

**고정요금 방식 구현하기**

기존의 RegularPolicy 클래스의 이름을 FixedFeePolicy로 수정하기만 하면 된다.

**시간대별 방식 구현하기**

기간을 편하게 관리할 수 있는 DateTimeInterval 클래스를 추가한다.

통화 기간을 일자별로 분리하고, 분리된 기간을 다시 시간대별 규칙에 따라 분리해 요금을 계산한다. 분리된 기간들을 DateTimeInterval 인스턴스들을 담는 List로 관리하자.

**요일별 방식 구현하기**

요일별 방식을 개발하는 프로그래머는 규칙을 DayOfWeekDiscountRule이라는 하나의 클래스로 구현하는 것이 더 나은 설계라고 판단했다. DayOfWeekDiscountPolicy 안에 DayOfWeekDiscountRule 인스턴스를 포함해 요금을 계산하도록 한다.

**구간별 방식 구현하기**

구간별 방식은 FixedFeePolicy를 상속한 DurationDiscoutRule을 추가해 규칙을 정의하도록 한다.

현재 구현의 가장 큰 문제점은 이 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것이다. 다시 말해서 개념적으로는 연관돼 있지만 구현 방식에 있어서는 완전히 제각각이다.

어떤 방식을 선택하더라도 구간별 방식을 구현하는 데에는 문제가 없다. 하지만 일관성이라는 측면에서는 문제가 더 커지게 된다. 또한 서로 다른 구현 방식은 코드를 이해하는 데 오히려 방해가 된다. 결론은 유사한 기능을 서로 다른 방식으로 구현해서는 안 된다는 것이다.

### 02 설계에 일관성 부여하기

일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것이다.

두 번째 조언은 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보라는 것이다.

모든 경우에 적합한 패턴을 찾을 수 있는 것은 아니다. 따라서 협력을 일관성 있게 만들기 위해 다음과 같은 기본 지침을 따르자.

- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.

**조건 로직 대 객체 탐색**

객체지향은 조건 로직을 만드는 대신 조금 다른 접근 방식을 취한다. 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다.

다형성은 바로 이런 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법이다.

조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다른 클래스를 더 작은 클래스들로 분리해야 한다. 클래스를 분리하기 위해서는 ‘변경의 이유와 주기’라는 기준을 따라야 한다.

클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야 한다.

협력을 일관성 있게 만드는 핵심은 훌륭한 추상화다. 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다.

**캡슐화 다시 살펴보기**

캡슐화는 데이터 은닉 이상이다.

GOF의 조언에 따르면 캡슐화란 단순히 데이터를 감추는 것이 아니다. 소프트웨어 안에서 변할 수 있는 모든 ‘개념’을 감추는 것이다.

코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.

가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것이다. 서브타입 캡슐화는 인터페이스 상속을 사용하고, 객체 캡슐화는 합성을 사용한다.

이들을 적용하는 방법은 다음과 같다.

- 변하는 부분을 분리해서 타입 계층을 만든다
    
    변하는 부분들의 공통적 행동을 추상 클래스나 인터페이스로 추상화. 변하는 부분들이 이들을 상속받게 한다.
    
- 변하지 않는 부분의 일부로 타입 계층을 합성한다
    
    앞에서 구현한 타입 계층을 변하지 않는 부분에 합성한다. 변하지 않는 부분에서는 변경되는 구체적인 사항에 결합돼서는 안된다.
    

### 03 일관성 있는 기본 정책 구현하기

**변경 분리하기**

일관성 있는 협력을 만들기 위한 첫 번째 단계는 변하는 개념과 변하지 않는 개념을 분리하는 것이다. 변하지 않는 것은 ‘단위요금’과 ‘적용조건’이 모인 ‘규칙’이고, 변하는 것은 ‘적용조건’의 형식이다.

**변경 캡슐화하기**

협력을 일관성 있게 만들기 위해서는 변경을 캡슐화해서 파급효과를 줄여야 한다.

변하지 않는 부분은 기본 정책이 여러 ‘규칙’들의 집합이며, 이는 ‘적용조건’과 ‘단위요금’으로 구성된다는 것이다. 이를 FeeRule이라는 클래스에 FeeCondition 인스턴스를 가지는 형태로 구현한다. ‘적용조건’의 세부적 내용은 FeeCondition의 서브타입으로 구현한다.

**협력 패턴 설계하기**

변하는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 추상화하고 나면 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기할 수 있다.

다시 말해서 재사용 가능한 협력 패턴이 선명하게 드러나는 것이다. 이를 이용해 작업들을 객체에 대한 책임들로 할당한다.

**추상화 수준에서 협력 패턴 구현하기**

‘적용조건’의 추상화인 FeeCondition에서 시작해, 추상화에 해당하는 요소들로 협력을 구현해본다. 변하지 않는 요소와 추상적인 요소만으로도 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다.

**구체적인 협력 구현하기**

- 시간대별 정책
    
    시간대별 정책의 적용조건을 구현하는 TimeOfDayFeeCondition을 구현한다. 이는 협력 안에서 FeeCondition을 대체할 수 있어야 한다.
    
- 요일별 정책
    
    요일별 정책의 적용조건을 구현하는 DayOfWeekFeeCondition을 구현한다. 이 역시 FeeCondition 인터페이스를 구현한다.
    
- 구간별 정책
    
    이 또한 DurationFeeCondition 클래스를 추가해 FeeCondition 인터페이스를 구현한다. 협력이 일관성 있게 만들어진다.
    

기본 정책을 추가하기 위해 규칙을 지키는 것보다 어기는 것이 더 어렵다는 점에 주목하라. 일관성 있는 협력은 개발자에게 확장 포인트를 강제하기 때문에 정해진 구조를 우회하기 어렵게 만든다.

유사한 기능에 대해 유사한 협력을 적용하는 것은 객체지향 시스템에서 **개념적 무결성**을 유지할 수 있는 가장 효과적인 방법이다.

**협력 패턴에 맞추기**

비록 설계를 약간 비트는 것이 조금은 이상한 구조를 낳더라도 전체적으로 일관성을 유지할 수 있는 설계를 선택하는 것이 현명하다.

처음에는 일관성을 유지하는 것처럼 보이던 협력 패턴이 시간이 흐르면서 점차 금이 가는 경우를 보게 된다. 이는 자연스러운 현상이다.

협력은 고정된 것이 아니다. 만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링하라.

중요한 것은 현재의 설계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지다.

---

## 느낀 점

마지막 부분이 가장 인상 깊었다. 지금까지 일관성 유지 vs 구현 구조를 깔끔하게 하기 사이에서 고민했던 적이 무척 많았는데, 구현 구조가 조금 무너지는 것이 자주 있는 일이고 일관성을 유지하라는 말이 큰 도움이 되었다.

---

## 논의사항

- ‘일관성 유지 vs 구현 구조를 깔끔하게 하기’ 사이에서 갈등했던 경험들을 얘기해보면 재밌을 것 같습니다!

전 디/버프에 대해 구현할 때 버프가 적용되고, 적용이 해제될 때의 메시지를 만들어 이를 호출되게 만들었는데, 지속성이 있는 버프를 구현할 때 이를 일관성을 유지하면서 구현해야 할까 고민했던 경험이 있습니다. 결국 일관성을 지키기 위해 코루틴 Start/Stop 식으로 해결했던 경험이 있네요.