# 6장 메시지와 인터페이스

## 정리

객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것이다. 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아진다.

객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지다. 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라.

객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 한다.

### 01 협력과 메시지

**클라이언트-서버 모델**

객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것뿐이다. 이처럼 메시지를 매개로 하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성한다.

두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 **클라이언트-서버 모델**이다. 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다. 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.

객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다. 협력에 관한 자세한 내용을 살펴보기 전 용어부터 정리하자.

**메시지와 메시지 전송**

**메시지**는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

한 객체가 다른 객체에게 도움을 요청하는 것을 **메시지 전송**이라고 부른다.

이때 메시지를 전송하는 객체를 **메시지 전송자**라고 부르고 수신하는 객체를 **메시지 수신자**라고 부른다. 클라이언트-서버 모델 관점에서 전송자는 클라이언트, 수신자는 서버라고 부르기도 한다.

메시지는 **오퍼레이션명**과 **인자**로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다. Java로 예시를 들면 ‘condition.isSatisfiedBy(screening)’ 이 메시지 전송이다. condition이 수신자, isSatisfiedBy가 오퍼레이션명, screening이 인자이다.

**메시지와 메서드**

메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인지에 달려 있다.

메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드**라고 부른다. 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 타입에 따라 실행되는 메서드가 달라질 수 있다. 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

메시지와 메서드의 구분은 전송자와 수신자가 느슨하게 결합될 수 있게 한다. 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다. 수신자 역시 누가 메시지를 전송하는지 알 필요가 없다.

실행 시점에 메시지와 메서드를 바인딩하는 매커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

**퍼블릭 인터페이스와 오퍼레이션**

객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스**라고 부른다.

프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션**이라고 부른다. 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다. 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.

프로그래밍 언어의 관점에서 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.

**시그니처**

오퍼레이션의 이름과 파라미터 목록을 합쳐 **시그니처**라고 부른다. 일반적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.

다형성의 축복을 받기 위해서는 하나의 오퍼레이션에 대해 다양한 메서드를 구현해야만 한다.

### 02 인터페이스와 설계 품질

좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**라는 조건을 만족해야 한다.

최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다. 이는 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다. 또한 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 한다. 따라서 추상적인 오퍼레이션이 자연스럽게 인터페이스에 스며든다.

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법을 알아보자.

**디미터 법칙**

**디미터 법칙**은 협력하는 객체의 내부 구조 결합으로 인해 발생하는 문제를 해결하기 위해 제안된 원칙이다. 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로는 제한하라는 것이다. “오직 하나의 도트(.)만 사용하라”라는 말로 요약되기도 한다.

클래스의 내부 메서드는 다음 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 해야 한다.

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

디미터 법칙을 따르면 **부끄럼타는 코드(shy code)**를 작성할 수 있다. 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.

디미터 법칙이 가치 있는 이유는 클래스를 캡슐화하기 위해 따라야하는 구체적 지침을 제공하기 때문이다. 캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.

```java
screening.getMovie().getDiscountConditions
```

이와 같은 코드는 **기차 충돌**이라고 부르며 디미터 법칙을 위반한다. 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로, 전송자는 수신자의 내부 정보를 자세히 알게 된다. 따라서 수신자의 캡슐화는 무너지고 전송자가 수신자의 내부 구현에 강하게 결합된다.

디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다.

**묻지 말고 시켜라**

디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다. **묻지 말고 시켜라.**

묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 또한 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.

내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함하고 있다면 더 나은 방법은 없는지 고민해 보라. 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가? 그렇다면 해당 객체가 책임져야 하는 행동이 객체 외부로 누수된 것이다.

상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라.

하지만 단순하게 객체에게 묻지 않고 시킨다고 모든 문제가 해결되는 것은 아니다. 인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지를 서술해야 한다.

**의도를 드러내는 인터페이스**

켄트 백은 메서드를 명명하는 두 가지 방법을 설명했다. 첫 번째 방법은 메서드가 작업을 어떻게 수행하는지를 나타내도록 명명하는 것이다. 이런 스타일은 두 가지의 좋지 않은 이유가 있다.

- 메서드에 대해 제대로 커뮤니케이션하지 못한다.
- 메서드 수준에서 캡슐화를 위반한다.

메서드의 이름을 짓는 두 번째 방법은 ‘어떻게’가 아니라 ‘무엇’을 하는지를 드러내는 것이다. 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 **의도를 드러내는 선택자**라고 부른다. 켄트 백은 메서드에 의도를 드러낼 수 있는 이름을 붙이기 위해 다음과 같이 생각하기를 조언한다.

- 매우 다른 두 번째 구현을 상상하고, 그 메서드에 동일한 이름을 붙인다고 상상하라.
- 그렇게 하면 그 순간 여러분이 할 수 있는 가장 추상적인 이름을 메서드에 붙일 것이다.

에릭 에반스는 켄트 백의 의도를 드러내는 선택자를 인터페이스 레벨로 확장한 **의도를 드러내는 인터페이스**를 제시했다. 의도를 드러내는 인터페이스를 한 마디로 요약하면 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것이다.

> 방정식을 푸는 방법을 제시하지 말고 이를 공식으로 표현하라. 문제를 내라. 하지만 문제를 푸는 방법을 표현해서는 안 된다.
> 

객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.

**함께 모으기**

- 디미터 법칙을 위반하는 티켓 판매 도메인

이런 원칙들을 위반하는 코드의 모습을 살펴보자. 1장에서 살펴본 티켓 판매 도메인이다.

```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

이 코드의 문제는 Theater가 audience와 ticketSeller 내부에 포함된 객체에도 직접 접근한다는 것이다. 결과적으로 Theater는 Audience의 퍼블릭 인터페이스뿐만 아니라 내부 구조에 대해서도 결합된다. 이로 인해 Theater는 디미터 법칙을 위반하게 된다.

근본적으로 디미터 법칙을 위반하는 설계는 **인터페이스와 구현의 분리 원칙**을 위반한다. 퍼블릭 인터페이스에 getBag을 포함시키는 순간 객체의 구현이 퍼블릭 인터페이스를 통해 외부로 새어나가 버리고 만다.

디미터 법칙을 위반한 코드는 사용하기도 어렵다. 클라이언트 객체의 개발자가 Audience의 퍼블릭 인터페이스뿐만 아니라 내부 구조까지 속속들이 알고 있어야 하기 때문이다.

이를 수정하는 일반적인 방법은 Audience와 TicketSeller의 내부 구조를 묻는 대신 Audience와 TicketSeller가 직접 자신의 책임을 수행하도록 시키는 것이다.

- 묻지 말고 시켜라

TicketSeller와 Audience는 묻지 말고 시켜라 스타일을 따르는 퍼블릭 인터페이스를 가져야 한다.

```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void setTicket(Audience audience) {
        ticketOffice.plusAmount(audience.setTicket(ticketOffice.getTicket()));
    }
}
```

```java
public class Audience {
    private Bag bag;

    public Audience(Bag bag) {
        this.bag = bag;
    }

    public Long setTicket(Ticket ticket) {
        return bag.setTicket(ticket);
    }
}
```

```java
public class Bag {
    private Long amount;
    private Invitation invitation;
    private Ticket ticket;

    public Bag(long amount) {
        this(null, amount);
    }

    public Bag(Invitation invitation, long amount) {
        this.invitation = invitation;
        this.amount = amount;
    }

    public Long setTicket(Ticket ticket) {
        if (hasInvitation()) {
            this.ticket = ticket;
            return 0L;
        } else {
            this.ticket = ticket;
            minusAmount(ticket.getFee());
            return ticket.getFee();
        }
    }

    private boolean hasInvitation() {
        return invitation != null;
    }

    private void minusAmount(Long amount) {
        this.amount -= amount;
    }
}

```

다음과 같이 Audience, TicketSeller, Bag를 디미터 법칙을 위반하지 않게, 묻지 말고 시켜라 스타일을 따르게 수정한다.

디미터 법칙과 묻지 말고 시켜라 스타일을 따르면 자연스럽게 자율적인 객체로 구성된 유연한 협력을 얻게 된다. 일단 디미터 법칙과 묻지 말고 시켜라 스타일을 따르는 인터페이스를 얻었다면 인터페이스가 클라이언트의 의도를 올바르게 반영했는지를 확인해야 한다.

- 인터페이스에 의도를 드러내자

Audience, TicketSeller, Bag의 setTicket은 미묘하게 다른 의미를 지니고 있지만, 같은 이름을 가지고 있어 클라이언트 개발자가 헷갈릴 우려가 있다. 클라이언트의 의도가 분명하게 드러나도록 퍼블릭 인터페이스를 개선해보자.

```java
public class TicketSeller {
	public void sellTo(Audience audience) {...}
}

public class Audience {
	public Long buy(Ticket ticket) {...}
}

public class Bag {
	public Long hold(Ticket ticket) {...}
}
```

의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있게 해준다.

### 03 원칙의 함정

이들은 절대적인 법칙이 아니다. 소프트웨어 설계에 법칙이란 존재하지 않는다.

잊지 말아야 하는 사실은 설계가 트레이드오프의 산물이라는 것이다.

원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라. 원칙을 아는 것보다 중요한 것은 언제 원칙이 유용하고 유용하지 않은지를 판단하는 능력을 기르는 것이다.

**디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다**

디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.

하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다. 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.

다음과 같은 질문을 해보자. 과연 여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는가?

**결합도와 응집도의 충돌**

수신자의 캡슐화를 저해시킨다고 판단해 수신자 객체에 직접 상태를 조사해 결정을 내리게 하는 위임 메서드를 추가하는 경우가 있다. 모든 상황에서 맹목적으로 위임 메서드를 추가하는 것은 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다. 결과적으로는 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 응집도가 낮아진다.

가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 존재한다. 물으려는 객체가 정말 데이터인 경우도 있다. 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.

> 경우에 따라 다르다.
> 

### 04 명령-쿼리 분리 원칙

**명령-쿼리 분리 원칙**은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.

어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 **루틴**이라고 부른다. 루틴은 다시 **프로시저**와 **함수**로 구분할 수 있다. **프로시저**는 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류다. 이에 반해 **함수**는 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류다.

**명령**과 **쿼리**는 프로시저와 함수를 부르는 또 다른 이름이다. 객체의 상태를 수정하는 오퍼레이션을 **명령**이라 부르고 객체와 관련된 정보를 반환하는 오퍼레이션을 **쿼리**라고 부른다.

명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다. 한 문장으로 원칙을 요약하면 “질문이 답변을 수정해서는 안 된다”는 것이다. 이를 분리해서 얻는 장점은 무엇일까?

**반복 일정의 명령과 쿼리 분리하기**

명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어려워질 수 있다. 이는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다. 가장 깔끔한 해결책은 명령과 쿼리를 명확하게 분리하는 것이다.

퍼블릭 인터페이스를 설계할 때 부수효과를 가지는 대신 값을 반환하지 않는 명령과, 부수효과를 가지지 않는 대신 값을 반환하는 쿼리를 분리하기 바란다. 그 결과, 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다.

**명령-쿼리 분리와 참조 투명성**

쿼리는 객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관이 없다. 부수효과를 가진 명령이 호출되지 않는 한 순서와 횟수에 상관없이 호출될 수 있다.

명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 **참조 투명성**의 장점을 제한적이나마 누릴 수 있게 된다.

컴퓨터와 수학의 세계를 나누는 가장 큰 특징은 부수효과의 존재 유무다. 수학의 경우 x의 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다.

참조 투명성이란 “어떤 표현식 e가 있을 때 e의 값으로 나타는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성”을 의미한다. 부수효과가 없는 불변의 세상에서는 모든 로직이 참조 투명성을 만족시킨다. 참조 투명성을 만족하는 식은 우리에게 두 가지 장점을 제공한다.

- 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
- 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.

객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다. 하지만 명령-쿼리 분리 원칙을 사용하면 이 균열을 조금이나마 줄일 수 있다.

**책임에 초점을 맞춰라**

디미터 법칙을 준수하고 묻지 말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하는 아주 쉬운 방법이 있다. 메시지를 먼저 선택하고 그 후에 그것을 처리할 객체를 선택하는 것이다. 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다. 이것이 각 법칙에 미치는 영향을 살펴보면 다음과 같다.

- 디미터 법칙: 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다. 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.
- 묻지 말고 시켜라: 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.
- 의도를 드러내는 인터페이스: 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다. 당연히 그 이름에는 클라이언트의 의도와 요구사항이 분명하게 드러난다.
- 명령-쿼리 분리 원칙: 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것이다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.

훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다. 우리에게 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지다.

---

## 느낀 점

퍼블릭 인터페이스의 설계에 대해 직접적으로 조언해준 장이었다. 법칙이 하나하나 나올수록 바로 적용시키기 어렵다는 생각이 들었지만 차차 해봐야겠다. 꼭 법칙이 옳지는 않다는 생각을 항상 가지고 있어야겠다.

---

## 논의사항

- 이 장에서 가장 인상적인 법칙이 있다면 어떤 것인가요? 이유와 함께 공유해주세요!

저는 ‘명령-쿼리 분리 원칙’이었습니다. 그동안 한 메서드 안에 다소 난잡한 의미를 가진 로직들이 엉켜있었는데, 뭔가 찝찝하고 잘못하고 있는 기분은 들었지만 어떻게 해야할지 난감했습니다. 이는 명령과 쿼리가 붙어있어서 실행 결과를 예측하기 어려워지고, 제 자신도 알아보기 힘든 메서드가 되는 것이라는 걸 깨닫고 바로 VS 켰습니다.. ‘한 메서드에 한 가지 기능만 지정하라’라는 사실은 알고 있었지만, 좀 더 구체적으로 분리하라는 것을 알려주어 인상 깊었습니다.