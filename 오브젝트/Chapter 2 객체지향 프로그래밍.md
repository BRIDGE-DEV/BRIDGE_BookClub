
도메인(domain) : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 동일한 추상화 기법을 사용할 수 있기 때문이다. 객체라는 동일한 관점을 유지할 수 있기에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.

## 클래스 구현하기

글래스의 내부와 외부를 구분해야 하는 이유:
경계의 명확성이 객체의 자율성을 보장하는 것과 프로그래머에게 구현의 자유를 제공하기 떄문이다.

#### 자율적인 객체

1. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재다.
2. 객체는 스스로 판단하고 행동하는 자율적인 존재다.

객체지향 이전 패러다임에서는 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구현했지만 이와 달리 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리에 묶어 프로그램을 구현했다.=> 캡슐화

대부분의 객체지향 프로그래밍 언어는 캡슐화에서 더 나아가 외부에서의 접근을 통제하는 접근 제어(acces control) 메커니즘도 함께 제공한다. public private protected와 같은 접근 수정자(acces modifier)가 이와 같다.

객체 내부로의 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다. 객체지향의 핵심은 스스로 상태를 관리, 판단, 행동하는 자율적인 객체의 상호협력의 공동체를 만드는 것이다. 객체가 자율적이기 위해서는 외부의 간섭을 최소화 해야 한다. 객체가 어떤 상태에 놓여져 있는지 어떤 생각을 하는지 어떤 방식으로 일을 처리하는지 알아서는 안 되며, 결정에 직접적으로 개입하려고 해서는 안된다. 그저 객체에게 원하는 것을 요청하고 객체가 스스로 최선의 방법으로 응답할 것이라고 믿고 기다려야 한다.

*인터페이스와 구현의 분리 원칙(seperation of interface and implementation)*
캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 하나는 외부에서 접근 가능한 부분으로 *퍼블릭 인터페이스(public interface)* 라 부른다. 다른 하나는 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분인 *구현(implementation)* 이다.

일반적으로 객체의 상태는 숨기고 행동은 외부에 드러낸다. 속성은 private로 감추고 일부 메서드만 public으로 선언해야 한다. 어떤 메서드들이 서브클래스나 내부에서만 접근 가능해야 한다면 protected나 private로 선언해야 한다. 

#### 프로그래머의 자유

프로그래머는 *클라이언트 프로그래머(client programmer)* 와 *클래스 작성자(class creator)* 로 구분된다. 클래스 작성자는 새로운 데이터 타입을 프로그램에 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.

클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 프로그램을 빠르고 안정적으로 구축하는 것이다. 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 구현부를 숨기는 것이다. 구현부를 숨긴다면 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 자유롭게 내부 구현을 바꿀 수 있다. 이를 *은닉(implementation hiding)*

접근 제어 메커니즘은 클래스의 내부와 외부를 명확하게 경계 지을 수 있게 하며 클래스 작성자가 내부 구현을 은닉할 수 있게 한다. 

구현 은닉은 클래스 작성자와 클라이언트 프로그래머 둘에게 모두 유용하다. 클라이언트 프로그래머는 퍼블릭 인터페이스만 신경쓰며 프로그램을 만들 수 있어 머릿속에 저장해야 하는 지식의 양을 줄일 수 있다. 클래스 작성자는 인터페이스에 영향을 주지 않고도 내부 구현을 마음대로 바꿀 수 있다.

#### 협력에 관한 짧은 이야기

객체의 내부상태는 외부에서 접근하지 못하도록 감춰야 한다. 대신 내부의 속성들을 퍼블릭 인터페이스를 통해 접근할 수 있독 허용한다. 다른 객체는 인터페이스에 공개된 행동을 수행하도록 *요청(request)* 할 수 있다. 요청받은 객체는 자율적인 방법에 따라 요청을 처리하고 적절한 *응답(response)* 한다.

객체가 다른 객체와 상호 작용할 수 있는 유일한 방법은 *메시지를 전송(send a message)* 하는 것뿐이다. 다른 객체에게 요청이 도착하면 해당 객체가 *메시지를 수신(receive message)* 했다고 이야기 한다. 수신된 메시지를 객체가 처리하는 방법을 *메서드(method)* 라고 부른다.

메시지와 메서드를 구분하는 것에서부터 *다형성(polymorphism)* 의 개념이 출발한다.
객체가 매서드를 호출한다고 표현하지만 사실 객체는 구체적인 메서드의 내용을 모른다. 그저 적절한 메서드가 응답할 것을 믿고 메시지를 보낼 뿐이다. 메시지를 처리하는 것은 메시지를 받은 객체의 문제인 것이다.

#### 컴파일 시간 의존성과 실행 시간 의존성

코드의 의존성과 실제 실행 시점의 의존성은 다를 수 있다. 유연하고 확장성을 고려한 객체지향 설계가 가지는 특징 중 하나는 코드의 의존성과 실행시점의 의존성이 다르다는 것이다.

코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 코드의 가독성은 떨어진다.  코드를 이해하기 위해 객체의 생성시점과 연결점을 파악해야 하기 때문이다. 반면에 코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 유연해지고 확장성이 좋아진다. 
이런 의존성의 양면성이 설계가 트레이드 오프의 산물이라는 것을 잘 보여준다.

훌륭한 객체지향 설계자로 성장하기 위해서는 가독성과 유연성의 균형을 항상 고민해야 한다. 무조건 유연한 설계도 무조건 가독성이 좋은 코드도 정답이 아니다.

#### 차이에 의한 프로그래밍

상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 상속을 통해 클래스를 연결시키는 것으로 기존의 클래스가 가지는 기능을 포함시키는 새로운 클래스를 만들 수 있다.

부모클래스의 구현을 공유하면서도 행동이 다른 자식클래스를 손쉽게 만들 수 있다.
이처럼 부모 클래스와 다른 부분을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 *차이에 의한 프로그래밍(programmin by difference)* 라고 한다.


#### 상속과 인터페이스

상속이 가치 있는 이유는 부모클래스의 인터페이스를 자식 클래스가 포함한다는 것이다. 이는 상속의 일반적인 시각과는 조금 다른데,  코드를 재사용한다는 목적으로 상속을 사용한다고 생각하기 때문이다.

인터페이스는 객체가 사용할 수 있는 메시지의 목록을 정의한다. 일반적으로 자식 클래스가 부모 클래스의 인터페이스를 포함하기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
> 조금 더 생각해보면 리스코프 치환 원칙(Liskov Substitution Principle)에 대한 얘기를 할 수 있을 것 같다.

자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스 대신 사용될 수 있다. 컴파일러는 코드상에서 부모클래스가 나오는 모든 장소에 자식 클래스를 사용하는 것을 허락한다.

자식클래스가 부모 클래스를 대신하는 것을 *업캐스팅(upcasting)* 이라고 한다. 아래에 위치한 자식클래스가 위에 위치한 부모클래스로 타입 캐스팅 되는 것처럼 보이기 때문이다.

#### 다형성

예제 코드에서 Movie 클래스가 DiscountPolicy 클래스에게 메시지를 전송하지만 실행시점에서는 Movie와 협력하는 객체의 클래스가 무엇인지에 따라 달라진다. 객체가 보내는 메시지가 실제로 "어떤 메서드"를 실행시키게되는 것인지는메시지를 받은 객체의 클래스에 따라 결정되는 것이다.  이를 *다형성* 이라고 부른다.

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실에 기반한다. 프로그램을 작성할 때는 객체가 추상적인 클래스에 의존하지만 실행시점에 상호작용하는 객체는 덜 추상적인 객체에 의존한다. 이처럼 메시지와 메서드가 구분되고 파일 시간 의존성과 실행 시간 의존성의 괴리로 같은 메시지가 서로 다른 메서드를 실행시킬 수 있게 되면서 다형성이 된다.

다형성은 동일한 메시지를 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 동일한 메시지를 수신하려면 객체들의  인터페이스가 동일해야한다. 예제 코드에서 AmountDiscoutPolicy와 PercentDiscountPolicy가 다형적인 협력에 참여할 수 있는 이유는 DiscountPolicy라는 추상적인 클래스에게 동일한 인터페이스를 물려받았기 때문이고 이를 구현한 방법이 상속인 것이다.

다형성을 구현하는 방법은 다양하지만 실행될 메서드들이 컴파일 시간이 아닌 실행시점 시간에 결정된다는 공통점이 있다. 이처럼 메시지와 메서드를 실행 시점 시간에 묶는 것을 *지연 바인딩(lazy binding)* 또는 *동적 바인딩(dynamic binding)* 이라고 한다. 반대로 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 *초기 바인딩(early binding)* 또는 *정적 바인딩(static binding)* 이라고 부른다.

#### 추상화의 힘

추상화를 사용할 경우 두 가지 장점이 있다. 
1. 추상적인 개념들을 통해 프로그램의 협력 흐름을 기술할 수 있다.
	추상화를 사용하면 세부적인 내용을 무시한 채 상위 개념들만을 가지고 도메인의 중요한 개념을 설명할 수 있다.
	 세부적인 내용들이 중요한 경우도 있겠지만 상위 개념만으로 기술하는 게 나을 때가 있으며, 추상화는 필요에 따라 표현 수준을 조정할 수 있게 해준다.
	
	 추상화를 이용해 상위의 협력 흐름을 기술 하는 개념은 *프레임 워크(framework)* 나 *디자인 패턴(design pattern)* 등에서 사용되기 때문에 매우 중요하다.
 2. 기존 구현을 수정하지 않고 기능을 추가하고 확장할 수 있다.
	 추상화를 통해 상위 개념을 정의하면 추상적인 클래스에 의존시켜 설계를 유연하게 만들 수 있다.

#### 코드 재사용

상속은 코드를 재사용하기 위해 널리 사용되는 방법이지만 널리 사용되는 방법이 항상 가장 좋은 방법은 아니다. 다른 책들에서는 상속보다는 *합성(composition)* 을 더 좋은 방법이라고 이야기 한다. 합성이란 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함시켜 사용하는 것을 말한다.

예제 코드에서 Movie가 DiscountPolicy의 코드를 재사용하는 방법이 바로 합성이다. 이 설계를 상속으로 사용할 수도 있으며 Movie를 상속받아 AmountDiscountMovie와 PercentDiscountMovie라는 클래스를 추가하면 합성을 사용한 기존 방법과 기능적인 관점에서는 동일하다.

그럼에도 상속보다 합성을 사용하는 이유는 무엇일까?

#### 상속

상속은 코드를 재사용할 수 있는 기법이지만 두 가지 관점에서 단점이 있다.

 1. 캡슐화를 위반한다.
	 상속을 이용하기 위해서는 부모 클래스의 내부를 잘 알고 있어야 한다. 자식 클래스는 부모 클래스의 내부 구현을 잘 파악하고 있어야 하며 이는 결과적으로 자식 클래스와 부모 클래스가 강하게 결합되도록 만든다. 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 가능성이 크다. 결과적으로 상속을 과도하게 사용하면 변경이 어려워지는 설계가 된다.
	 
 2. 설계를 유연하게 만들지 못한다.
	 상속은 부모 클래스와 자식 클래스 사이의 관계가 컴파일 시점에 결정된다. 따라서 실행 시점에 객체의 종류를 바꾸는 것이 불가능 하다.

#### 합성

합성은 객체가 다른 객체의 인터페이스에 정의된 코드를 재사용하는 방법이다.

합성은 상속이 가지는 두 가지 문제점을 모두 해결한다. 객체의 인터페이스에 정의된 메시지를 통해 코드를 재사용하기 때문에 구현부를 캡슐화 할 수 있으며 또한 의존하는 인스턴스를 손쉽게 교체할 수 있기 때문에 설계를 유연하게 만든다.

그렇다고 상속을 절대 사용하지 말라는 얘기는 아니다. 코드 재사용의 관점에서 상속보다 합성이 대체로 옳은 방법이지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 같이 조합해서 사용할 수 밖에 없다.

**감상**
배운 것들이 정말 많은 챕터였습니다. 객체지향 패러다임에서는 "의존성을 높이지 마라", "상속을 쓰지 마라", "인터페이스에 지나치게 많은 기능을 구현하지 마라" 등등 항상 무엇을 하지말라고 많이 말합니다. 왜 하면 안되는지 개념적인 설명으로는 항상 이해가 안갔는데 구체적인 코드를 예시로 활용하다 보니 공부하는데 큰 도움이 됐습니다.

특히 상속을 잘 사용하지 않는 이유가 Movie를 상속받은 AmountDiscountMovie로 예시를 들며 변경이 어려워진다는 설명이 좋았습니다. 단순히 계층이 복잡해지고 가독성이 안좋아서라는 얘기만 듣고 상속을 안썼는데, 적절한 상황에서는 상속도 고려해봐야겠습니다.

**논의 사항**
예제코드에서는 DiscountPolicy라는 추상적인 상위 정책을 세워서 각종 금액할인이나 비율할인 등을 세부사항으로 두었습니다. 여러분들이 짰던 코드에서는 어떤 추상적 상위 정책이 있었나요? 어떤 세부사항들을 추가시켜 확장성에서 이득을 봤나요? 추상적인 클래스는 상속을 사용했나요 인터페이스를 사용했나요?























