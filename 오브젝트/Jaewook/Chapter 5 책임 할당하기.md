
책임을 할당한다는 것은 일종의 트레이드 오프 활동.
동일한 문제를 해결하기 위한 책임할당 방법은 다양하기 때문에 상황과 문맥을 파악하고 다양한 관점에서 설계를 평가할 수 있어야 한다.

## 01 책임 주도 설계를 향해

데이터 중심 설계에서 책임 중심 설계로 변경하기 위한 원칙

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥안에서 책임을 결정하라
#### 데이터보다 행동을 먼저 결정하라

객체를 설계할 때 "이 객체가 수행해야 하는 책임은 무엇인가"를 결정한 후에 "이 책임을 수행하는 데 필요한 데이터가 무엇인가"를 결정해야 한다. 

#### 협력이라는 문맥안에서 책임을 결정하라

협력을 시작하는 주체는 메시지 전송자이다. 즉 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야한다.

객체를 결정한 후 메시지를 설정하는 것이 아닌 메시지를 먼저 결정한 후 객체를 선택해야 한다. 객체가 메시지를 결정하는 것이 아니라 메시지가 객체를 결정해야 한다.

메시지를 전송할 클라이언트는 어떤 객체가 메시지를 수신할 것인지 알지 못한다. 메시지를 수신한 객체는 메시지를 처리할 "책임"을 할당 받는다.

메시지를 먼저 결정하면 송신자는 수신자에 대한 가정을 할 수 없게 된다. 즉 전송자 관점에서 수신자가 캡슐화되는 것이다.

**객체에 적절한 책임을 할당하려면 협력이라는 문맥을 고려해야 함.
협력이라는 문맥에서의 적절한 책임은 클라이언트 관점에서 적절한 책임을 의미
클라이언트가 보낼 메시지를 결정한 다음에서야 객체의 상태(내부 데이터)를 고민하기 시작한다.**

---
## 02 책임 할당을 위한 GRASP 패턴

**GRASP(General Responsibility Assignment Software Pattern)** 은 객체에게 책임을 할당할 때 지침으로 삼을 수있는 원칙들의 집합을 패턴형식으로 정리한 것이다.

#### 도메인 개념에서 출발하기

설계를 시작하기 전에  도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다.
개념들의 의미나 관계가 정확하지 않아도 상관없다. 이 단계에서는 책임을 할당 받을 객체들의 종류나 관계에 대한 유용한 정보를 제공할 수 있다면 충분하다.

#### 정보 전문가에게 책임을 할당하라

메시지는 메시지를 수신할 객체가 아니라 전송하는 객체의 의도를 반영해서 결정해야 한다. 

따라서 메시지를 결정하는 첫 질문은 다음과 같다.
*메시지를 전송할 객체는 무엇을 원하는가?*

두 번째 질문은 다음과 같다.
*메시지를 수신할 적합한 객체는 누구인가?*

두 번째 질문 전에 유념해야할 점은 객체는 상태와 행동을 통합한 캡슐화 단위이다. 객체는 자신의 상태를 스스로 처리해야 하는 자율적인 존재여야 한다. 따라서 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당해야 한다. GRASP에서는 이를 **정보 전문가 패턴(INFORMATION EXPERT PATTERN)** 이라고 부른다.

> [!note] INFORMATION EXPERT 패턴
> 
> 책임을 정보 전문가, 즉 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라.
> 
> INFORMATION EXPERT 패턴은 객체가 자율적인 존재라는 점을 상기시킨다.
> 정보를 알고 있는 객체만이 책임을 어떻게 수행할 지 스스로 결정할 수 있기 때문이다.
> INFORMATION EXPERT 패턴에 따르면 정보와 행동을 가까운 곳에 위치시켜 캡슐화를 유지할 수 있다. 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 결합도가 낮고 응집도가 높아진다.

객체가 책임을 수행하기 위한 정보를 알고 있다는 표현에서 정보란 단순 상태만을 말하는 것은 아니다. 해당 정보를 제공할 다른 객체를 알고 있거나  정보를 계산해서 제공할 수 있다. *정보 전문가가 반드시 데이터를 저장할 필요는 없다.*

책임을 객체에게 할당했다면 객체의 내부로 들어가 메시지를 처리하기 위해 필요한 절차와 구현을 고민해야 한다. 다만 개략적인 수준에서 객체가 수행하는 데 필요한 작업을 구상하고 처리할 수 없는 작업이 무엇인지 가릴 수준이면 된다.

스스로 처리할 수 없는 작업이 있다면 외부 객체에 도움을 요청하면 된다. 이 요청이 새로운 메시지가 되고 새로운 객체의 책임으로 할당된다. 이 같은 연쇄적인 메시지 전송과 수신이 협력 공동체를 만든다.

INFORMATION EXPERT 패턴에서 상태와 행동을 함께 가지는 객체지향의 기본 원리를 책임 할당의 관점에서 표현한다.

#### 높은 응집도와 낮은 결합도

높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리다.
GRASP에서는 이를 **LOW COUPLING(낮은 결합도)** 패턴과 **HIGH COHESION(높은 응집도)** 패턴이라고 부른다.

> [!note] LOW COUPLING 패턴
> 
> 의존성을 낮추고 변화의 영향을 줄이고 재사용성을 높이기 위한 설계는 결합도가 낮은 설계이다. 

> [!note] HIGH COHESION 패턴
> 
> 복잡성을 관리 가능한 수준으로 유지시킬 수 방법은 높은 응집도로 유지시켜야 한다.


LOW COUPLING 패턴과 HIGH COHESION 패턴은 설계를 진행하면서 책임과 협력의 품질을 검토하는 데 사용할 수 있는 중요한 평가 기준이다. 책임을 할당하고 구현하면서 매순간 LOW COUPLING과 HIGH COHESION의 관점에서 설계 품질을 검토하자

#### 창조자에게 객체 생성 책임을 할당하라

> [!note] CREATOR 패턴
> 
> 객체 A를 생성해야 할 때 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라
> 
> - B가  A 객체를 포함하거나 참조한다.
> - B가  A 객체를 기록한다.
> - B가 A 객체를 긴밀하게 사용한다.
> - B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다.(이 경우 B는 A에 대한 정보 전문가다.)
>   
>   생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.
>   
>   이미 결합된 객체에게 생성 책임을 할당하는 것은 전체적인 결합도에 영향을 미치지 않는다.

## 03 구현을 통한 검증


> [!note] 클래스 응집도 판단하기
> 
> 낮은 응집도가 갖는 특징
> 
> - 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮다. 변경의 이유를 기준으로 클래스를 분리하라.
> - 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
> - 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮다. 이들 그룹을 기준으로 클래스를 분리하라.
>   
>   일반적으로 응집도가 낮은 클래스는 위의 세 가지 문제를 동시에 가지는 경우가 대부분이다.

#### 다형성을 통해 분리하기

자바에서는 역할을 구현하기 위해서는 추상 클래스나 인터페이스를 사용한다. 추상 클래스는 클래스들 사이에서 공유되는 구현이 있을 때, 인터페이스는 객체들의 책임만 정의하고 싶을 때 사용하면 된다.

> [!note] POLYMORPHISM 패턴
> 
> 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하자
> 
> 조건에 따른 변화는 프로그램의 기본 논리다. 프로그램을 if~ else 또는 switch ~ case 등의 조건 논리를 사용해서 설계한다면 변화가 일어나는 경우 조건 논리를 수정해야 하며 변경에 취약해진다.
> 
> POLYMORPHISM 패턴은 객체의 타입을 검사해 타입에 따라 여러 대안들을 수행하는 조건논리를 사용하지 않고 변화를 다루기 쉽게 확장시킨다.

#### 변경으로부터 보호하기

> [!note] PROTECTED VARIATIONS 패턴
> 
> 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
> 
> PROTECTED VARIATIONS 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다. "설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라"

클래스를 변경에 따라 분리하고 인터페이스로 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 방법이다. 클래스를 분해하고 POLYMORPHISM 패턴에 따라 책임을 분산시켜라. 예측 가능한 변경이 있다면 PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화해야 한다.

#### 변경과 유연성

유연성은 의존성 관리의 문제이다. 요소들 사이의 의존성 정도가 유연성의 정도를 결정한다. 
## 04 책임 주도 설계의 대안

책임과 객체사이에서 방황할 때 최대한 빠르게 기능을 구현해보고 코드 상에서 드러나는 명확한 책임관계를 파악해 리팩터링하는 방법을 추천.

#### 메서드 응집도

**몬스터 메서드(monster method)** :메서드의 응집도가 낮아 하나의 메서드의 길이가 길어 가독성이 떨어지는 메서드

- 어떤 일을 수행하는지 한 눈에 파악하기 어렵다. 이해하는데 시간이 많이 걸린다.
- 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높음
- 로직의 일부만 재사용하는 것이 불가능하다.
- 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여 넣는 것 뿐이다.

응집도가 낮은 메서드는 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분이다. 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 응집도가 낮다. 주석 대신 메서드를 잘게 분해해서 각 메서드의 응집도를 높이고 적절한 네이밍을 지으면 메서드의 이름이 주석의 역할을 할 수 있다.

메서드의 길이가 중요한 것이 아니라 메서드의 이름과 몸체의 의미적 차이가 중요하다. 코드의 길이가 더 길어지더라도 코드를 더욱 명확하게 할 수있다면 메서드를 새로 만든다.

#### 객체를 자율적으로  만들자

객체를 자율적으로 만들기 위한 지름길은 자신이 소유하고 있는 데이터를 자기 스스로 처리하게 만드는 것이다. 

책임주도 설계에 익숙하지 않다면 일단 데이터 중심으로 구현한 뒤 이를 리팩터링하면 유사한 결과(책임주도 설계)를 얻을 수 있다. 캡슐화, 결합도, 응집도를 이해하고 객체지향 원칙을 적용하기 위해 노력한다면 처음부터 책임주도 설계를 따르지 않더라도 유연하고 깔끔한 코드를 얻을 수있다.

**논의 사항** 

여러가지 리팩터링 기법들이 존재하는 데 범용성 좋게 자주 쓰던 기법들이 있나요?

저는 early return을 많이 적용해 봤는데 가독성이 올라가고 코드가 깔끔해지는 느낌이었습니다. 물론 이건 응집도나 결합도면에서 영향을 주는 규모있는 리팩터링 기법은 아니었습니다만 여러분들의 리팩터링 경험들이 궁금합니다.
