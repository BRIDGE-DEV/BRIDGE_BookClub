
객체지향 설계란 올바른 객체에게 올바른 책임을 할당해 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.[ Evers09] 객체지향 설계의 핵심이 책임이라는 것과 책임을 할당하는 작업이 응집도와 결합도와 같은 설계 품질과 깊이 연관돼 있다.

설계는 변경을 위해 존재하고 변경은 늘 비용이 발생한다. 훌륭한 설계한 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다. 합리적인 비용의 변경을 수용할 수 있는 구조는 느슨하게 결합된 요소로 구성된다. 

결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙은 객체의 상태가 아닌 행동에 초점을 맞추는 것이다. 객체를 데이터 집합으로 바라보는 것은 내부구현을 퍼블릭 인터페이스에 노출시키는 것과 같다. 결과적으로는 변경에 취약해진다.

객체의 책임에 초점을 맞추면 상태와 행동에서 더 나아가 다른 객체와 협력하는 상호작용이 설계의 중심이 된다. 

이번 내용은 영화 예매 시스템을 책임이 아닌 데이터 중심의 설계로 살펴보며 책임 주도 설계의 통찰을 얻자.

---

## 01 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 시스템을 상태나 책임을 분할의 중심축으로 삼을 수 있다. 훌륭한 객체 지향 설계에서는 책임을 중심축으로 시스템을 분할 해야 한다. 객체의 상태를 분할의 중심축으로 삼으면 인터페이스에 근접해 노출되게 된다. 객체의 상태는 곧 내부 구현을 뜻하며 구현은 불안정하기 때문에 변경이 쉽게 일어난다. 따라서 상태의 변경은 인터페이스의 변경을 뜻하며 인터페이스에 의존하는 모든 객체가 변경해야 하는 취약한 설계가 된다.

반면에 책임은 인터페이스에 속하며 책임을 수행하는 데 필요한 상태는 인터페이스 뒤로 숨겨 캡슐화시켜 구현 변경에 대한 영향력을 제거한다. 따라서 안정적인 설계가 가능하다.

#### 데이터를 준비하자

데이터 중심 설계는 "객체가 내부에 저장해야 하는 데이터가 무엇인가?"를 묻는 것으로 시작한다. 

```js
public class Movie{
	private String title;
	private Duration runningTime;
	private Money fee;
	private List<DiscountCondition> discountConditions;

	private MovieType movieType;
	private Money discountAmount;
	private double discountPercent;

}
```

데이터 중심의 Movie 클래스는 책임 중심의 Movie클래스와 마찬가지로 영화의 기본 정보가 담겨 있는 것은 똑같으나 차이점은 할인 조건의 목록(discountConditions)이 인스턴스 변수로 Movie안에 직접 포함되어 있다는 점이다.

또한 할인 정책(DiscountPolicy)를 별도로 두었던 책임중심과 달리 할인 정책에 사용되는 disountAmount와 discountPercent가 Movie안에 직접 정의하고 있다.

영화에 적용된 할인 정책의 종류를 알려면 MovieType을 사용한다.
열거형인 MovieType을 이용해 해당 영화의 할인 정책을 결정한다.

```js
public enum MovieType{
AMOUNT_DISCOUNT,
PERCENT_DISCOUNT,
NONE_DISCOUNT
}
```

데이터 중심 설계에서는 객체가 포함해야 하는 데이터에 집중한다. 이 객체가 포함해야 하는 데이터는 무엇인가를 질문하다 보면 데이터 중심의 설계에 매몰돼 있을 확률이 높다. 특히 객체의 종류를 저장할 수 있는 변수(movietype)이와 인스턴스 종류에 따라 배타적으로 사용될 변수(discountAmount,discountPercent)를 하나의 클래스 안에 함께 포함시키는 방식은 데이터 중심의 설계 안에서 흔히 볼 수 있다.

이제 Movie 객체에 접근자(accessor)와 수정자(mutator)를 추가한다.


```js
public enum DiscountConditionType{
SEQUENCE, //순번 조건
PERIOD    //기간 조건
}
```

할인조건의 타입을 구현한다.

```js
public class DiscountCondition{
private DiscountConditionType type;

private int sequence;

private DayOfWeek dayOfWeek;
private LocalTime startTime;
private LocalTime endTime;
}
```
할인 조건은 조건의 타입과 요일, 시작시간, 종료시간을 함께 포함한다.
추가로 접근자와 수정자를 추가한다.


```js
public class Screening {
private Movie movie;
private int sequence;
private LocalDateTime whenScreened;

//접근자와 수정자 추가
}
```

```js
public class Reservation {
private Customer customer;
private Screening screening;
private Money fee;
private int audienceCount;
//접근자와 수정자 추가
}
```

```js
public class Customer {
private string name;
private String id;

public Customer(String name, String id) {
this.id=id;
this.name=name;
}
//접근자와 수정자 추가
}
```

#### 영화를 예매하자

ReservationAgency는 데이터 클래스들을 조합해서 영화 예매 절차를 구현하는 클래스다.

```js
public class ReservationAgency {
	public Reservation reserve(Screening screening, Customer customer, int audienceCount){
		Movie movie = screening.getMoive();

		boolean discountable = false;
		for(DiscountCondition condition : movie.getDiscountConditions()){
			if(condition.getType() == DiscountConditionType.PERIOD){
				discountable=screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek())&&condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime())<=0&&condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime())>=0);}else {
		discountable = condition.getSequence() == screening.getSequence();
				}
		if(discountable){
			break;
		}
			
			}
		}

}

...
}
```

---

## 02 설계 트레이드오프

객체

#### 캡슐화

구현이란 변경되기 쉬운 불안정한 구역이며 인터페이스란 변경될 가능성이 낮은 안정적인 구역이다. 객체를 사용하면 구현은 내부로 숨기고 인터페이스는 공개함으로써 한 객체의 변경이 다른 객체로 변경의 여파가 퍼져나가는 것을 통제한다.

객체를 설계하기 위한 기본적인 아이디어는 구현과 인터페이스를 분리하고 외부에서 인터페이스에만 의존하도록 하는 것이다.

설계가 필요한 이유는 요구사항이 변경되기 때문이고 캡슐화가 중요한 이유는 불안정한 부분과 안정된 부분을 분리시켜 변경의 영향을 통제할 수 있기 때문이다. 컙슐화는 변경될 수 있는 모든 것들을 객체 내부로 숨기는 일이다.

#### 응집도와 결합도

**응집도** 
모듈에 포함된 내부 요소들의 연관성이다.
모듈 내부의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 응집도가 높다. 반대로 요소들이 서로 다른 목적을 추구한다면 응집도가 낮다.

**결합도**
의존성의 정도.
다른 모듈에 대해 가지고 있는 정보의 정도를 뜻한다. 한 모듈이 다른 모듈의 세부적인 내용까지 알고 있다면 두 모듈은 높은 결합도를 가진다. 반대로 꼭 필요한 정보만을 알고 있다면(최소한의 인터페이스) 결합도가 낮다.

객체지향의 관점에선 응집도가 높고 결합도가 낮은 것을 추구한다.
응집도와 결합도는 변경과 관련된 것이며 설계의 품질을 결정한다.

응집도는 *변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도* 로 측정 가능하다.
하나의 변경을 수용하기 위해 모듈 전체가 변경에 함께한다면 응집도가 높다. 반대로 모듈의 일부만 변경된다면 응집도는 낮다.

응집도가 높을수록 변경의 대상과 범위가 명확해진다. 변경을 위해 수정 해야할 코드를 찾아다니지 않아도 된다.

결합도는 *한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도*로 측정 가능하다. 결합도가 높을수록 변경을 할 때 같이 변경해야 하는 모듈의 수가 늘어난다. 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.

캡슐화의 정도가 응집도와 결합도에 영향을 미친다. 캡슐화를 지키면 응집도는 높아지고 결합도는 낮아진다. 
응집도와 결합도를 고려하기 전에 캡슐화를 향상시키자.

---

## 03 데이터 중심의 영화 예매 시스템의 문제점

책임중심의 설계와 기능적으로는 동일하다. 하지만 설계관점에서는 다르다.

**캡슐화를 다루는 방식**

데이터 중심의 설계에서는 캡슐화를 위반하고 내부구현와 인터페이스가 뒤섞인다.
데이터 중심 설계는 캡슐화를 위반하기 쉬워 결합도가 높고 응집도가 낮다.

#### 캡슐화 위반

Movie 클래스의 접근자와 수정자를 보면 캡슐화의 원칙이 지켜지고 있는 것처럼 보이나 결국 내부구현을 퍼블릭 인터페이스로 노출시키고 있다.

Movie가 캡슐화 원칙을 어기게 된 이유는 책임이 아닌 객체의 내부 데이터에 초점을 맞췄기 때문이다. 

**추측에 의한 설계 전략(design-by-guessing strategy)[Holub04]**
객체가 사용될 협력을 고려하지 않고 막연히 사용될 것이라는 추측으로 설계하게 되면 내부상태를 드러내는 메서드를 많이 추가하게 된다. 따라서 캡슐화가 위반되며 결합도가 높고 응집도가 낮아진다. 

#### 높은 결합도

접근자와 수정자를 통해 내부 구현을 인터페이스의 일부로 만들기 때문에 캡슐화를 위반한다.  또한 객체의 내부 구현을 변경하게 되면 이 인터페이스에 연결된 모든 클라이언트들도 함께 변경해야 한다.  

Movie의 fee의 타입이 변경된다면 fee에 의존하는 클래스들이 변경되기 때문에 getFee 메서드는 fee를 정상적으로 캡슐화하지는 못한다. 결과적으로는 결합도를 높인다.

또 다른 단점으로는 데이터 객체들을 사용하는 제어 로직이 특정 객체에 집중되기 때문에 하나의 제어객체에 많은 데이터 객체가 강하게 결합된다. 이로인해 제어 로직 객체가 변경되면 모든 데이터 객체까지 변경의 여파가 퍼진다.

#### 낮은 응집도

모듈의 응집도를 살펴보기 위해서는 코드를 수정하는 이유를 살펴야 한다.
다음 경우에 ReservationAgency의 코드를 수정해야 한다.

 - 할인 정책이 추가될 경우
 - 할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우
 - 할인 조건이 추가되는 경우
 - 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
 - 예매 요금을 계산하는 방법이 변경될 경우

낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다.

- 변경의 이유가 서로 다른 코드를 하나의 모듈안에 뭉쳐놓았기 때문에 변경과 상관없는 코드들도 변경에 영향을 받는다. 어떤 코드를 수정했을 때 *아무런 상관도 없는 코드에 문제가 발생하는 것은 모듈의 응집도가 낮을 때 발생하는 증상이다.*
- 하나의 요구사항을 반영하면 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 다른 모듈에 위치해야 할 책임이 엉뚱한 곳에 있기 때문이다. 

---

## 04 자율적인 객체를 향해

#### 스스로 자신의 데이터를 책임지는 객체

객체를 상태와 행동으로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다.

객체는 단순한 데이터 제공자가 아니다. 객체 내부의 데이터보다 협력에 참여하면서 책임을 정의하는 오퍼레이션이 중요하다.

따라서 객체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?"는 질문은 다음과 같은 두 개의 개별적인 질문으로 분리해야 한다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이터는 무엇인가?

영화예매 시스템에서 객체가 데이터에 대해 어떤 것을 수행시켜야 하는지 고민해보자

- DiscountCondition에서 순번조건일 때는 sequence를 사용해 할인 여부를 결정하고 기간 조건일 때는 dayOfWeek, startTime, endTime를 이용해 할인 여부를 결정한다. 

따라서 두 가지 할인 조건을 판단할 수 있게 두 개의 isDiscountable 메서드를 통해 type의 값을 통해 할인 조건 타입에 맞는 적절한 메서드가 호출됐는지 판단한다.

- Movie에는 영화 요금을 계산하는 오퍼레이션과 할인 여부를 판단하는 오퍼레이션이 필요하다. Movie의 타입을 판단해 요금을 계산하는 오퍼레이션이 추가되야 할 것이다.

- Screening에서는 할인 정책을 지원할 경우 Movie의 isDicscountable메서드를 호출해 할인이 가능한지 여부를 판단 후 Movie의 메서드를 호출해 요금을 계산한다.

- ReservationAgency는 Screening의 calculateFee메서드를 호출해 예매 요금을 계산한 후 계산된 Reservation을 생성한다.

변경된 설계는 내부구현을 더 캡슐화하기 때문에 객체들이 데이터를 처리하는 데 필요한 메서드를 가지고 있어 스스로 책임지는 객체가 되었다.

---

## 05 하지만 여전히 부족하다.

캡슐화 관점에서 개선된 것은 사실이나 여전히 캡슐화가 만족스러울 정도는 아니다.

#### 캡슐화 위반

사실 DiscountCondition과 Movie의 캡슐화는 완벽히 이루어지지 않고 있다. 
DiscountCondition에서는 메서드의 파라미터에서 sequence 와 날짜 및 시간을 통해 내부구현을 드러내고 있고 Movie에서는 각종 할인 정책의 계산을 메서드로 추가해 할인정책의 종류를 밖으로 드러내고 있다. 할인정책이 추가되거나 제거되면 마찬가지로 Movie의 할인정책 계산 메서드에 의존하고 있는 모든 객체들에 변경의 여파가 갈 것이다.

> [!note] 캡슐화의 진정한 의미
> 
> 이 예제는 캡슐화가 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다는 것을 의미한다. 
> 
> 캡슐화는 변경 가능성이 있는 어떤 것들을 내부로 감춘다는 것이다. 단순히 데이터를 감추는 것은 "데이터 캡슐화"라는 캡슐화의 한 종류일 뿐이다. 설계에서 변할 수 있는 것이 무엇인지를 파악하고 변하는 개념들을 캡슐화해야 한다.

#### 높은 결합도

캡슐화의 위반으로 DiscountCondition의 내부구현은 외부로 노출됐다. 때문에 Movie와 DiscountCondition은 결합도가 높을 수 밖에 없다. DiscountCondition에서 변경이 생기면 Movie를 수정할 수 밖에 없어진다. 

- DiscountCondition의 기간 할인 조건의 PERIOD에서 다른 값으로 변경되면 Movie를 수정해야 한다.
- DiscountCondition의 종류가 추가되거나 삭제된다면 Movie의 if~else 문을 수정해야 한다.
- 각 DiscountCondition의 만족 여부를 판단하는 데 필요한 정보가 변경된다면 Movie의isDiscountable 메서드로 전달된 파라미터를 변경해야 한다. 이로 인해 Movie의 isDiscountable 메서드 시그니처도 함께 변경될 것이고 결과적으로 이 메서드에 의존하는 Screening의 변경 또한 초래한다.

#### 낮은 응집도

DiscountCondition에서 할인 여부를 판단하는 정보가 변경되면 Movie의 isDiscountable이 변경되고(메서드의 파라미터) Screening에서 isDiscountable을 호출하는 부분도 변경된다. 
응집도가 낮은 이유는 캡슐화를 위반했기 때문이다. DiscountCondition과 Movie의 내부 구현이 인터페이스에 그대로 노출되고 Screening이 노출된 부분에 의존하고 있기 때문이다.

---

## 06 데이터 중심 설계의 문제점

- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

#### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

설계에 실패한 이유는 크게 두가지가 있다.

- 데이터 중심 설계에서 객체는 단순히 데이터의 집합체이다. 이렇게 접근자와 수정자를 과도하게 추가되고 데이터를 사용하는 절차는 별도의 객체에 구현된다. 접근자와 수정자는 public과 큰 차이가 없기 때문에 캡슐화는 완전히 무너진다.
- 데이터를 먼저 결정하고 데이터를 처리하는데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 드러난다. 그 결과 내부구현은 인터페이스에 드러나고 캡슐화에는 실패한다.

#### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

올바른 객체지향 설계의 무게 중심은 객체의 내부가 아닌 외부로 향해야 한다. 객체의 내부와 그 상태를 관리하는 것은 부가적인 문제이다. 객체가 상호 협력하는 공동체를 구축하는 것이 객체지향의 관점이기 때문이다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다.

데이터 중심 설계에서는 설계의 초점이 객체의 외부가 아니라 내부로 향한다. 실행 문맥과 책임관계에 대한 깊이 있는 고민없이 객체의 세부적인 데이터부터 결정한다. 객체의 내부 구현이 된 상태에서 다른 객체와 협력 방법을 고려하다보니 구현부를 인터페이스에 억지로 끼워맞출 수 밖에 없다.

---

논의사항 : 접근자와 수정자를 사용하게 되는 경우는 어떤 경우가 있었나요?

본인은 프로퍼티를 무작정 만들어서 쓰다보니 데이터 중심 설계의 나쁜 예시처럼 되버렸습니다... 책에서 설명한대로는 프로퍼티(접근자, 수정자)가 이론상으로는 전혀 필요없어 보이는데, 여러분들은 프로퍼티를 사용했다면 어떤 때에 사용했는지 궁금합니다.
그리고 정말 이상적인 객체지향 설계 관점으로는 프로퍼티는 사용할 필요가 없는가를 논의해보면 좋을 것 같아요.