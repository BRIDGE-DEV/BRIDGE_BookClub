

클래스와 추상클래스, 인터페이스를 조합한 구조와 지연 바인딩을  통해 구현되는 다형성, 상속과 합성, 유연한 객체지향을 위해서는 컴파일 시간 의존성과 실행 시간 의존성이 달라야 한다는 사실이 전 챕터에서 배운 내용이였다.

객체지향 패러다임의 관점에서 핵심은 **역할(role), 책임(responsibility), 협력(collaboration)** 이다. 클래스, 상속, 지연 바인딩이 중요하지 않은 것은 아니지만 객체지향 패러다임의 본질과 먼 구현 측면에 치우쳐 있다.

객체지향의 본질은 협력하는 객체의 공동체를 창조하는 것이다. 어플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 그 협력을 위해 어떤 책임과 역할을 부여해야 하는지 고민해야 한다. 클래스와 상속은 책임과 협력이 자리잡은 뒤에 사용할 수 있는 구현 메커니즘이다.

---

## 협력

#### 영화 예매 시스템 돌아보기

객체들이 어플리케이션의 기능을 수행하기 위해 하는 상호작용을 **협력**이라고 한다. 객체가 협력하기 위해 수행하는 로직은 **책임**이라고 한다. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

#### 협력

객체지향 시스템은 자율적인 객체들의 공동체이다. 객체들은 시스템의 기능이라는 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적 존재이다. 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이며 한 객체가 다른 객체에게 도움을 요청할 때 시작된다. 

> 협력이란 어떤 객체가  다른 객체에게 무엇인가를 요청하는 것이다. 한 객체는 어 떤 것이 필요할 때마다 다른 객체에게 전적으로 위임하거나 서로 협력한다. 즉, 두 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다. 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.

메시지를 수신한 객체는 **메서드**를 실행해 요청에 응답한다. 객체는 메시지를 실행하는 방법을 객체 스스로 정한다는 점이 중요하다. 외부의 객체는 오직 메시지만 전송할 수 있으며 그 메시지를 어떻게 처리할 것인지는 메시지를 수신받은 객체 스스로가 정한다.

[[캡슐화 협력.canvas|캡슐화 협력]]

Screening이 Movie에게 calualateMovieFee 메시지를 전송해 예매자 한 명의 요금 계산을 요청한다. 처리를 위임하는 이유는 Movie가 할인 정책과 기본요금에 대해 잘 알고있기 때문이다.  Screening이 요금을 계산하는 작업을 수행하면 Movie의 변수인 Fee와 discountPolicy에 접근하게 된다. 이 경우에 Screening이 Movie의 내부 구현에 결합되고 Movie의 자율성이 훼손된다. 

Movie의 내부 구현이 변경된다면 Screening또한 변경된다. Movie가 자율적인 존재가 되려면 Movie 자신이 알고 있는 요금과 정보를 이용해 요금을 계산해야 한다.

결과적으로 객체를 자율적으로 만드는 방법은 내부 구현을 **캡슐화**하는 것이다.  Movie가 자신의 정보를 바탕으로 직접 계산하게 되면 Screening과 Movie 사이의 결합도를 느슨하게 유지할 수 있다.

자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 요청해 협력을 요청한다. 메시지를 수신한 객체 또한 메시지를 처리하던 중에 도움이 필요한 경우 다른 객체에게 메시지를 요청한다.  이렇게 객체간의 협력을 구하는 일련의 요청과 응답이 에플리케이션의 기능을 구현하게 된다.

#### 협력이 설계를 위한 문맥을 결정한다.

객체지향은 객체가 중심인 프로그래밍 패러다임이다. 객체란 상태와 행동을 함께 캡슐화하는 실행 단위이다. 그렇다면 객체는 어떤 기준으로 상태와 행동이 할당될까?

어떤 객체도 고립된 섬이 아니다. 어플리케이션에 객체가 필요하다면 이유는 단 하나, 객체가 협력에 참여하고 있기 때문이다. 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다. 

**객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.** 협력이 바뀌면 객체의 행동 역시 바뀐다. 협력은 객체의 존재 이유와 행동의 동기를 제공한다.

Movie는 어떤 행동을 수행할 수 있어야 할까? 영화라는 단어를 들으면 일반적으로 극장에서 상영하는 장면을 생각할 것이고 Play()라는 행동을 수행할 것이라고 예측할 것이다.
그러나 Movie는 영화의 예매를 위해 협력하는 객체이고 대부분이 요금을 계산하는 행동과 관련이 있다. 이것은 Movie가 영화를 예매하기 위해 협력하고 있고 요금을 계산한다는 책임을 지고 있기 때문이다.

Movie의 행동을 결정하는 것은 영화 예매를 위한 협력이다. 협력이라는 문맥을 고려하지 않고  행동을 결정하는 것은 아무런 의미가 없다. 협력이 있기에 행동이  존재하는 것이다. 
> *즉 영화 예매라는 협력의 문맥없이 객체만 보고 Movie, 즉 영화니까 play라는 행동을 부여하는 것은 의미가 없는 행동이라는 뜻인듯 하다.*

객체의 행동을 결정하는 것이 협력이라면 상태를 결정하는 것은 행동이다. 
즉 협력->행동->상태 순으로 결정에 영향을 준다.  객체는 자신의 상태를 스스로 결정하고 행동해야 하기 때문에(객체의 자율성, 캡슐화) 행동을 위해 필요한 상태도 함께 가지고 있어야 한다.

Movie가 기본요금 fee와 discountPolicy라는 인스턴스 변수를 상태의 일부로 포합하는 기유는 요금 계산이라는 행동을 수행하는 데 이 정보들이 필요하기 때문이다.

```js
public class Movie{
	private Money fee;
	private DiscountPolicy discountPolicy;

	public Money calculateMovieFee(Screening screening){
	return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}

}
```


객체의 상태는 객체가 어떤 행동을 하느냐에 따라 정해진다. 행동은 객체간의 협력 안에서 처리할 메시지에 의해 결정된다. 즉 객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다. 따라서 협력은 객체를 설계하는 데 필요한 **문맥(context)** 을 제곻한다.

---

## 책임

#### 책임이란 무엇인가

책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합. 객체가 유지해야 하는 정보와 수행해야하는 행동이 개략적으로 서술된 문장.
크레이그 라만(Craig Larman)은 **하는 것(doing)과 아는 것(knowing)** 의 두 가지 범주로 나누어져 있다.

> 하는 것
> 	- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
> 	- 다른 객체의 행동을 시작시키는 것
> 	- 다른 객체의 활동을 제어하고 조절하는 것
>
> 아는 것
> 	- 사적인 정보에 관해 아는 것
> 	- 관련된 객체에 관해 아는 것
> 	- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

협력안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.

일반적으로 책임과 메시지의 크기는 다르다. 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로도 크다. 단순한 책임이라고 생각했던 것도 여러 개의 메시지로 전달되지도 하고  하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에는 여러 객체들이 협력 해야하는 큰 책임이 될 수 있다.

객체는 책임을 수행하는데 필요한 정보를 알고 있어야 한다.

- 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임 
- 자신이 할 수 없는 작업을 도와줄 객체를 알고 있어야할 책임

책임은 객체지향 설계의 핵심이다. 협력이 책임을 제공하고 그 책임을 객체에 적절히 할당해야 단순하고 유연한 설계가 된다.
객체의 구현방법은 객체의 책임을 정한 다음에 고민해도 늦지 않을 만큼 책임선정과 할당이 중요하다.

#### 책임할당

자율적인 객체를 만드는 기본적인 방법은 책임을 수행하는 데 필요한 정보를 잘 알고 있는 전문가에게 책임을 할당하는 **INFORMATION EXPERT(정보 전문가) 패턴**이다.

객체가 책임을 수행하기 위해 그 정보를 가장 잘 알고 있는 전문가에게 도움을 요청한다. 요청에 응답하기 위한 행동들이 객체의 책임으로 이어진다. 따라서 협력이라는 문맥을 정의해야 한다. 협력을 설계하는 출발점은 시스템이 제공해야 하는 서비스를 하나의 책임으로 바라보고 그 책임을 완료하는 데 필요한 더 작은 책임을 찾아내 객체에게 할당하며 반복한다.

협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복과정으로 설계가 이루어진다.  메시지는 메시지를 수신할 객체의 책임을 결정한다.

그렇게 결정된 메시지는 객체의 퍼블릭 인터페이스를 구성한다. 협력을 설계하고 객체의 책임을 식별해 나가면 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 퍼블릭 인터페이스 목록이다.

물론 예외적으로 응집도와 결합도 관점에서 정보의 전문가가 아닌 다른 객체에게 책임을 할당하는 경우도 있지만 기본적으로 정보 전문가에게 책임을 할당하는 것만으로 상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아진다.

#### 책임 주도 설계

협력을 설계할 때 책임에 초점을 맞춰 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 **책임 주도 설계(Responsibility - Driven Design, RDD)[Wrifs-Brock03]** 라고 한다.

> - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
> - 시스템 책임을 더 작은 책임으로 분할한다.
> - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을  찾아 책임을 할당한다.
> - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
> - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

책임 주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있게 해준다. 유연하고 견고한 객체지향 시스템을 위한 재료는 책임이다.

#### 메시지가 객체를 결정한다.

객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 처리할 객체를 나중에 선택했다는 것이 중요하다. 다시 말해 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하는 것이다. [Metz 12]

메시지가 객체를 선택하게 해야 하는 중요한 이유

1. 객체가 **최소한의 인터페이스(minimal interface)[Weisfeld08]** 를 가질 수 있게 된다.필요한 메시지가 식별되기 전까지 객체의 퍼블릭 인터페이스에 추가되지 않기 때문에 객체는 크지도 작지도 않은 적절한 퍼블릭 인터페이스를 가질 수 있다.

2. 객체는 충분히 **추상적인 인터페이스(abstract interface)[Weisfeld08]** 를 가질 수 있기된다. 객체의 인터페이스는 무엇(What)을 하는 지는 알아야 하지만 어떻게(How) 하는 지는 숨겨야 한다. 메시지는 외부에 요청하는 "무언가" 이기 때문에 메시지를 식별하면 무엇을 수행할 지에 초점을 맞춘 인터페이스를 얻을 수있다.

#### 행동이 상태를 결정한다.

객체의 존재 이유는 협력의 참여이다. 따라서 객체는 협력에 필요한 행동을 제공해야 한다. 즉 객체를 객체답게 만드는 것은 상태가 아닌 다른 객체에게 제공하는 행동이다.

객체가 협력에 참여할 수 있는 방법은 행동이다. 즉 객체가 협력에 얼마나 적합한지를 결정하는 것은 객체의 행동이다. 얼마나 객체를 적절히 창조했느냐는 객체에 적절한 책임이 할당되었느냐에 따라 달렸고 이는 곧 객체가 협력에 얼마나 적절한가에 달렸다.

객체의 행동이 아닌 상태에 초점을 맞추게 되면 객체에 필요한 상태를 먼저 결정하고 상태에 필요한 행동들을 결정해나간다. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스를 노출되도록 한다. 즉 **캡슐화**가 저해된다. 객체의 내부 구현에 초점을 맞춘 설계 방법을 **데이터-주도 설계(Data - Driven Design)[Wirfs-Brock89]** 라고 부른다.

구현에 대한 결정을 뒤로 미루며 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다. 협력관계 속에서 객체가 무엇을 제공하고 무엇이 필요한지를 고민해야 훌륭한 책임을 수확할 수 있다. 객체의 상태는 행동을 수행시키기 위한 재료일 뿐이다.

*협력이 행동을 결정하고 행동이 상태를 결정한다. 그리고 그 행동이 바로 객체의 책임이다.*

---

## 역할

#### 역할과 협력

객체는 협력이라는 문맥안에서 목적을 갖게 된다. 객체의 목적은 협력안에서 맡게 되는 책임의 집합이다. 이러한 협력안에서 수행하는 객체의 책임 집합을 **역할** 이라고 부른다.
*협력을 설계할 때 책임의 할당을 객체가 아닌 역할에 한다고 생각하는 게 좋다.*

영화 예매 협력에서 "예매하라"는 메시지를 처리하기에 적합한 객체로 Screening을 선택했다. 한 단계로 보이는 이 책임할당 과정은 실제로 두 단계로 처리된다. 

1. 영화를 예매할 수 있는 역할을 찾는다.
2. 그 역할을 수행할 객체로 Screening 인스턴스를 선택한다.

그렇다면 왜?
왜 중간에 역할이라는 개념을 이용해서 설계에 번거로운 과정을 추가할까?

#### 유연하고 재사용 가능한 협력

역할이 중요한 이유는 유연하고 재사용 가능한 협력을 얻기 위함이다.
역할에 책임을 할당하지 않고 객체에 할당을 하게 된다면 Movie가 할인가격을 계산하기 위해 AmountDiscountPolicy에 메시지를 보내는 코드와 Movie가 PercentDiscountPolicy에 메시지를 보내는 코드를 작성할 것이다. 그렇게 된다면 중복된 코드가 나오게 될 것이고 프로그래밍에서 중복된 코드는 문제를 야기한다. 두 개의 할인 정책을 하나의 추상적인 DiscountPolicy로 묶어 메시지를 보내게 된다면 동일한 책임을 수행하는 하나의 역할로 통합할 수 있다. 이렇게 되면 불필요한 중복 코드를 줄일 수 있고 새로운 할인 정책이 생기면 DiscountPolicy에 객체를 추가함으로서 설계가 더 유연해진다.

> [!note] 역할의 구현
> 
> 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것이다. 협력에 관점에서는 이것들이 책임의 집합을 서술한 것이다. 추상 클래스는 책임의 일부를 구현한 것이고 인터페이스는 구현 없이 책임의 집합을 나열한 것이지만 둘 다 역할을 정의할 수 있는 구현 방법이다.
> 
> 영화 예매 시스템에선 DiscountPolicy는 추상 클래스로 구현했다. 이를 구현하는 모든 객체들의 공통된 상태와 행동이 있었기 때문이다. 반면에 DiscountCondition의 경우에는 책임의 목록만 정의하면 되기 때문에 인터페이스로 구현했다.
> 
> 역할은 다양한 객체를 수용할 수 있는 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화라는 것이다. 역할이 어떤 책임을 수행해야 하는지를 결정하는 것이 역할을 구현하는 것보다 우선된다.

#### 객체 대 역할

한 종류의 객체만 협력에 참여하는 상황에서 역할의 개념이 유용한가?

레베카 워프스브록의 말에 따르면 협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 수 있으면  그 후보는 역할이 되지만 한 종류의 객체만 참여한다면 그 후보는 객체가 된다. 

>객체에 관해 생각할 때 "이 객체가 무슨 역할을 수행해야 하는가?"라고 자문하는 것이 도움이 된다. 이 질문은 객체가 어떤 형태를 띠어야 하는지, 어떤 동작을 해야 하는지에 집중할 수 있게 해준다. 객체와 역할의 진짜 차이는 무엇일까? 만일 동일한 종류의 객체가 하나의 역할을 수행한다면 둘은 동일하다. 하지만 하나 이상의 객체가 동일한 책임을 수행할 수 있다면 역할은 책임의 집합이 된다.

책임을 수행하는 대상이 한 종류라면 객체로 간주한다. 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.

역할은 실행되는 동안 협력 안에서 각자의 위치를 가지는 객체들에 대한 별칭이라고 정의하기도 한다. [Reenskaug07] 린스카우에 따르면 협력은 역할의 상호작용이고 역할은 역할에 맞게 적합한 객체가 선택되며, 객체는 클래스를 이용해 구현되고 생성된다.

[[협력, 역할, 객체, 클래스의 관계 Reenskaug07.canvas|협력, 역할, 객체, 클래스의 관계 Reenskaug07]]

대부분의 경우 어떤 것이 역할이고, 객체인지 또렷하게 드러나지는 않는다. 특히나 명확한 기준을 세우기 어렵고 정보가 부족한 설계 초반은 더욱 어렵다.

개인적인 견해는 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 목표여야 하고 *역할과 객체를 명확하게 구분하는 것은 그렇게 중요하지 않다.* 따라서 애매하다면 *단순히 객체로 시작하고 반복적으로 책임과 협력을 정제하면서 필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법이다.* 

> [!note] 중요한 것은 책임이다.
> 
> 설계 초반에 다루는 대부분의 대상은 후보로 취급하는 것이 바람직하다. 이 후보는 객체가 될 수 있고 역할이 될 수 있고 클래스가 될 수 있지만 정확하게 이 후보가 무엇인지는 설계 초반에는 그다지 중요하지 않다. 이 시점에 중요한 것은 협력을 위해 어떤 책임이 필요한지를 이해하는 것이다. 후보는 책임을 식별해서 담을 빈자리 역할로 충분하다. 나중에 필요할 때 역할의 도입을 고려해도 늦지 않다.

협력을 구상할 때는 도메인 모델에 있는 개념들을 후보로 책임을 할당할 것이다. 협력을 지속적으로 정제하다 보면 두 협력이 유사한 구조를 보일 것이고 이 경우 두 협력을 하나로 합치면서 두 객체를 포괄할 수 있는 역할을 고려해 객체를 역할로 대체할 수 있다.

디양한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작하라. 모든 것이 확실하지 않다면 구체적인 객체로 시작하라. 역할은 유사한 협력들을 합치고 단순화하며 정제하다 보면 자연스럽게 모습을 드러낸다.

트리그비 린스카우는 **역할 모델링(Role Modeling)** 이라는 개념을 제안했다. [Working with Objects Reenskaug95]에서 상호작용하는 객체들의 협력 패턴을 역할들의 협력 패턴으로 추상화함으로써 유연하고 재사용 가능한 시스템을 얻을 수 있는 방법에 설명하고 있다.

#### 역할과 추상화

추상화가 가질 수 있는 장점은 역할 또한 갖는다. 
역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 역할은 객체의 추상화라고 볼 수 있다. 역할은 세부사항들을 숨기며 상위 수준의 정책들과 핵심적인 개념들만을 남겨서 협력에서의 큰 그림을 볼 수 있게 해준다. 이는 2장에서 설명한 추상화의 장점과 일치한다.

구체적인 객체로 대체 가능한 자리를 만들고 그러한 상위수준의 자리들이 협력에 참여하는 그림들을 보면 세부적인 객체들의 복잡성을 제거하고 핵심적인 협력관계를 읽을 수 있다. 이런 구체적인 객체로 대체 가능한 자리가 2장의 DiscountPolicy와DiscountCondition이다. 이것들이 바로 역할이다.

구체적인 객체의 복잡성이 제거된다. -> 즉 핵심관계를 문장으로 설명할 때 사족을 뺄 수 있다.

'가격 할인 정책과 함께 2개의 순번 규칙과 1개의 비율 규칙을 적용하거나 비율 할인 정책과 함께 3개의 순번 규칙을 적용' -> '할인 정책과 여러 개의 할인 조건을 적용한다.'

역할이 다양한 종류의 객체를 넣을 수 있는 슬롯이라는 점에서는 설계를 유연하게 만들 수 있다. 

#### 배우와 배역

배우는 연극이 상영되는 동안만 자신이 연기하는 배역의 가면을 쓴다.  무대에서 연기를 하는 동안은 관객들은 배우가 아닌 배역으로서 바라본다. 조명이 꺼지고 막이 내리면 사람들은 배우를 배역이 아닌 배우라는 존재로 바라본다.

-  배역은 연극 배우가 특정 연극에서 연기하는 역할이다.
-  배역은 연극이 상영되는 동안에만 존재하는 일시적인 개념이다.
-  연극이 끝나면 연극 배우는 배역이라는 역할을 벗어 버리고 원래의 연극 배우로 돌아온다.

배우와 배역간에는 또 다른 추가적인 특성이 존재한다. 

-  서로 다른 배우들이 동일한 배역을 연기할 수 있다.
-  하나의 배우가 다양한 연극 안에서 서로 다른 배역을 연기할 수 있다.

연극 안에서 배역을 연기하는 배우라는 은유는 협력 안에서 **역할**을 수행하는 객체라는 관점이 가진 입체적인 측면들을 훌륭하게 담아낸다. 협력은 연극과 동일하고 코드는 극본과 동일하다. 배우는 연극이 상영될 때 배역이라는 특정한 역할을 연기한다. 객체는 협력이라는 실행 문맥 안에서 역할을 수행한다. 연극 배우는 연극이 끝나면 자신의 배역을 잊고 원래 자신으로 돌아 오듯이 객체는 협력이 끝나고 협력에서의 역할을 잊고 원래 객체로 돌아온다.

배역 = 역할 , 배우 = 객체

협력이라는 문맥안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다[Vanhilst96] 일반적으로 역할은 객체가 협력에 참여하는 동안만 존재하는 일시적인 개념이다. 역할은 모양이나 구조에 의해 정의될 수 없으며 오직 시스템의 문맥 안에서 무엇을 하는지에 의해서만 정의될 수 있다. 

하나의 배역을 여러 배우가 연기하는 것 = 동일한 역할을 하나 이상의 객체들이 수행하는 것

배우가 여러 연극에 참여해 여러 배역을 연기하는 것 = 객체 역시 여러 협력에 참여하면서 다양한 역할을 수행하는 것

객체는 협력에 따라서 다양한 역할을 가지게 되고 그 역할을 제외한 부분은 가려진다. 객체는 다양한 역할을 수행할 수 있지만 협력의 입장에선 객체의 한 가지 역할만 바라보게 된다. 

---

논의 사항 : 여러분 들은 게임 안에서 협력에 의해 만들어진 문맥들이 뚜렷하게 구분이 가나요? 협력들은 어떻게 구별지어지나요?

책을 읽으면서 다른 소프트웨어에 비해 게임 안에서는 협력이 복합적으로 얽히고 설켜있는 느낌입니다. 게임은 복수의 협력들이 존재할거라 생각이 드는데, 어떤 기능까지가 하나의 협력으로 규정할지, 협력으로 규정되는 규모가 궁금합니다.