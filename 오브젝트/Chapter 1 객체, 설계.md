

### 이론이 먼저인가? 실무가 먼저인가?

로버트L. 글래스는 <소프트웨어 크리에이티비티 2.0>에서 어떤 분야를 막론하고 실무가 어느 정도는 발전해야만 비로소 실용성을 입증할 수 있는 이론들이 모습을 갖춰간다고 한다. 

이 말이 시사하는 바는 건축같이 오래된 공학분야에 비해 아직 초기단계라고 할 수 있는 소프트웨어 분야는 아직까지 실무가 앞서 있으며 실무가 더 중요하다는 것이다.

소프트웨어 개발에서 실무가 이론보다 앞서는 분야에는 *'소프트웨어 설계'* 와 *'소프트웨어 유지보수'* 가 있는데 설계와 관련된 이론들은 이론자체에서 출발해서 실무에 스며들었다기 보다 실무에서 보이는 반복적으로 보인 기법들이 이론으로 정립된 것들이다. 이는 소프트웨어의 규모가 커질 수록 이론이 실무를 추월할 가능성은 희박해 보인다.

소프트웨어 유지보수의 경우에는 그 격차가 심하다. 유지보수와 관련된 효과적인 이론이 발표된 적은 거의 없다시피 하며, 소프트웨어의 생명주기 중 유지보수가 차지하는 비율을 생각해보면 유지보수와 관련된 이론은 실망스러운 수준이다. 따라서 **설계와 유지보수**에서는 이론보다 실무적인 코드에 초점을 맞추는 것이 타당하다.

개발자는 구체적인 코드를 만지며 손을 더럽힐 때 가장 많은 것을 얻어가는 존재이다.

---

## 티켓 판매 어플리케이션 구현하기

[[티켓 판매 어플리케이션.canvas|티켓 판매 어플리케이션]]UML

## 무엇이 문제인가?


소프트웨어 모듈의 세 가지 목적

1. 실행 중에 제대로 동작하는 것이다.
	- 모듈의 존재 이유
2. 변경을 위해 존재하는 것이다.
	- 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.
3. 코드를 읽는 사람과 의사소통 하는 것이다.
	- 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.

읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.
*로버트 마틴<클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>*

#### 예상을 빗나가는 코드

위의 코드를 이해하기 어렵게 만드는 이유는 이 코드를 이해하기 위해서는 여러가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다는 점이다. 
Theater의 enter메서드에서 Bag을 가지고 있는 Audience, TicketOffice에서 티켓을 판매하는 TicketSeller, TicketOffice에는 돈과 티켓이 보관되어 있다는 사실을 전부 기억해야 한다. 
하나의 클래스나 메서드 안에 너무 많은 세부사항을 다루기에 코드를 읽고 이해해야 하는 사람에게 큰 부담을 준다.

#### 변경에 취약한 코드

더 큰 문제는 변경에 취약하다. 관람객이 가방을 들고 있지 않다거나 신용카드를 사용하는 경우, 판매원이 매표소 밖에서 판매하는 경우 가정이 깨지는 순간에 모든 코드가 흔들린다.

관람객이 가방을 들고 있다는 가정이 깨진다면 Audience 클래스에서 Bag을 제거해야 될 뿐 아니라 Audience의 Bag에 접근하는 Theater의 enter메서드 역시 수정해야 한다.
어떤 클래스가 다른 클래스의 세부적인 사항을 알 수록 세부사항이 바뀌면 세부사항을 가지고 있는 클래스 뿐만 아니라 그것에 의존된 클래스 또한 함께 바꿔야 한다.

이것은 객체 사이의 **의존성(dependency)** 과  관련된 문제다.
의존성은 변경에 대한 영향을 암시한다. 어떤 객체가 변경될 때, 그 객체에 의존한 객체도 함께 변경될 수 있다는 사실이 내포되어 있다.

객체사이의 의존성을 완전히 없애는 것이 정답은 아니다. 객체지향 설계는 객체가 서로 의존하고 상호 협력하는 공동체를 구축하는 것이다. 우리의 목표는 의존성을 필요한 만큼 최소한으로 유지하고 불필요한 의존성을 없애는 것이다.

객체사이에 의존성이 과한 경우 결합도(coupling)이 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에 결합도가 낮다고 한다.
따라서 설계의 목표는 낮은 결합도로 만들어 변경에 용이하게 만드는 것이다.

## 설계 개선하기

예제 코드는 모듈의 세 가지 목적 중 한 가지만 만족한다. 실행중에 제대로 동작하지만 읽기 용이한 코드도, 변경하기 쉬운 코드도 아니다. Theater가 관람객의 가방과 매표소에 직접 접근한다. 이는 관람객과 판매원이 자신의 일을 직접 처리한다는 직관을 벗어난다. 따라서 의도가 전달되지 않고 이해하기 어려운 코드가 되어버린다. 결합도 또한 높기 때문에 변경하기 어려운 코드다. 

>그렇다면 결합도를 낮춘다면 자동으로 모듈의 두가지 목적은 달성하게 되는 것인가? 적어도 변경하기 쉬운 코드가 되는 것은 맞는 것 같다. 그렇다면  의사소통하기 쉬운 코드는 어떻게 짜야할까?

해결방법은 Theater가 Audience와 TicketSeller에 대해 세세하게 알지 못하게 함과 동시에 Audience와 TicketSeller들에게 각자 자신의 일을 처리하게끔 자율성을 부여하면 된다.
*이론적으로 풀자면 SOLID에서 단일 책임 원칙과 캡슐화를 말하는 것 같다.*

#### 자율성을 높이자

Theater에 있는 메서드 중 다른 클래스에 접근하는 부분들을 각각 자신의 클래스에서 처리할 수 있게하고 클래스 사이에서 인터페이스로 접근할 수 있도록 수정 

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화(encapsulation)라고 부른다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 객체 내부로의 접근을 제한해 객체오 객체 사이의 결합도를 낮출 수 있기 때문에 변경하기 쉽게 된다.

[[개선된 티켓 판매 어플리케이션.canvas|개선된 티켓 판매 어플리케이션]]UML
#### 무엇이 개선됐는가

수정된 Audience나 TicketSeller는 자신의 소지품을 자신이 관리한다.  이로인해 Audience나 TicketSeller의 내부 구현을 변경하더라도 Theater는 함께 변경할 필요가 없다. 

#### 어떻게 한 것인가?

자신의 변수들은 자신의 클래스 내부의 프로세스 

#### 캡슐화와 응집도

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 말한다.

객체의 응집도를 높이기 위해서는 스스로 자신의 데이터를 책임져야 한다.

#### 절차지향과 객체지향

메서드인 *프로세스(Process)* 와 속성인 *데이터(Data)* 가 별도의 모듈에 위치시키는 방식을 *절차적 프로그래밍(Procedural Programming)* 이라고 한다.

절차적 프로그래밍의 세상에서는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기가 어렵다.(캡슐화되지 않기 때문에 한 가지를 변경시키면 변경점에 의존하는 것들을 같이 변경해야 한다.)

데이터와 프로세스가 동일한 모듈 내부에 위치하도록프로그래밍 하는 방식은 *객체지향 프로그래밍(Object-Oriented Programming)* 이라고 부른다.

훌륭한 객체지향 설계는 캡슐화를 이용해 의존성을 적절히 관리해 객체간 결합도를 낮추는 것이다. 결합도가 낮아진 구조에서 변경이 유연해진다.

#### 책임의 이동

객체지향과 절차지향의 근본적인 차이는 *책임의 이동(shift of responsibility)* 이다. 

> 객체가  메시지를 보내는 화살표가 많아질 수록 책임이 많아지나 보다...

객체지향 설계에서는 책임이 적절하게 분배되어 있고 각 객체는 스스로 책임지며 다른 객체들과 상호작용하는 공동체를 구성하면서 완성된다.

설계를 어렵게 하는 것은 *의존성* 이다. 불필요한 의존성을 제거해서 *결합도*를 낮춰야 한다. 객체에 대한 세부사항을 객체 내부로 *캡슐화*시켜 *자율성*과 *응집도*가 높은 객체들의 공동체를 창조할 수 있게 해야한다.

#### 그래, 거짓말이다.

실생활의 관점을 가져와 객체를 설계한다면 직관대로 객체들이 자신의 일을 스스로 처리하고 책임또한 객체 스스로가 져야한다. 하지만 예제의 Bag이나 Theater, TicketOffice 등등은 실생활에서 자율적으로 일을 처리할 수 있는 존재가 아니다.

비록 현실에서 수동적인 존재라도 객체지향의 세계에 들어온다면 자율적이고 능동적인 존재가 된다. 객체를 능동적이고 자율적인 존재로 설계하는 것을 *의인화(anthropomorphism)* 라고한다.


**감상**

확실히 객체지향에 대해 공부해본다면 먼저 읽어봐야 할 책인것 같습니다. 객체지향에서 책임이 무엇인지 의존성이 무엇인지 예제 코드들을 가지고 설명하니 두루뭉술하게 알고있던 개념들이 구체적으로 이해됐습니다. 인터페이스나 구현부에 대한 기초적인 설명도 자바나 C#의 interface와 헷갈렸던 나는 기본기를 쌓을 수 있는 좋은 책이 됐습니다.

읽으면서 내가 짰던 코드를 고쳐야겠다 생각이 들고 코드를 고치다보니 책을 읽어봐야 겠다는 생각이 들어 선순환이 도는 시간이었습니다.

**논의사항**

모듈의 세 가지 목적 중에서 코드의 가독성을 높이는 기준은 뭐가 있을까요?

모듈의 목적 중에 "모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다." 즉 가독성에 대한 얘기가 나옵니다. 초기 Theater가 모든 책임을 갖는 설계에서 관람객이나 티켓 판매원들이 스스로 작업을 수행하지 않아 직관을 벗어나거나 클라이언트 프로그래머가  Theater와 연결된 너무 많은 세부사항을 기억해야 하는 등 가독성을 암시하는 기준들이 나옵니다. 여러분들은 어떤 기준이 가독성에 가장 큰 영향을 주나요?












