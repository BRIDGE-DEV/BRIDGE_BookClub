# 챕터7: 템플릿과 일반화 프로그래밍

## 항목 44: 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자

아무 생각 없이 템플릿을 사용하면 **코드 비대화**가 초래될 수 있다. 방지하기 위해서는 **공통성 및 가변성 분석**이라는 방법을 사용해야 한다. 이는 템플릿이 아닐 때에도 많이 사용한 방식이다. 함수를 예시로 들면, 기존의 두 함수를 분석해 공통적인 부분과 다른 부분을 찾은 후, 공통 부분은 새 함수에 옮기고, 다른 부분은 원래의 함수에 남겨둔 것이다. 클래스의 경우도 비슷하다. 공통 부분을 별도의 새로운 클래스에 옮긴 후, 클래스 상속 혹은 객체 합성을 사용해 원래의 클래스들이 공통 부분을 공유하도록 한다.

템플릿을 작성할 경우에도 똑같은 분석을 하고 똑같은 방법으로 코드 중복을 막으면 된다. 중요한 점은, 템플릿 코드에서는 코드 중복이 암시적이라는 것이다. 어떤 템플릿이 여러 번 인스턴스화될 때 발생할 수 있는 코드 중복을 감각으로 알아차려야 한다는 것이다. 예제를 보자.

```cpp
template<typename T, std::size_t n>
class SquareMatrix {
public:
	...
	void invert();
};
```

이 템플릿은 `T`라는 타입 매개변수와, `size_t` 타입의 비타입 매개변수 `n` 두 가지를 받는다. 이를 통해 `invert` 함수를 호출한다고 해보자.

```cpp
SquareMatrix<double, 5> sml;
...
sm1.invert();

SquareMatrix<double, 10> sm2;
...
sm2.invert();
```

이때 두 `invert`는 같은 함수일 수가 없다. 두 `invert`의 사본이 각각 인스턴스화가 된 것으로, 사본의 개수가 2개 만들어지기 때문이다. 그렇지만 행과 열의 크기를 나타내는 상수만 빼면 두 함수는 완전히 똑같다. 이런 현상이 코드 비대화를 일으키는 일반적인 형태 중 하나이다.

이것을 해결하기 위해선, 사이즈 값을 매개변수로 받는 별도의 함수를 만들고, 그 함수에 5와 10을 매개변수로 넘겨서 호출하도록 해야할 것이다.

```cpp
template<typename T>
class SquareMatrixBase {
protected:
	...
	void invert(std::size_t matrixsize);
};

template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
protected:
	using SquareMatrixBase<T>::invert; // 기본 클래스 invert가 사라지는 걸 막기
	...
	void invert() { this->invert(n); }
};
```

행렬의 크기를 매개변수로 받도록 바뀐 `invert` 함수가 기본 클래스인 `SquareMatrixBase`에 들어가 있다. 이렇게 하게 되면, 같은 타입의 객체를 원소로 갖는 모든 정방행렬은 오직 한 가지의 `SquareMatrixBase` 클래스를 공유하게 된다.

아직 해결하지 못한 문제가 하나 있다. `SquareMatrixBase::invert` 함수는 자신이 상대할 데이터가 어떤 것인지를 어떻게 알 수 있을까? ‘정방행렬의 메모리 위치’를 파생 클래스가 기본 클래스로 넘겨주면 될 것이다. 매개변수로 추가할 수 있지만, 이렇게 되면 모든 함수에 이 포인터 매개변수를 추가해야 할 것이다. 따라서 행렬 값을 담는 메모리에 대한 포인터를 `SquareMatrixBase`가 저장하도록 해보자.

```cpp
template<typename T>
class SquareMatrixBase {
protected:
	SquareMatrixBase(std::size_t n, T *pMem): size(n), pData(pMem) {}
	void setDataPtr(T *ptr) { pData = ptr; }
	...
private:
	std::size_t size;
	T *pData;
};
```

경우에 따라서는 객체 자체의 크기를 줄이기 위해 행렬의 데이터를 힙에 둘 수도 있다.

중요한 점은, 이를 통해 `SquareMatrix`에 속해 있는 멤버 함수들이 기본 클래스 버전을 호출하는 단순 인라인 함수가 될 수 있으며, 똑같은 타입의 데이터를 원소로 갖는 모든 정방행렬들이 행렬 크기에 상관없이 이 기본 클래스 버전의 사본 하나를 공유한다는 것이다. 또한 행렬 크기가 다른 `SquareMatrix` 객체는 저마다 고유의 타입을 갖고 있다는 점도 중요하다. 예를 들면 `SquareMatrix<double, 5>` 객체와 `SquareMatrix<double, 10>` 객체가 똑같이 `SquareMatrixBase<double>` 클래스의 멤버 함수를 사용하고 있다 하더라도, 이 둘은 타입 자체는 다른 것이다. 따라서 서로의 타입을 대체할 수는 없다.

물론 처음 예제였던 행렬 크기 별로 별도의 버전이 만들어지는 `invert`의 경우에는, 행렬 크기가 컴파일 시점에 투입되는 상수이기 때문에 상수 전파(상수 폴딩) 등의 최적화가 들어가기 좋다. 

반면, 뒤의 예제처럼 여러 행렬 크기에 대해 한 가지 버전의 `invert`를 두도록 만들면 실행 코드의 크기가 작아지는 이점을 얻을 수 있다. 실행 코드가 작아지면 작은 크기로 끝나는 것이 아니라, 프로그램의 작업 세트 크기가 줄어들면서 명령어 캐시 내의 참조 지역성도 향상된다는 것이 중요하다. 이렇게 되면 프로그램 실행 속도가 더 빨라질 수 있다는 것이다.

> 템플릿을 사용하면 비슷한 클래스와 함수가 여러 개 만들어진다. 이는 비대화의 원인이 된다.
비타입 템플릿 매개변수로 생기는 코드 비대화의 경우, 템플릿 매개변수를 함수 매개변수 혹은 클래스 데이터 멤버로 대체함으로써 비대화를 없앨 수 있다.
타입 매개변수로 생기는 코드 비대화의 경우, 동일한 이진 표현구조를 가지고 인스턴스화되는 타입들이 한 가지 함수 구현을 공유하게 만듦으로써 비대화를 없앨 수 있다.