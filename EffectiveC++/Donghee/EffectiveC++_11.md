# 챕터2: 생성자, 소멸자 및 대입 연산자

## 항목 11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자

자기대입이란, 어떤 객체가 자기 자신에 대해 대입 연산자를 적용하는 것을 말한다.

```cpp
class Widget { ... };
Widget w;
...
w = w; // 자기대입
```

예를 들어,

```cpp
a[i] = a[j]; // i와 j가 같으면 자기대입
*px = *py; // px와 py가 가리키는 대상이 같으면 자기대입
```

등의 코드도 특정 조건이 갖추어 지면 자기대입이 된다. 명확하지 않은 이러한 자기대입이 생기는 이유는 여러 곳에서 하나의 객체를 참조하는 상태, 즉 **중복참조** 때문이다.

같은 타입으로 만들어진 객체 여러 개를 참조자 혹은 포인터로 물어 놓고 동작하는 코드를 작성할 때는, 같은 객체가 사용될 가능성을 고려하는 것이 바람직하다.

이럴 때 가장 조심해야 하는 것이 대입 연산자다. 이 연산자는 우리가 신경쓰지 않아도 자기대입에 대해 안전하게 동작해야 한다. 자기 참조의 가능성이 있는 코드를 보자.

```cpp
Widget& Widget::operator=(const Widget& rhs)
{
	delete pb;
	pb = new Bitmap(*rhs.pb);
	
	return *this;
}
```

여기서 생기는 문제는 operator= 내부에서 *this와 rhs가 같은 객체일 가능성이 있다는 것이다. 이 둘이 같은 객체면, delete 연산자가 *this 객체의 비트맵과 rhs의 객체에 동시에 적용된다.

전통적인 방법은 operator=의 첫머리에서 일치성 검사를 통해 자기대입을 점검하는 것이다.

```cpp
Widget& Widget::operator=(const Widget& rhs)
{
	if (this == &rhs) return *this;

	delete pb;
	pb = new Bitmap(*rhs.pb);
	
	return *this;
}
```

예외 안정성에 대해서는 이번 것도 문젯거리를 안고 있다. ‘new Bitmap’ 부분에서 예외가 터지게 되면, Widget 객체는 결국 삭제된 Bitmap을 가리키는 포인터를 껴안고 홀로 남고 만다. 이런 포인터는 delete 연산자를 안전하게 적용할 수도 없고, 안전하게 읽는 것조차 불가능하다.

pb가 가리키는 객체를 복사 후 삭제하는 방식으로 해결해보자.

```cpp
Widget& Widget::operator=(const Widget& rhs)
{
	Bitmap *pOrig = pb; // 원본 저장
	pb = new Bitmap(*rhs.pb); // rhs의 pb 사본으로 pb에 저장
	delete pOrig; // 원본은 delete
	
	return *this;
}
```

이 코드는 이제 원본 비트맵을 복사해 놓고, 복사해 놓은 사본을 포인터가 가리키게 만든 후, 원본을 삭제하는 순서로 실행되기 때문이다. 이제 ‘new Bitmap’ 부분에서 예외가 발생하더라도 pb는 변경되지 않은 상태가 유지된다.

효율이 너무 신경 쓰인 나머지, 일치성 테스트를 함수 앞단에 다시 붙여 놓고 싶은 사람도 있을 것이다. 하지만, 프로그램에서 자기대입이 얼마나 자주 일어날까? 일치성 테스트는 공짜가 아니다. 일치성 검사 코드가 들어가면 그만큼 코드가 코지고, 처리 흐름에 분기를 만들게 되므로 실행 시간 속력이 줄어들 수 있다. 추가로 CPU 명령어 선행인출, 캐시, 파이프라이닝 등의 효과도 떨어질 수 있다.

- CPU 명령어 선행인출: CPU가 프로그램에서 필요한 명령어들을 미리 읽어 들이는 방식. 분기 예측이 실패하면, 미리 읽어들인 명령어들이 잘못된 경우가 되어 효율이 떨어진다.
- 캐시: 자주 사용하는 데이터를 메모리에서 빨리 가져오기 위한 고속 메모리. 사용할 데이터가 캐시에 저장되어 있지 않는 상황(캐시 미스)이 발생하면, 캐시의 효과가 줄어든다.
- 파이프라이닝: CPU가 명령어를 여러 단계(인출→해석→실행→저장)로 나누어 처리할 때, 각 단계를 병렬로 처리해 성능을 높이는 기법. 분기 예측 오류로 인해 파이프라인을 다시 시작해야 한다면 효과가 줄어든다.

다른 방법이 있다. ‘복사 후 맞바꾸기’(Copy And Swap, CAS)라고 알려진 기법이다. 이 기법은 예외 안전성과 아주 밀접한 관계에 있다.

```cpp
class Widget {
	...
	void swap(Widget& rhs);
	...
};
Widget& Widget::operator=(const Widget& rhs)
{
	Widget temp(rhs);
	swap(temp);
	return *this;
}
```

이 방법은 C++가 가진 특징을 이용해 다르게 구현할 수도 있다.

1. 클래스의 복사 대입 연산자는 인자를 값으로 취하도록 선언하는 것이 가능하다.
2. 값에 의한 전달을 수행하면 전달된 대상의 사본이 생긴다.

```cpp
Widget& Widget::operator=(Widget& rhs)
{
	swap(rhs);
	
	return *this;
}
```

이 코드는, 명확성이 다소 떨어질 수 있다는 걱정이 존재한다. 하지만 객체를 복사하는 코드가 매개변수의 생성자로 옮겨졌기 때문에, 컴파일러가 더 효율적인 코드를 생성할 수 있는 여지가 생겼다.

swap을 활용하는 경우에는, private이나 protected 데이터 멤버에 접근해야하고 전역 함수 같이 사용하기 위해 friend 함수로 선언을 많이 한다고 한다.

https://www.geeksforgeeks.org/c-program-to-swap-two-members-using-friend-function/

> operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 하자. 원본과 복사대상의 주소를 비교하거나, 문장의 순서를 조정하거나, CAS 기법을 써도 된다.
두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 같은 객체인 경우에 정확하게 동작하는지 확인해보자.