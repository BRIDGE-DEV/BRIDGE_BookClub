# 챕터5: 구현

클래스와 함수의 골격이 준비된 이상, 여기에 맞추어 코드의 살을 붙이는 구현 작업은 별로 어렵지 않다. 하지만, 구현 중에 발생할 수 있는 문제가 아직 남아있다.

## 항목 26: 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자

생성자 혹은 소멸자를 끌고 다니는 타입으로 변수를 정의하면 반드시 물게 되는 비용이 두 개 있다. 하나는 프로그램 흐름이 변수의 정의에 닿을 때 생성자가 호출되는 비용이고, 다른 하나는 그 변수가 유효범위를 벗어날 때 소멸자가 호출되는 비용이다. 변수가 정의되었으나 사용되지 않은 경우에도 비용은 부과된다.

```cpp
std::string encryptPassword(const std::string& password)
{
	using namespace std;
	string encrypted;
	if(password.length() < MinimumPasswordLength)
	{
		throw logic_error("Password is too short");
	}
	...
	
	return encrypted;
}
```

위 코드의 `encryptPassword`를 보자. `if`문 안에서 예외가 발생해 던져진다면, `encrypted` 객체는 사용하지 않게 된다. 이렇게 되면 `encrypted` 객체는 사용하지 않지만 생성과 소멸에 대해 비용을 지불하는 것이다.

최대한 정의를 미루고, 의미 없는 기본 생성자 호출도 건너뛰도록 해보자.

```cpp
std::string encryptPassword(const std::string& password)
{
	using namespace std;
	...
	string encrypted(password);
	
	encrypt(encrypted);
	return encrypted;
}
```

‘늦출 수 있는 데까지’의 진짜 뜻이 이것이다. 어떤 변수를 사용해야 할 때가 오기 전까지 정의를 늦추고, 거기에 초기화 인자를 손에 넣기 전까지 정의를 늦출 수 있는지도 둘러봐야 한다.

어떤 변수가 루프 안에서만 쓰이는 경우라면, 해당 변수를 루프 바깥에서 미리 정의해 놓고 루프 안에서 대입하는 방법이 좋을까, 아니면 루프 안에서 변수를 정의하는 방법이 좋을까?

루프를 n번 진행한다면, 전자는 생성자 1번 + 소멸자 1번 + 대입 n번 진행한다. 후자는 생성자 n번 + 소멸자 n번 진행한다. 클래스 중에는 대입에 들어가는 비용이 생성자-소멸자 쌍보다 적게 나오는 경우가 있는데 이런 경우에는 전자가 훨씬 효율이 좋다. 그렇지 않은 경우라면 후자가 좋을 것이다.

다만 전자 방법을 사용하면, 변수의 유효범위가 후자보다 넓어져서 프로그램 이해도, 유지보수성이 역으로 안 좋아질 수도 있다. 대입이 생성자-소멸자 쌍보다 비용이 덜 들고, 전체 코드에서 수행 성능에 민감한 부분을 건드리는 중이라고 생각하지 않는다면, 후자 방법이 무조건 좋다.

> 변수 정의는 늦출 수 있을 때까지 늦추자.