# 챕터5: 구현

## 항목 31: 파일 사이의 컴파일 의존성을 최대로 줄이자

> 연말 닭살 커플들의 염장행각에 의욕을 상실했던 여러분은, 면식수행과 주침야활로 점철된 폐인 인생에 종지부를 찍고 한두 달 전 쯤 접었던 C++ 프로그램을 다시 작업하기로 결심한다.

뜬금 없는 초입부다.

```cpp
class Person {
public:
	Person(const std::string& name, const Date& birthday, const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
private:
	std::string theName;
	Date theBirthDate;
	Address theAddress;
};
```

위의 코드만 가지고 Person 클래스가 컴파일될 수 있을까? 아니다. `string`, `Date`, `Address` 가 어떻게 정의되었는지를 모르면 컴파일 자체가 불가능하다. 이때 쓰는 것이 `#include` 지시자다.

하지만 `#include` 문은 `Person` 을 정의한 파일과 다른 헤더파일 사이에 ‘컴파일 의존성’을 엮어버린다. 헤더 파일이 하나라도 바뀌면, 혹은 이들과 또 엮여 있는 헤더파일이 바뀌기만 해도 `Person` 클래스를 정의한 파일은 컴파일러에게 끌려가야 하고, 이를 사용하는 다른 파일들까지 다시 컴파일되어야 한다.

이런 경우를 위해 ‘전방 선언’을 이용한다. `Person` 클래스를 정의할 때 구현 세부 사항을 따로 떼어서 지정하는 식으로 한다. 물론 `string` 같은 표준 라이브러리 헤더는, 어지간한 경우가 아니면 컴파일시 병목요인이 아니기 때문에 전방 선언할 필요가 없다. 오히려 전방 선언 했다가 템플릿을 추가로 끌고 와야 해서 더 복잡한 경우가 생긴다.

또한 모두 ‘전방 선언’ 하게 된다면, 컴파일러가 컴파일 도중에 객체의 크기를 전부 알아야 하는데 그것이 되지 못한다. 물론 C++에서는 포인터 객체를 이용하면 이를 해결할 수 있다. ‘포인터 뒤에 실제 객체 구현부 숨기기’인 것이다.

```cpp
#include <string>
#include <memory>

class PersonImpl;
class Date;
class Address;
class Person {
public:
	Person(const std::string& name, const Date& birthday, const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
private:
	std::tr1::shared_ptr<PersonImpl> pImpl;
};
```

이런 설계는 pimpl 관용구라는 이름도 있다. 이제 `Person` 클래스에 대한 구현 클래스 부분은 생각만 있으면 마음대로 고칠 수 있다. 하지만 `Person` 클래스의 사용자 쪽에서는 컴파일을 다시 할 필요가 없다.

인터페이스와 구현을 둘로 나누는 열쇠는 ‘정의부에 대한 의존성’을 ‘선언부에 대한 의존성’으로 바꾸어 놓는 데 있다. 이것이 바로 컴파일 의존성을 최소화하는 핵심 원리이다.

정리해보자.

- 객체 참조자 및 포인터로 충분한 경우에는 객체를 직접 쓰지 않는다. 어떤 타입에 대한 참조자 및 포인터를 정의할 때는 그 타입의 선언부만 필요하다.
- 할 수 있으면 클래스 정의 대신 선언에 최대한 의존하도록 만든다. 어떤 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의를 가져오지 않아도 된다. 클래스 객체를 값으로 전달하거나 반환하더라도 클래스 정의가 필요 없다.
    
    ```cpp
    class Date; // 전방 선언
    Date today();
    void clearAppointments(Date d); // Date 클래스 정의 필요 없음
    ```
    
    이는 크게 이상한 것이 아니다. 함수 선언이 되어 있는 헤더파일이 쪽에 부담을 주는 것이 아니라, 실제 함수 호출이 일어나는 사용자의 소스 파일 쪽에 전가하는 방법을 사용하는 것이다.
    
- 선언부와 정의부에 대해 별도의 헤더 파일을 제공한다. 선언부를 위한 헤더 파일, 정의부를 위한 헤더 파일이 짝으로 있어야 한다. 이렇게 하면 이제 `Date` 클래스를 전방 선언 대신 선언부 헤더 파일만 `#include` 하면 된다.

pimpl 관용구를 사용하는 `Person` 같은 클래스를 가리켜 핸들 클래스라고 한다. 핸들 클래스에서 어떤 함수를 호출하게 되어 있다면, 핸들 클래스에 대응되는 구현 클래스 쪽으로 그 함수 호출을 전달해 구현 클래스가 실제 작업을 수행하게 만들자.

핸들 클래스 방법 대신에 다른 방법을 쓰고 싶다면 `Person`을 특수 형태의 추상 기본 클래스, 즉 인터페이스 클래스로 만드는 방법도 생각해볼 수 있다. 어떤 기능을 나타내는 인터페이스를 추상 기본 클래스를 통해 마련해 놓고, 이 클래스로부터 파생 클래스를 만들 수 있게 하자는 것이다. 자바 혹은 닷넷의 인터페이스는 언어 차원에서 데이터 멤버나 함수 구현을 아예 가질 수 없지만, C++에는 이런 것들에 대한 제약이 없다.

인터페이스 클래스의 인터페이스가 수정되지 않는 한 사용자는 다시 컴파일할 필요가 없다. 또한  인터페이스 클래스를 사용하기 위해서는 객체 생성 수단이 최소한 하나는 있어야 한다. 대개 이 문제는 팩토리 함수를 호출해 해결한다. 이는 주어진 인터페이스 클래스의 인터페이스를 지원하는 객체를 동적으로 할당한 후, 그 객체의 포인터를 반환한다.

정리하면, 인터페이스 클래스로부터 인터페이스 명세를 물려받게 만든 후에, 그 인터페이스에 들어 있는 함수를 구현하면 되는 것이다.

물론 이는 실행 시간 비용이 더 들어가고, 객체 한 개당 필요한 저장 공간이 추가로 필요하다. 또한 인터페이스 클래스의 경우에는 호출되는 함수가 전부 가상 함수이기 때문에, 가상 테이블 점프에 따르는 비용이 소모된다. 핸드 클래스의 경우에는 구현부 객체의 데이터까지 가기 위해 포인터를 타야 한다. 마지막으로 공통적으로 인라인 함수의 도움을 받기가 어렵다. 인라인은 본문을 대개 헤더 파일에 두기 때문이다.

하지만 이런 기법은 미래를 대비한다는 느낌으로 사용해야 한다. 개발 도중에는 핸들 클래스나 인터페이스 클래스를 사용하자. 그러다가 제품을 출시해야 할 때 다시 고민하는 것이다.

> 컴파일 의존성을 최소화하는 작업의 배경이 되는 가장 기본적인 아이디어는 ‘정의’ 대신에 ‘선언’에 의존하게 만드는 것이다. 핸들 클래스와 인터페이스 클래스가 이에 기반한 접근 방법이다.
라이브러리 헤더는 그 자체로 모든 것을 갖추어야 하며 선언부만 갖고 있는 형태여야 한다.