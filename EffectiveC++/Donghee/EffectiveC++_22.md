# 챕터4: 설계 및 선언

## 항목 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

데이터 멤버가 public이면 왜 안 되는지, public 멤버에 대한 이야기가 protected 데이터 멤버에도 똑같이 적용되는 모습을 확인해보자. public 데이터 멤버는 왜 안 될까?

우선 문법적 일관성 때문이다. 어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수라면, 클래스의 멤버에 접근할 때 괄호를 붙여야 하는지 말아야 하는지 고민할 필요가 없다. 그냥 괄호를 쓰면 된다.

또한 함수를 쓰면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할 수 있다. 데이터 멤버를 public으로 해놨다면 읽기/쓰기가 모두 가능하지만, 함수가 있다면 접근 불가/읽기 전용/읽기,쓰기 접근을 우리가 직접 구현할 수 있다. 심지어 쓰기 전용도 가능하다.

제일 중요한 것은 캡슐화이다. 함수를 통해서만 접근 가능하게 구현하면, 데이터 멤버를 나중에 계산식으로 대체할 수도 있고, 절대로 사용자는 이 클래스를 넘보지 못하게 되는 것이다. 여러 이유들로 인해 내부 구현을 이렇게 저렇게 바꿈에도 사용자는 그저 컴파일만 다시 하면 되는 것이다.

데이터 멤버를 함수 인터페이스 뒤에 감추게 되면 구현상의 융통성을 전부 누릴 수 있다. C#의 프로퍼티와 같은 맥락이라고 할 수 있다. 또한 데이터 멤버를 캡슐화하면, 클래스의 불변속성을 항상 유지하는 데 절대로 소홀해질 수 없게 된다. 불변속성을 보여줄 수 있는 통로가 멤버 함수밖에 없으니까 말이다.

C++ 세상에서 public이란 ‘캡슐화되지 않았다’는 뜻이며, 실질적인 측면에서 이야기할 때 ‘캡슐화되지 않았다’라는 말은 ‘바꿀 수 없다’라는 의미를 담고 있다. protected 데이터 멤버의 경우도, 앞서 말한 사정과 비슷하다. 어쨌든 public 데이터 멤버보다는 많이 가려진 것이 아니냐고 할 수 있지만, 아니다.

어떤 클래스에 public 데이터 멤버가 있고, 이것을 제거한다고 해보자. 이것을 사용하는 사용자 코드는 무사할 수 없을 것이다. 이젠 어떤 protected 데이터 멤버를 제거한다고 가정해보자. 이번엔 코드가 얼마나 망가질까? 이것을 사용하는 파생 클래스는 전부 망가질 것이다. 조금 가렸다고 가린 것이 아니다. protected 데이터 멤버나 public 멤버나 오십 보 백보란 말이다.

어떤 데이터 멤버를 일단 public 혹은 protected로 선언헀으며 사용자가 그것을 사용하기 시작했다면, 그때부터 그 멤버는 완전 코 꿰인 것이다. 캡슐화의 관점에서 쓸모 있는 접근 수준은 private과 private이 아닌 나머지 이렇게 둘뿐이다.

> 데이터 멤버는 private 멤버로 선언하자. 일관성 있는 데이터 접근 통로 제공, 세밀한 접근 제어 가능, 클래스의 불변속성 강화, 내부 구현의 융통성 발휘의 장점이 있다.
protected는 public보다 많이 보호받고 있는 것이 절대로 아니다.