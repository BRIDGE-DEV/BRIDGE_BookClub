# 챕터2: 생성자, 소멸자 및 대입 연산자

## 항목6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

어떤 클래스 MyClass의 객체는 **사본을 만드는 것이 불가**하게 만들고 싶다고 해보자. 이런 경우 우리는, 객체를 복사하려 하는 코드가 컴파일되지 않았으면 좋겠다는 생각을 한다.

일반적인 경우엔, 어떤 클래스에서 특정한 종류의 기능을 지원하지 않았으면 하는 경우엔 그 함수를 선언하지 않으면 된다. 그런데 이 전략은 복사 생성자와 복사 대입 연산자에 대해서는 ‘해당사항 없음’이다. 우리가 선언하지 않는다 해도, 외부에서 호출하려고 하면 컴파일러가 우리 대신 이들을 선언해버리기 때문이다.

해결의 열쇠는 다음과 같다. 복사 생성자와 복사 대입 연산자를 private으로 선언하자. 그렇다면 일단 클래스 멤버 함수가 명시적으로 선언되기 때문에, 컴파일러는 자신의 기본 버전을 만들 수 없게 된다.

물론 private 멤버 함수는 그 클래스의 멤버 함수나, friend 함수가 호출할 수 있다는 점이 여전히 허점이다. 그 클래스의 friend 함수로 지정된 함수는, private 멤버로 들어가있는 모든 요소를 사용할 수 있기 때문이다. 이것까지 막으려면 **정의(define)**를 안 해 버리면 어떨까?

정의되지 않은 함수를 실수로 호출하려 한다면, 링크 시점에서 에러를 보게 될 것이다. 이 기법은 꽤 널리 퍼지며 하나의 ‘기법’으로 굳어지기까지 했다.

```cpp
class MyClass {
public:
	...
private:
	...
	// 둘다 선언만 존재
	MyClass(const MyClass&);
	MyClass& operator=(const MyClass&);
};
```

사용자가 MyClass 객체의 복사를 시도하면 컴파일러가 에러를 내고, 깜빡하고 멤버 함수나 friend 함수를 통해 복사를 시도하면 링커가 에러를 낼 것이다.

이 링크 시점 에러를 컴파일 시점 에러로 옮길 수도 있다. 위처럼 private으로 복사 생성자와 복사 대입 연산자를 선언하되, 별도의 기본 클래스에 넣고 이를 상속하는 방식으로 가는 것이다.

```cpp
class Uncopyable {
protected:
	// 생성과 소멸은 가능 
	Uncopyable() {}
	~Uncopyable() {}
private:
	// 복사 방지
	Uncopyable(const Uncopyable&);
	Uncopyable& operator=(const Uncopyable&);
};
```

다음의 Uncopyable 클래스를 상속하면, 앞에 나왔던 모든 문제들은 컴파일러가 에러로 처리해준다. 이는 private으로 상속해도 되고, Uncopyable의 소멸자는 가상 소멸자일 필요가 없다. 다음 항목에 나오겠지만, 다형성을 갖춘 기본 클래스가 아니기 때문이다.

> 컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 private로 선언한 후에 구현은 하지 않은 채로 둬라.
> Uncopyable과 비슷한 기본 클래스를 쓰는 것도 방법이다.