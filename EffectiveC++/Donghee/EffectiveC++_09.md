# 챕터2: 생성자, 소멸자 및 대입 연산자

## 항목 9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자

항목명을 다시 보자. **객체 생성 및 소멸 과정 중에는 가상 함수를 호출하면 절대로 안된다.** 생각해보자. 기본 클래스 생성자는 파생 클래스 생성자보다 앞서서 실행된다. 따라서 기본 클래스 생성자가 돌아가고 있을 시점에는, 파생 클래스 데이터 멤버는 아직 초기화 상태가 아니라는 것이다.

결국 기본 클래스의 생성자가 호출될 동안에는, 가상 함수는 절대로 파생 클래스 쪽으로 내려가지 않는다. 그 대신, 객체 자신이 기본 클래스 타입인 것처럼 동작한다.

객체가 소멸될 때는 어떨까?  아까와 똑같이 생각해보자. 파생 클래스의 소멸자가 일단 호출되고 나면, 파생 클래스만의 데이터 멤버는 정의되지 않은 값으로 가정하기 때문에 C++는 이들을 없는 것처럼 취급한다. 또한 기본 클래스 소멸자에 진입할 당시의 객체는 그저 기본 클래스 객체가 되고, 모든 C++ 기능들 역시 기본 클래스 객체의 자격으로 처리한다.

생성자나 소멸자에서 가상 함수를 호출하는 경우에는, 컴파일러에서 직접 경고 메세지를 띄워주는 경우도 있다. 하지만 생성자나 소멸자에서 호출한 비가상 함수가 다시 가상 함수를 호출하는 골치아픈 경우가 나온다면, 컴파일은 잘 되지만 실행 과정에서 결함이 발생할 것이다. 이 문제를 해결하는 방법은 별 다른 게 없다. 그저 생성자나 소멸자에서 가상 함수를 호출하는 코드를 잘 솎아내고, 이들에서 호출되는 함수가 똑같은 제약을 따르게 만드는 방법밖에는 없다.

그렇다면 우리가 정말 기본 클래스 생성자에서 다형성을 가질 수는 없을까? 여러 방법이 있지만 다음의 예제로 한 방법을 알아보자.

```cpp
class Transaction {
public:
	// 객체의 묵시적 형변환을 막는 explicit 키워드
	explicit Transaction(const std::string& logInfo);
	void logTransaction(const std::string& logInfo);
	...
};

Transaction::Transaction(const std::string& logInfo)
{
	...
	logTransaction(logInfo);
}
class BuyTransaction: public Transaction {
public:
	BuyTransaction(...) : Transaction(createLogString(,,,)) {...}
private:
	static std::string createLogString(...);
};
```

Transaction이 기본 클래스, BuyTransaction이 파생 클래스이다. Transaction의 생성자에서 logInfo 인자를 받아 logTransaction 함수를 호출시켜준다. 여기서 파생되는 BuyTransaction의 생성자는 createLogString 함수를 통해 사용할 정보를 미리 넘겨주는 형태이다.

가상 함수를 호출하는 대신, 필요한 초기화 정보를 파생 클래스 쪽에서 기본 클래스 생성자로 올려주도록 만드는 것이다. createLogString 함수는 정적 멤버이기 때문에, 파생 클래스의 미초기화 이슈를 고려할 필요도 없다.

> 생성자 혹은 소멸자 안에서 가상 함수를 호출하지 말자.
> 가상 함수라고 해도 지금 실행 중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로는 내려가지 않는다.