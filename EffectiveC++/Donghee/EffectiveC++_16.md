# 챕터3: 자원 관리

## 항목 16: new 및 delete를 사용할 때는 형태를 반드시 맞추자

```cpp
std::string *stringArray = new std::string[100];
...
delete stringArray;
```

위의 예제를 보자. 다음과 같은 코드를 가진 프로그램은 미정의 동작을 보이게 된다. stringArray가 가지고 있는 100개의 string 객체들 중 적어도 99개는 제대로 된 소멸 과정을 거치지 못할 것이기 때문이다.

new 연산자를 사용해서 표현식을 꾸미게 되면 이로 인해 두 가지 내부 동작이 진행된다. 먼저 메모리가 할당되고, 이후 할당된 메모리에 대해 한 개 이상의 생성자가 호출된다.

delete 표현식을 쓸 경우에는 똑같이 또 다른 두 가지의 내부 동작이 진행된다. 우선 기존에 할당된 메모리에 대해 한 개 이상의 소멸자가 호출되고, 그 후 그 메모리가 해제된다. 여기서 delete 연산자가 적용되는 객체는 몇 개일까? 이 질문의 답이 ‘소멸자가 호출되는 횟수’이다.

다시 말하자면 이런 말이다. **삭제되는 포인터는 객체 하나만 가리킬까, 혹은 객체의 배열을 가리킬까?** 중요한 점은 단일 객체의 메모리 배치구조는 객체 배열에 대한 메모리 배치구조와 다르다. 배열을 위해 만들어지는 힙 메모리에는 대개 배열원소의 개수가 박혀 들어간다.

어떤 포인터에 대해 delete를 적용할 때, delete 연산자로 하여금 ‘배열 크기 정보가 있다’는 것을 알려주는 건 우리에게 달려 있다. 대괄호 쌍 []을 delete 뒤에 붙여주는 것이다. 그제서야 delete가 ‘포인터가 배열을 가리키고 있구나’라고 가정한다.

```cpp
std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100];
...
delete stringPtr1; // 객체 하나 삭제
delete [] stringPtr2; // 객체 배열 삭제
```

위의 코드에서 stringPtr1에 ‘[]’ 형태를 사용하면 어떻게 될까? 우선 delete는 앞쪽의 메모리 몇 바이트를 읽고 이것을 배열 크기라고 인식한다. 그 후 배열 크기에 해당하는 횟수만큼 소멸자를 호출하려 할 것이다. 그러다 메모리가 배열이 아니고, 타입도 알맞지 않다는 것을 알게 된다.

그렇다면 stringPtr2에 ‘[]’ 형태를 사용하지 않는다면 어떨까? 정의된 바는 없으나 ‘소멸자 호출 횟수가 너무 적다’라는 것이 문제가 되는 것은 확실하다. int 등의 기본 제공 타입이어도 배열에 대해 []을 사용하지 않으면 미정의 동작이 나타난다.

결국 new 표현식에 []를 썼으면, 여기에 대응되는 delete 표현식에도 []를 써야한다. new 표현식에 []을 안 썼으면, 대응되는 delete 표현식에도 []을 안 쓰면 된다.

typedef로 만든 타입이 사실 배열 객체를 담고 있다면, new에는 []를 쓰지 않았더라도 delete에는 써야하는 상황이 발생한다.

```cpp
typedef std::string AddressLines[4];
std::string *pal = new AddressLines;
// delete pal; // 정의 X
delete [] pal; // 제대로 메모리 해제
```

C++에서는 머리 아픈 typedef보다는 string, vector 같은 좋은 클래스 템플릿을 쓰는 것이 낫다.

> new 표현식에 []를 썼으면, 여기에 대응되는 delete 표현식에도 []를 써야한다.
new 표현식에 []을 안 썼으면, 대응되는 delete 표현식에도 []을 안 쓰면 된다.