# 챕터6: 상속, 그리고 객체 지향 설계

## 항목 40: 다중 상속은 심사숙고해서 사용하자

‘다중 상속’하면 꼭 알아야 하는 사실이 있다. 둘 이상의 기본 클래스로부터 똑같은 이름(함수, typedef 등)을 물려받을 가능성이 생긴다는 것이다. 즉, 다중 상속 때문에 모호성이 생긴다는 것이다.

```cpp
class BorrowableItem {
public:
	void checkOut();
	...
};
class ElectronicGadget {
private:
	bool checkOut() const;
	...
};
class MP3Player: public BorrowableItem, public ElectronicGadget { ... };

MP3Player mp;
mp.checkOut(); // 모호성 발생
```

이 예제에서, `ElectronicGadget::checkOut`은 private이기 때문에, 두 `checkOut` 함수들 중에서 파생 클래스가 접근할 수 있는 함수가 분명해 보인다. 그럼에도 불구하고 모호성이 생긴다. 이는 중복된 함수 호출 중 하나를 골라내는 C++의 규칙을 따른 결과이다. 먼저 최적 일치 함수를 찾은 후에 비로소 함수의 접근가능성을 점검한다는 이야기이다.
이 모호성을 해소하려면, 호출할 기본 클래스의 함수를 손수 지정해줘야 한다.

```cpp
mp.BorrowableItem::checkOut();
```

다중 상속의 의미는 그냥 ‘둘 이상의 클래스로부터 상속을 받는 것’일 뿐이지만, MI(다중 상속)는 상위 단계의 기본 클래스를 여러 개 갖는 클래스 계통에서 심심치 않게 눈에 띈다.

```cpp
class File { ... };
class InputFile: public File { ... };
class OutputFile: public File { ... };
class IOFile: public InputFile, public OutputFile { ... };
```

이렇게 기본 클래스와 파생 클래스 사이의 경로가 두 개 이상 되는 상속 계통을 혹시라도 쓰게 되면, ‘기본 클래스의 데이터 멤버가 경로 개수만큼 중복 생성될 수 있다’는 의혹을 피하지 못한다.

C++은 기본적으로는 데이터 멤버를 중보생성하는 쪽으로 지원한다. 만약 중복생성을 원한 것이 아니었다면, 해당 데이터 멤버를 가진 클래스(여기서는 File)를 **가상 기본 클래스**로 만드는 것으로 해결할 수 있다.

```cpp
class File { ... };
class InputFile: virtual public File { ... };
class OutputFile: virtual public File { ... };
class IOFile: public InputFile, public OutputFile { ... };
```

정확한 동작의 관점에서 보면, public 상속은 항상 가상 상속이어야 하는 것이 맞다. 하지만, 상속되는 데이터 멤버의 중복생성을 막는 데엔 보이지 않는 컴파일러의 꼼수가 필요하다. 꼼수 덕분에, 가상 상속을 사용하는 클래스로 만들어진 객체는 가상 상속을 쓰지 않은 것보다 크기가 더 크다. 또한 가상 기본 클래스의 데이터 멤버에 접근하는 속도도 비가상 기본 클래스의 데이터 멤버에 접근하는 속도보다 느리다. 즉, 가상 상속은 비싸다.

다른 쪽으로도 비용이 생긴다. 가상 기본 클래스의 초기화에 관련된 규칙은 비가상 기본 클래스의 초기화 규칙보다 훨씬 복잡한데다가 직관성도 떨어진다. 초기화 규칙은 다음과 같다.

1. 초기화가 필요한 가상 기본 클래스로부터 클래스가 파생된 경우, 파생 클래스는 가상 기본 클래스의 존재를 염두에 두고 있어야 한다.
2. 기존의 클래스 계통에 상관없이 파생 클래스를 새로 추가할 때도 그 파생 클래스는 가상 기본 클래스의 초기화를 떠맡아야 한다.

가상 기본 클래스는 구태여 쓸 필요가 없으면 사용하지 말자. 혹시 가상 기본 클래스를 정말 쓰지 않으면 안 될 상황이라면, 가상 기본 클래스에는 데이터를 넣지 않는 쪽으로 최대한 신경쓰자.

다중 상속을 의미 있게 쓰는 경우는, 인터페이스의 public 상속과 구현의 private 상속을 조합하는 경우다.

다중 상속은 대단한 것이 아니다. 그냥 객체 지향 기법으로 소프트웨어를 개발하는 데 쓰이는 도구 중 하나로 보자. MI 설계와 동등한 효과를 내는 SI(단일 상속) 설계를 뽑을 수 있다면 SI 쪽으로 가는 것이 확실히 좋다. 머리에 쥐가 나게 궁리해서 MI 설계밖에 나오지 않는다 해도 조금만 더 고민해라. 웬만한 경우엔 SI로도 똑같이 할 수 있는 방법을 찾을 수 있다. ‘이때다’라고 확신이 들면 주저 말고 MI를 지르자.

> 다중 상속은 단일 상속보다 확실히 복잡하다.
가상 상속을 쓰면 크기 비용, 속도 비용이 늘어나며, 초기화 및 대입 연산의 복잡도가 커진다. 가상 기본 클래스에는 데이터를 두지 않는 것이 실용적이다.
다중 상속을 적법하게 쓰는 경우는, 인터페이스 클래스로부터 public 상속을 시킴과 동시에 구현을 돕는 클래스로부터 private 상속을 시키는 것이다.