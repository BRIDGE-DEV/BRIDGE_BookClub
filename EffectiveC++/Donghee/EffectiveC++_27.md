# 챕터5: 구현

## 항목 27: 캐스팅은 절약, 또 절약! 잊지 말자

이론적으로 C++ 프로그램은 일단 컴파일만 깔끔하게 끝나면, 그 이후엔 어떤 객체에 대해서도 불안전한 연산이나 말도 안되는 연산을 수행하려 들지 않는다. 이런 타입 시스템을 가볍게 무시할 수 있는 괴물이 있는데, ‘캐스트’이다. C++에서 캐스팅은 정말 조심해서 써야하는 기능이다.

C 스타일의 캐스트를 먼저 보자. `(T) 표현식`, `T(표현식)`으로 표현된다. 이들이 가진 의미는 똑같다. 이들을 ‘구형 스타일의 캐스트’라고 부르자.

C++는 네 가지로 이루어진 새로운 형태의 캐스트 연산자를 독자적으로 제공한다.

- `const_cast<T>(표현식)`: 객체의 상수성을 없애는 용도로 사용된다. 이 기능을 가진 C++ 스타일의 캐스트는 이것뿐이다.
- `dynamic_cast<T>(표현식)`: 안전한 다운캐스팅을 할 때 사용하는 연산자다. 주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지 결정한다. 런타임 비용이 높다.
- `reinterpret_cast<T>(표현식)`: 포인터를 int로 바꾸는 등 하부 수준 캐스팅을 위해 만들어졌다. 이런 캐스트는 하부 수준 코드 외에는 거의 없어야 한다.
- `static_cast<T>(표현식)`: 암시적 변환을 강제로 진행할 때 사용한다. 비상수 객체 → 상수 객체, int → double 등에 사용된다. 물론 상수 객체를 비상수 객체로 캐스팅하는 데 쓸 수는 없다.

C++ 스타일의 캐스트를 쓰는 것이 바람직하다. 코드를 읽을 때 알아보기 쉽고, 캐스트를 사용한 목적을 더 좁혀 지정하기 때문에 컴파일러 쪽에서 오류를 진단할 수 있기 때문이다. 예를 들어 상수성을 없애려고 한 부분에 `const_cast`가 아닌 다른 캐스팅을 썼다면 컴파일 자체가 되지 않는 것이다.

캐스팅은 어떻게 쓰더라도 일단 타입 변환이 있으면 이로 인해 런타임에 실행되는 코드가 만들어지는 경우가 많다. 아래의 코드를 보자.

```cpp
class Base { ... };
class Derived: public Base { ... };
Derived d;
Base *pd = &d;
```

파생 클래스 객체에 대한 기본 클래스 포인터를 만드는 코드이다. 이때 두 포인터의 값이 같지 않을 때도 존재한다. 이런 경우가 되면, 포인터의 변위를 `Derived*` 포인터에 적용해 실제 `Base*` 포인터 값을 구하는 동작이 런타임에 이루어진다.

C++에서는 다중 상속이 사용되면 이런 현상이 항상 생기지만, 단일 상속인데도 이렇게 되는 경우도 있다. 어떤 객체의 주소를 char* 포인터로 바꿔서 포인터 산술 연산을 적용하는 등의 코드는 거의 항상 미정의 동작을 낳는다. 객체의 메모리 배치구조를 결정하는 방법과 객체의 주소를 계산하는 방법은 컴파일러마다 천차만별이다.

가상 함수를 파생 클래스에서 재정의해 구현할 때, 기본 클래스의 버전을 호출해야하는 경우가 있다. 이때 틀린 경우로 구현하는 경우가 꽤 있다. 아래 예제를 보자.

```cpp
class Window {
public:
	virtual void onResize() { ... }
	...
};
class SpecialWindow: public Window {
public:
	virtual void onResize()
	{
		static_cast<Window>(*this).onResize();
		...
	}
	...
};
```

이 코드에서는 캐스팅이 일어나면서 `*this` 의 기본 클래스 부분에 대한 사본이 임시적으로 만들어진다. `onResize`는 바로 이 임시 객체에서 호출되는 것이다. 다시 말하면, `SpeicalWindow`만의 동작을 현재 객체에 대해 수행하기도 전에 기본 클래스 부분의 사본에 대고 `Window::onResize`를 호출하는 것이다. 만약 `Window::onResize`가 객체를 수정하도록 만들어져 있다면, 그 객체는 수정이 반영되지 않는다. 사본을 수정하기 때문이다.

이 문제를 풀려면 캐스팅을 빼고, 현재 객체에 대고 바로 `onResize`의 기본 클래스 버전을 호출하도록 만들어야 한다.

```cpp
class SpecialWindow: public Window {
public:
	virtual void onResize()
	{
		Window::onResize();
		...
	}
	...
};
```

캐스트 연산자가 입맛 당기는 상황이라면 뭔가 꼬여가는 징조다. `dynamic_cast`가 당기는 상황에는 더더욱 그렇다. 일단 이 연산자는 상당수의 구현환경에서 정말 느리게 구현되어 있다. 수행 성능에 사활이 걸린 코드라면 `dynamic_cast`에 주의를 놓지 말아야 한다.

`dynamic_cast` 연산자가 쓰고 싶어지는 때는 분명 있다. 파생 클래스 객체임이 분명한 객체가 있어서 이에 대해 파생 클래스 함수를 호출하고 싶은데, 그 객체를 조작할 수 있는 수단으로 기본 클래스의 포인터밖에 없을 경우가 존재하기 때문이다. 이런 문제를 피해 가는 일반적 방법은 두 가지가 있다.

첫 번째, 파생 클래스 객체에 대한 포인터를 컨테이너에 담아둠으로써 기본 클래스 인터페이스를 통해 조작할 필요를 아예 없애 버리는 것이다. 하지만 이 방법으로는 서로 다른 타입의 포인터를 담으려면 컨테이너가 여러 개 필요하다.

두 번째 방법으로는 원하는 조작을 가상 함수 집합으로 정리해 기본 클래스에 넣는 것이다. 파생 클래스에만 존재하던 함수를 기본 클래스에 빈 구현으로 놔둔 채 가상 함수로 제공하면 된다.

두 가지 방법 모두 모든 상황에 적용하기란 불가능하지만, 상당히 많은 상황에서 `dynamic_cast` 대신 사용할 수 있다.

정말 잘 작성된 C++ 코드는 캐스팅을 거의 쓰지 않는다. 최대한 캐스팅과 멀어지자. 캐스팅을 해야 하는 코드를 내부 함수 속에 몰아 놓고, 그 안에서 일어나는 낮은 수준에 일들은 외부에서 알 수 없도록 인터페이스를 막아두는 식으로 해결하면 된다.

> 캐스팅은 피하라. 특히 수행 성능에 민감한 코드에서 `dynamic_cast`는 몇 번이고 다시 생각하라.
캐스팅이 어쩔 수 없이 필요하다면, 함수 안에 숨길 수 있도록 해보자.
구형 스타일의 캐스트보다는 C++ 스타일의 캐스트를 선호하자. 발견하기도 쉽고, 어떤 역할을 의도했는지가 더 자세하게 드러난다.