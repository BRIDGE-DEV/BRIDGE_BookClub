# 챕터6: 상속, 그리고 객체 지향 설계

C++의 OOP는 우리가 익히 알고 있는 OOP보다 조금 더 생각할 부분이 많다. 상속은 단일 상속과 다중 상속이 가능하고, 상속 관계 하나하나가 public, protected, private의 성질을 가질 수 있다. 또한 가상 상속, 비가상 상속이 얹힐 수 있다. 객체 지향 프로그래밍에 있어 C++가 갖고 있는 이런저런 특징의 의미를 이해하고 나면, 일단 OOP를 보는 눈이 바뀔 것이다.

## 항목 32: public 상속 모형은 반드시 “is-a”를 따르도록 만들자

중요한 규칙이 하나 있다. public 상속은 “is-a”를 의미한다. 클래스 D(Derived)를 클래스 B(Base)로부터 public 상속을 통해 파생시켰다면, 컴파일러에게 이렇게 말한 것과 같다. ‘D 타입으로 만들어진 모든 객체는 또한 B 타입의 객체지만, 그 반대는 되지 않는다.’ 다시 말해 B는 D보다 더 일반적인 개념이고, D는 B보다 더 특수한 개념을 나타낸다. 즉, D 타입이 필요한 부분에 B 타입의 객체를 쓰는 것은 불가능하다. 모든 D는 B의 일종이지만(D is a B), B는 D의 일종이 아니다.

public 상속과 is-a 관계가 같은 뜻이라는 이야기는 꽤 직관적이지만, 그 직관 때문에 판단을 잘못할 수도 있다. 예를 들어 새-펭귄의 관계를 생각하면 된다. `Bird` 기본 클래스에 `Fly`라는 함수가 있어도, `Penguin` 클래스는 날지 못하기 때문에 is-a 관계에 따른 직관이 애매해진다. 이럴 때는 `FlyingBird`라는 또다른 파생 클래스를 이용해 ‘비행 능력’을 구분할 필요가 있다. 물론, `Fly` 라는 ‘비행 능력’ 자체가 필요하지 않는 프로그램도 있다.

무릇 최고의 설계는, 제작하려는 소프트웨어 시스템이 기대하는 바에 따라 달라지는 것이다. 지금 만드는 프로그램이 비행에 대한 지식을 전혀 쓰지 않으며 나중에도 쓸 일이 없을 것이라면, 굳이 날 수 있는 새, 아닌 새를 구분하지 않는 것이 좋을 수 있다.

그렇다면 `Fly` 함수를 가상 함수로 선언해, `Penguin`에서는 에러 코드를 호출하게 하는 것은 어떨까? 이는 그다지 좋은 방법은 아니다. 코드가 컴파일된다는 것이 유효하지 않은 코드를 컴파일 단계에서 막아 주는 인터페이스가 좋은 인터페이스다. 차라리 선언되지 않는 것이 좋다는 것이다.

public 상속은 기본 클래스 객체가 가진 모든 것들이 파생 클래스 객체에도 그대로 적용된다고 단정하는 상속이다. 그대로 적용될 때 문제가 있을 것이라고 판단되면, public 상속을 하면 안 된다.

> public 상속의 의미는 “is-a”이다. 기본 클래스에 적용되는 모든 것들이 파생 클래스에 그대로 적용되어야 한다.