# 챕터5: 구현

## 항목 29: 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자!

GUI 메뉴를 구현하기 위해 `PrettyMenu`의 `changeBackground`라는 함수를 아래와 같이 구현되었다고 생각해보자.

```cpp
void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	lock(&mutex);
	delete bgImg;
	++imageChanges;
	bgImage = new Image(imgSrc);
	unlock(&mutex);
}
```

예외 안전성이라는 측면에서 이 함수는 이보다 더 나쁠 수 없다.

예외 안전성을 가진 함수라면 예외가 발생할 때 이렇게 동작해야 한다.

- 자원이 새도록 만들지 않는다: 하지만 위 코드는 자원이 샌다. `new Image(imgSrc)` 표현식에서 예외를 던지면 `unlock`함수가 실행되지 않기 때문에 뮤텍스가 계속 잡힌 상태가 된다.
- 자료구조가 더렵혀지는 것을 허용하지 않는다: 위 코드는 `new Image(imgSrc)`가 예외를 던지면 `bgImage`가 가리키는 객체는 이미 삭제된 후이다. 또한 `imageChanges` 변수는 이미 증가되었을 것이다.

뮤텍스의 경우에는, ‘항목 14’에서 나온 것처럼 소멸자에서 `unlock`을 시키는 자원관리 객체를 만들면 해결할 수 있다. 하지만 아직 자료구조 오염 문제가 남아있다. 그전에 예외 안전성을 갖춘 함수가 가질 수 있는 세 가지 보장을 알아보자.

- 기본적인 보장: 함수 도중에 예외가 발생하면, 실행 중인 프로그램에 관련된 모든 것을 유효한 상태로 유지하겠다는 보장이다.  모든 객체의 상태는 일관성을 유지한다. 하지만 프로그램 상태가 정확히 어떠한지는 예측이 어려울 수 있다. 이 부분은 전적으로 함수를 만든 사람에 달려 있다.
- 강력한 보장: 함수 동작 중에 예외가 발생하면, 프로그램의 상태를 절대로 변경하지 않겠다는 보장이다. 원자적(atomic) 동작이다. 호출이 성공하면 마무리까지 완벽하게 성공하고, 실패하면 함수 호출이 없었던 것처럼 상태가 되돌아간다. 예측할 수 있는 프로그램의 상태가 두 개밖에 안 되기 때문에, 쓰기 편하다.
- 예외불가 보장: 예외를 절대로 던지지 않겠다는 보장이다. 기본제공 타입(int, 포인터 등)에 대한 모든 연산은 예외를 던지지 않게 되어 있다.

예외 안전성을 갖춘 함수는 위 세 가지 보장 중 하나를 반드시 제공해야 한다. 하나를 고르라면 실용성 있는 강력한 보장이 괜찮아 보인다. 현실적으로는 대부분의 함수에 있어서 기본적인 보장과 강력한 보장 중 하나를 고르게 된다.

위의 `changeBackground` 함수를 강력한 보장을 거의 제공하도록 변경해보자.

```cpp
class PrettyMenu {
	...
	std::tr1::shared_ptr<Image> bgImage;
	...
};
void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	Lock(&mutex);
	bgImage.reset(new Image(imgSrc));
	
	++imageChanges;
}
```

이젠 이전의 배경그림을 프로그래머가 직접 삭제할 필요가 없다. 또한 `imageChanges`가 실제로 배경이 바뀌기 전에 증가하지 않도록 순서를 변경했다. 하지만 아직 완벽하지 않다. `Image` 클래스의 생성자가 실행되다가 예외를 일으키면, 그 시점에 입력 스트림의 읽기 표시자가 이동한 채로 남아 있을 가능성이 있다. 따라서 엄밀히 말하면 이 함수는 기본적인 보장을 제공한다.

이번에는 예외 안전성 보장을 제공하는 함수로 만드는 일반적인 설계 전략을 알바좌. 이 전략은 ‘복사-후-맞바꾸기(copy-and-swap, CAS)’로 알려져 있다. 어떤 객체를 수정하고 싶으면, 객체의 사본을 만들어 놓고 그 사본을 수정한다. 그 후 필요한 동작이 전부 완료되면, 수정된 객체를 원본 객체와 맞바꾼다. 이 작업을 ‘예외를 던지지 않는’ 연산 내부에서 수행한다.

이 전략은 대개 진짜 객체의 모든 데이터를 별도의 구현 객체에 넣어두고, 그 구현 객체를 가리키는 포인터를 진짜 객체가 물고 있게 하는 식으로 구현한다. ‘pimpl 관용구’라고 불리는 구현 방법이다.

CAS 전략은 객체 상태를 ‘all-or-nothing’ 방식으로 유지하려는 경우에 좋다. 하지만 이 또한 강력한 예외 안전성을 갖도록 보장하지는 않는다. 다음 예제를 보자.

```cpp
void someFunc()
{
	... // 사본 만들기
	f1();
	f2();
	... // 변경된 상태로 바꾸어넣기
}
```

여기서 `f1` 과 `f2`에서 보장하는 예외 안전성이 강력하지 못하면, 위의 구조로는 `someFunc` 함수 역시 강력한 예외 안전성을 보장하기 어렵다. 그렇다고 `f1` 과 `f2`가 강력한 예외 안전성을 보장한다고 해도 사실 별로 나아지는 것은 없다. `f1`이 끝까지 실행되면 어차피 프로그램 상태는 변해있을 것이고, `f2`가 실행하다가 예외를 발생하면 이때 프로그램의 상태는 `someFunc`가 호출될 때의 상태와 아예 달라져 있을 것이기 때문이다.

여기서 불거지는 문제가 바로 함수의 부수효과(side effect)이다. 특히나 비지역 데이터에 대해 부수효과를 주는 함수는 강력한 보장을 제공하기가 무척이나 어렵다. 실용성이 확보될 때만 강력한 보장을 제공하는 데 힘쓰자. 이렇게만 하면, 기본적인 보장만 제공한다고 할 때 뭐라고 할 사람은 아무도 없다.

소프트웨어 시스템은 예외에 안전하거나 뚫려 있거나 둘 중 하나다. 일부만 예외 안전성을 갖춘 시스템 같은 것은 없다. 예외 안전성이 없는 함수가 한 개라도 쓰이고 있다면, 그 시스템은 전부가 예외에 안전하지 않은 시스템이다. 호출 즉시 자원이 누출되고 자료구조가 더러워지기 때문이다.

앞으로는 새로운 함수를 만들거나 기존의 코드를 고칠 때 ‘어떻게 하면 예외에 안전한 코드를 만들까’ 고민하는 버릇을 들이자. 시간은 계속 흐른다. 계속 배워가야 한다.

> 예외 안전성을 갖춘 함수는 실행 중 예외가 발생되더라도 자원을 누출시키지 않으며 자료구조를 더럽힌 채로 내버려 두지 않는다.
강력한 예외 안전성 보장은 CAS 방법을 써서 구현할 수 있지만, 강력한 보장이 모두 실용적인 것은 아니다.
어떤 함수가 제공하는 예외 안전성 보장의 강도는, 그 함수가 내부적으로 호출하는 함수들이 제공하는 가장 약한 보장을 넘지 못한다.