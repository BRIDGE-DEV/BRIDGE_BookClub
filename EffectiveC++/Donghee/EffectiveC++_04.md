## 항목4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

```cpp
int x;
```

int형 변수 하나를 선언해보자. 어떤 경우에는 x의 값이 0으로 확실히 초기화되지만, 또 어떤 경우에서는 그것이 보장되지 않는다.

C++의 객체/변수 초기화가 중구난방인 것은 아니다. 분명 규칙이 명확히 있다. C++의 C 부분만을 쓴다면 값이 초기화된다는 보장이 없다. 그러나 STL의 vector는 초기화된다는 보장을 갖게 된다. 이런 불균형을 해결하는 좋은 방법은 모든 객체를 사용하기 전 항상 초기화하는 것이다.

여기서 초기화와 대입을 헷갈리지 말자. 다음의 코드를 보자. 모두 대입을 하고 있다.

```cpp
class ABEntry{
public:
	ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones);
	
private:
	std::string theName;
	std::string theAddress;
	std::list<PhoneNumber> thePhones;
	int numTimesConsulted;
};

ABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)
{
	theName = name;
	theAddress = address;
	thePhones = phones;
	numTimesConsulted = 0;
	// 모두 초기화가 아니라 대입을 하고 있다.
}
```

C++의 규칙에 의하면 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전, 초기화되어야 한다고 명기되어 있다. 여기서 ABEntry의 데이터 멤버들은 초기화되고 있는 것이 아니라 대입되고 있는 것이다. 정확히 말하자면, 생성자에 진입하기도 전에 numTimesConsulted를 제외한 세 데이터 멤버가 기본 생성자에 의해 초기화되었다. numTimesConsulted는 기본제공 타입이기 때문에 초기화되었다는 보장이 없다. 올바르게 초기화할 수는 없을까?

```cpp
ABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)
: theName(name),
	theAddress(address),
	thePhones(phones),
	numTimesConsulted(0)
{}
```

멤버 초기화 리스트를 사용하면 된다. 이는 기본 생성자로 초기화 후 다시 대입하는 아까의 방식과 다르게 바로 인자로 초기화가 된다. 대부분 이렇게 복사 생성자를 한 번 호출해 초기화하는 쪽이 더 효율적이다.

또한 데이터 멤버를 기본 생성자로 초기화하고 싶을 때도 멤버 초기화 리스트를 사용하는 습관을 들이자. 이렇게 해야 어쩌다가 리스트에서 특정 멤버를 빼먹었을 때 ‘그 멤버가 초기화되지 않았을 수 있다’는 생각의 부담이 사라진다.

데이터 멤버가 상수거나, 참조자로 되어있다면 반드시 초기화되어야 한다. 이들은 대입 자체가 불가능하기 때문이다. 따라서 이 경우엔 초기화 리스트가 선택이 아니라 의무가 된다. 이렇게 여러 경우를 고려하며 초기화 리스트를 썼다가 안 썼다가 하기엔 너무 헷갈리니, 그냥 모두 쓰는 편이 낫다.

물론 생성자마다 초기화 리스트가 주렁주렁 달려있다면 다소 예쁘지 않게 보인다. 이런 경우엔 대입으로도 초기화가 가능한 데이터 멤버를 별도의 함수로 옮기는 것도 방법이 된다. 하지만 일반적인 경우만 따지면 초기화 리스트를 통한 진짜 멤버 초기화가 아무래도 좋다.

C++에서 클래스 데이터 멤버는 선언된 순서로 초기화된다. 아무리 멤버 초기화 리스트에서 데이터 멤버의 순서를 바꾸더라도, 초기화 순서는 그대로다. 순서가 바뀌면 혼동이 일어날 수 있으니, 초기화 리스트에 넣는 순서도 클래스에 선언된 순서와 동일하게 맞춰주자.

또한, 비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다. 이게 무슨 말일까? **비지역 정적 객체**와 **개별 번역 단위**가 뭔지 알아보자.

우선 정적 객체는 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 일컫는다.

- 전역 객체
- 네임스페이스 유효범위에서 정의된 객체
- 클래스 안에서 static으로 선언된 객체
- 함수 안에서 static으로 선언된 객체
- 파일 유효범위에서 static으로 정의된 객체

이 중 함수 안에 있는 정적 객체는 **지역 정적 객체**라고 하고, 나머지는 **비지역 정적 객체**라고 한다.

**번역 단위**는 프로그램을 컴파일할 때 독립적으로 번역될 수 있는 코드의 최소 단위를 의미한다. 보통 하나의 소스 파일이나 헤더 파일이 번역 단위가 된다. 여기서 그 파일이 #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다.

여기서 생기는 문제는 이렇다. 별도의 번역 단위에 있는, 즉 별도로 컴파일된 소스 파일이 두 개 이상 있을 때 각자의 비지역 정적 객체들의 초기화 순서는 어떻게 되는가? 만약 한 쪽의 정적 객체의 초기화가 다른 정적 객체를 사용한다면?

위에도 말했듯이 별개의 번역 단위에 있는 비지역 정적 객체들의 초기화 순서는 정해져 있지 않다. 이는 설계의 약간 변화를 줘서 해결할 수 있다. 바로 **싱글톤 패턴**이다. 비지역 정적 객체를 하나씩 맡는 함수를 준비하고, 이 안에 각 객체를 넣는 것이다. 이제 함수에서 정적 객체를 선언해주고, 그에 대한 참조자를 반환하게 하자. 이제 비지역 정적 객체가 아닌 **지역 정적 객체**가 되었다. **지역 정적 객체는 함수 호출 중에 객체의 정의에 최초로 닿았을 때 초기화된다.** 따라서 이 설계가 위의 문제를 해결할 수 있다.

이 참조자 반환 함수는 내부적으로 정적 객체를 쓰기 떄문에, 다중스레드 시스템에서는 동작에 장애가 생길 수도 있다. 초기화를 할 때 경합 조건(race condition)에 들어가면 골칫거리가 되기 때문이다. 이 해결책으로는 다중스레드를 본격적으로 들어가기 전, 참조자 반환 함수를 손수 한번씩 호출시켜줘 초기화하는 방법이 있다.

> 기본제공 타입의 객체는 직접 손으로 초기화하자.
> 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계하자. 참조자 반환 함수를 통해 비지역을 지역 정적 객체로 바꾸자.
> 생성자에서는 멤버 초기화 리스트를 이용해 초기화하자. 리스트의 멤버 나열 순서는 선언된 순서와 같게 하자.