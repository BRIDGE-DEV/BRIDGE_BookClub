# 챕터7: 템플릿과 일반화 프로그래밍

C++ 템플릿을 만들려고 했던 원래 동기는, 사용자가 타입에 관계없는 컨테이너를 만들어 사용할 때 타입 안전성을 부여할 수 있도록 하는 것이었다. 템플릿을 통해 원래 목적을 달성한 컨테이너는 그 자체만으로도 훌륭했지만, 템플릿의 응용 분야로 파생된 일반화 프로그래밍은 더 훌륭했다. C++ 템플릿을 사용하면 계산 가능한 어떤 값도 계산할 수 있다. 템플릿 기반 프로그래밍이란 것의 밑바닥에는 몇 개 되지 않는 핵심 아이디어가 자리하고 있다. 이들을 알아보는 것이 이번 장의 목표다.

## 항목 41: 템플릿 프로그래밍의 천릿길도 암시적 인터페이스와 컴파일 타임 다형성부터

객체 지향 프로그래밍의 세계를 회전시키는 축은 **명시적 인터페이스**와 **런타임 다형성**이다. 다음의 예시를 보자.

```cpp
class Widget {
public:
	Widget();
	virtual ~Widget();
	virtual std::size_t size() const;
	virtual void normalize();
	void swap(Widget& other);
	...
};

void doProcessing(Widget& w)
{
	if(w.size() > 10 && w != someNastytWidget) {
		Widget temp(w);
		temp.normalize();
		temp.swap(w);
	}
}
```

이 예제에서 `doProcessing` 함수의 인자 `w`를 보자. 이 `w`는 `Widget` 타입으로 선언되었기 때문에, `Widget` 의 인터페이스를 지원해야 한다. 이 인터페이스를 소스 코드에서 찾으면 이것이 어떤 형태인지를 확인할 수 있으므로, 이런 인터페이스는 **명시적 인터페이스**라 한다. 즉, 소스 코드에 명시적으로 드러나는 인터페이스를 일컫는다. 또한 `Widget`의 멤버 함수 중 몇 개는 가상 함수이므로, 이 가상 함수에 대한 호출은 **런타임 다형성**에 의해 이루어진다.

템플릿과 일반화 프로그래밍의 세계에는 뿌리부터 다른 부분이 있다. 여기서의 주인공은 **암시적 인터페이스**와 **컴파일 타임 다형성**이다. `doProcessing` 함수를 함수 템플릿으로 바꿔보자.

```cpp
template<typename T>
void doProcessing(T& w)
{
	if(w.size() > 10 && w != someNastytWidget) {
		T temp(w);
		temp.normalize();
		temp.swap(w);
	}
}
```

`w`가 지원해야 하는 인터페이스는 이 템플릿 안에서 `w`에 대해 실행되는 연산이 결정한다. `T`는 `size`, `normalize`, `swap` 멤버 함수를 지원하고, 복사 생성자도 지원해야 하고, 부등 연산도 지원해야 한다. 결국, 이 템플릿이 제대로 컴파일되려면 몇 개의 표현식이 유효해야 한다. 이 표현식들은 `T`가 지원해야 하는 **암시적 인터페이스**이다. 

`w`가 수반되는 함수 호출이 일어날 때, 해당 호출을 성공시키기 위해 템플릿의 인스턴스화가 일어난다. 이러한 인스턴스화가 일어나는 시점은 컴파일 도중이다. 인스턴스화를 진행한는 함수 템플릿에 어떤 템플릿 매개변수가 들어가냐에 따라 호출되는 함수가 달라지기 때문에, 이것을 **컴파일 타임 다형성**이라고 한다. 이것은 오버로드된 함수 중 지금 호출할 것을 골라내는 과정과 가상 함수 호출의 동적 바인딩의 차이점과도 흡사하다.

명시적 인터페이스는 대개 함수 시그너치로 이뤄진다. 시그니처는 함수의 이름, 매개변수 타입, 반환 타입 등을 통틀어 부르는 용어이다. 반면 암시적 인터페이스는 사뭇 다르다. 암시적 인터페이스를 이루는 요소는 유효 표현식이다.

```cpp
template<typename T>
void doProcessing(T& w)
{
	if(w.size() > 10 && w != someNastytWidget) {
	...
```

여기서 `T`에서 제공될 암시적 인터페이스에는 다음과 같은 제약이 걸릴 것이다.

- 정수 계열의 값을 반환하고 이름이 `size`인 함수를 지원해야 한다.
- `T` 타입의 객체 둘을 비교하는 `operator!=` 함수를 지원해야 한다.

실제로는 연산자 오버로딩의 가능성이 있기 때문에 `T`는 위의 두 가지 제약 중 어떤 것도 만족시킬 필요가 없다. `T`가 `size` 멤버 함수를 지원해야 하는 것은 맞다. 하지만 그저 어떤 `X` 타입의 객체와 `int`가 함께 호출될 수 있는 `operator>` 가 성립될 수 있도록, `X` 타입의 객체만 반환하면 임무 종료이다. 또한, `operator>` 함수는 반드시 `X` 타입의 매개변수를 받아들일 이유가 없다. 이 함수가 `Y` 타입의 매개변수를 받도록 정의되어 있고, `X` 타입에서 `Y` 타입으로 암시적인 변환만 가능하다면 되기 때문이다.

같은 이유로 두 번째 제약도 필수 요구사항이 아니다. `operator!=` 함수가 `X`타입의 객체 하나와 `Y` 타입의 객체 하나를 받아들인다고 하면 이 부분은 별 걸림돌 없이 넘어갈 수 있기 때문이다. `T`가 `X`로 변환될 수 있으며 `someNastyWidget`의 타입이 `Y`로 변환되는 것이 가능하기만 하면 `operator!=` 함수의 호출은 유효 호출로 간주될 것이다.

나머지 함수들, 즉 복사 생성자, `normalize` 그리고 `swap` 함수에 대한 호출도 `T` 타입의 객체에 대해 유효해야 한다.

클래스에서 제공하는 명시적 인터페이스와 호환되지 않는 방법으로 그 클래스의 객체를 쓸 수 없듯이, 어떤 템플릿 안에서 어떤 객체를 쓰려고 할 때 그 템플릿에서 요구하는 암시적 인터페이스를 그 객체가 지원하지 않으면 사용이 불가하다. (컴파일이 되지 않는다.)

> 클래스 및 템플릿은 모두 인터페이스와 다형성을 지원한다.
클래스의 경우, 인터페이스는 명시적이며 함수의 시그니처를 중심으로 구성된다. 다형성은 프로그램 실행 중 가상 함수를 통해 나타난다.
템플릿 매개변수의 경우, 인터페이스는 암시적이며 유효 표현식에 기반을 두어 구성된다. 다형성은 컴파일 중에 템플릿 인스턴스화와 함수 오버로딩 모호성 해결을 통해 나타난다.