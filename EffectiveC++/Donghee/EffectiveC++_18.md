# 챕터4: 설계 및 선언

어떻게 하면 좋은 C++ 인터페이스를 설계하고 선언할 수 있을까?

## 항목 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

C++에서는 발에 치이는 것이 인터페이스다. 함수도 인터페이스, 클래스도 인터페이스, 템플릿 또한 인터페이스다.

이상적으로는, 어떤 인터페이스를 어떻게 써 봤는데 결과 코드가 사용자가 생각한 대로 동작하지 않는다면 그 코드는 컴파일되지 않아야 맞다. 거꾸로 생각해서, 어떤 코드가 컴파일된다면 그 코드는 사용자가 원하는 대로 동작해야 할 것이다.

‘제대로 쓰기에 쉽고 엉터리로 쓰기에 어려운’ 인터페이스를 개발하려면 우선 사용자가 저지를 만한 실수의 종류를 머리에 넣어두어야 한다. 지금 날짜를 나타내는 클래스에 넣을 생성자를 설계하고 있다고 가정하자.

```cpp
class Date {
public:
	Date(int month, int day, int year);
	...
};
```

여기에는 오류 구멍이 적어도 두 개 있다. 예를 들면, 매개변수의 전달 순서가 잘못될 여지가 있다.

```cpp
Date d1(30, 3, 1995); // 30월 3일
Date d2(3, 40, 1995); // 3월 40일
```

이런 경우엔 새로운 타입을 들여와 인터페이스를 강화하면 상당수의 실수를 막을 수 있다. 일, 월, 연을 구분하는 간단한 래퍼 타입을 만들자.

```cpp
struct Day {
	explicit Day(int d) : val(d) {}
	int val;
};
struct Month {
	explicit Month(int m) : val(m) {}
	int val;
};
struct Year {
	explicit Year(int y) : val(y) {}
	int val;
};

class Date {
public:
	Date(const Month& m, const Day& d, const Year& y);
	...
};
Date d(Month(3), Day(30), Year(1995));
```

물론, Day 및 Month, Year에 데이터를 이것저것 넣어 온전한 클래스로 만들면 구조체보다는 낫다. 하지만 이렇게 타입을 적절히 새로 준비해 두기만 해도 인터페이스 사용 에러를 막는 데엔 효과가 있다.

다른 방법으로는 제약을 부여하여 그 타입을 통해 할 수 있는 일들을 묶어 버리는 방법이 있다. 제약 부여 방법으로 아주 흔히 쓰이는 예가 **‘const 붙이기’**이다.

```cpp
if (a * b = c) ... // operator*의 반환 타입을 const로 한정함으로써 에러 표시
```

여기서 또 하나의 일반적인 지침이 나온다. ‘그렇게 하지 않을 이유가 없다면 사용자 정의 타입은 기본제공 타입처럼 동작하게 만들자’이다. 그러니까, int와 굳이 다른 길을 걸어갈 이유가 없다면 이를 따라야 한다. 아리송하면, int의 동작 원리대로 만들자.

쓸데없이 어긋나는 동작을 피하는 실질적 이유는 일관성 인터페이스를 제공하기 위해서다. 일관성만큼 똑 부러지는 것이 별로 없으며, 더 나쁘게 만들어 버리는 요인 중에 비일관성을 따라오는 것이 거의 없다. 한 예로, 모든 STL 컨테이너는 size라는 멤버 함수를 개방해 놓고 있다.

사용자 쪽에서 뭔가를 외워야 제대로 쓸 수 있는 인터페이스는 잘못 쓰기 쉽다. 언제라도 잊어버릴 수 있기 때문이다. 예를 들어 항목 13에 나온 바 있는 팩토리 함수를 보자.

```cpp
Investment* createInvestment(); // 인자 생략
```

이 함수를 사용하면, 자원 누출을 피하기 위해 createInvestment에서 얻어낸 포인터를 나중에라도 삭제해야 한다. 이를 깜빡하는 걸 방지하기 위해, tr1::shared_ptr 등의 스마트 포인터를 사용하기도 한다. 하지만, 사용해야 한다는 사실도 사용자가 잊어버리면 어떻게 할 것인가? 애초부터 팩토리 함수가 스마트 포인터를 반환하게 만들자.

```cpp
std::tr1::shared_ptr<Investment> createInvestment();
```

이렇게 해 두면, 이 함수의 반환 값은 tr1::shared_ptr에 넣어 둘 수 밖에 없다. 또한 이 객체를 삭제하는 것을 깜빡하고 넘어가는 불상사도 생기지 않는다.

tr1::shared_ptr에는 엄청 좋은 특징이 하나 있다. 포인터별 삭제자를 자동으로 씀으로써 사용자가 저지를 수 있는 또 하나의 잘못, **교차 DLL 문제**를 미연에 없애 준다는 점이다. 이 문제는, 객체 생성 시에 어떤 동적 링크 라이브러리(DLL)의 new를 썼는데 그 객체를 삭제할 때는 이전의 DLL과 다른 DLL에 있는 delete를 썼을 경우에 발생한다. tr1::shared_ptr은 이 문제를 해결할 수 있다. 이 클래스의 기본 삭제자는 tr1::shared_ptr이 생성된 DLL과 동일한 DLL에서 delete를 사용하도록 만들어져 있기 때문이다. 즉, tr1::shared_ptr은 다른 DLL들 사이에 이리저리 넘겨지더라도 교차 DLL 문제를 걱정하지 않아도 된다는 뜻이다.

auto_ptr의 경우, 소멸될 때 그 포인터를 소유하고 있는 DLL에서 delete가 실행된다. 따라서, 할당한 DLL과 다른 DLL에서 delete가 실행돼 문제가 생길 수도 있는 것이다. 반면 shared_ptr은 포인터가 할당되면 그 DLL에서의 delete 연산자로 삭제자가 자동 지정된다.

https://stackoverflow.com/questions/345003/is-it-safe-to-use-stl-tr1-shared-ptrs-between-modules-exes-and-dlls

이 클래스를 쓰면 원시 포인터보다 크고 느리며, 내부 관리용 동적 메모리까지 추가로 매달려있다. 하지만 이런 것들 때문에 프로그램에서 런타임 비용이 눈에 띄게 늘어나는 경우는 거의 없다. 반면 사용자 실수가 눈에 띄게 줄어드는 경우는 충분히 많다.

> 좋은 인터페이스는 제대로 쓰기에 쉬우며 엉터리로 쓰기에 어렵다.
인터페이스의 올바른 사용을 이끄는 방법에는 인터페이스 사이의 일관성 잡아주기, 기본제공 타입과의 동적 호환성 유지하기가 있다.
사용자 실수를 방지하는 방법에는 새로운 타입 만들기, 타입에 대한 연산 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있다.
tr1::shared_ptr은 사용자 정의 삭제자를 지원한다. 이 때문에 교차 DLL 문제를 막아 주며, 뮤텍스를 자동 잠금 해제하는 데 사용 가능하다.