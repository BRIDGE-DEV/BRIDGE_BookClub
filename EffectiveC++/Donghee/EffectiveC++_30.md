# 챕터5: 구현

## 항목 30: 인라인 함수는 미주알고주알 따져서 이해해 두자

인라인 함수는 함수처럼 보이고, 함수처럼 동작하고, 매크로보다 훨씬 안전하고 쓰기 좋다. 인라인 함수에는 이점이 하나 더 있다. 대체적으로 컴파일러 최적화는 함수 호출이 없는 코드가 연속적으로 이어지는 구간에 적용되도록 설계되어 있다. 따라서 인라인 함수를 사용하면 컴파일러가 함수 본문에 대해 문맥별 최적화를 걸기가 용이해지는 점이다.

인라인 함수의 아이디어는 함수 호출문을 그 함수의 본문으로 바꿔치기 하는 것이다. 따라서 메모리가 제한된 컴퓨터에서 아무 생각 없이 인라인을 남발했다가는 프로그램 크기가 그 기계에서 쓸 수 있는 공간을 넘어버릴 수도 있다. 가상 메모리를 쓰는 환경일지라도 인라인 함수로 인해 부풀려진 코드는 성능의 걸림돌이 된다. 페이징 횟수가 늘어나고, 명령어 캐시 적중률이 떨어질 가능성도 높아진다.

반대의 경우도 있다. 본문 길이가 굉장히 짧은 인라인 함수를 사용하면, 함수 본문에 대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어지는 코드보다 작아질 수도 있다. 이 경우에는 목적 코드의 크기도 작아지며 명령어 캐시 적중률도 높아진다.

`inline`은 컴파일에 대해 ‘요청’을 하는 것이지 ‘명령’을 하는 것이 아니다. 이 요청은 `inline`을 붙이지 않고도 눈치껏 되는 경우도 있고, 명시적으로 할 수도 있다. 암시적 방법은 클래스 정의 안에 함수를 바로 정의해 넣으면 된다.

```cpp
class Person {
public:
	...
	int age() const { return theAge; } // 암시적 인라인 요청
	...
private:
	int theAge;
};
```

프렌드 함수도 클래스 내부에서 정의가 될 수 있다는 것도 참고하자.

인라인 함수를 선언하는 명시적 방법은 함수 정의 앞에 `inline` 키워드를 붙이는 것이다. 한 예로, 표준 라이브러리의 `max` 템플릿이 있다.

```cpp
template<typename T>
inline const T& std::max(const T& a, const T& b) { return a < b ? b : a; }
```

`max` 가 템플릿이라는 점 때문에 ‘인라인 함수와 템플릿은 대개 헤더 파일 안에 정의한다’라는 이야기도 나온다. 물론 이것이 ‘함수 템플릿은 반드시 인라인 함수여야 한다’라는 이야기는 아니다.

물론 둘다 헤더 파일에 들어있는 것이 대체적으로 맞다. 인라인은 대부분의 빌드 환경에서 컴파일 도중에 수행된다. 템플릿 역시, 사용되는 부분에서 해당 템플릿을 인스턴스로 만들려면 그것이 어떻게 생겼는지를 컴파일러가 알아야하기 때문에 헤더 파일에 들어 있는 것이 대부분이다. 그런데 이와는 별개로, 둘은 관련이 없다.

`inline`은 분명 비용을 동반하는 동작이고, 컴파일러 선에서 무시할 수 있는 요청이다. 대부분 컴파일러의 경우 아무리 인라인 함수로 선언되어 있어도 자신이 보기에 복잡한 함수는 절대로 인라인 확장의 대상에 넣지 않는다. 루프가 들어있거나 재귀 함수인 경우가 예시이다.

또한 정말 간단한 함수라 할지라도 가상 함수 호출 같은 것은 절대로 인라인해 주지 않는다. `virtual`의 의미는 ‘어떤 함수를 호출할지 결정을 런타임에 한다.’이고, `inline`의 의미는 ‘함수 호출 위치에 호출된 함수를 끼워 넣는 작업을 프로그램 실행 전에 한다.’라는 것이니 이미 말이 안되는 것이다.

결론은 인라인 함수가 실제로 인라인되느냐 안 되느냐의 여부는 전적으로 빌드 환경, 그 중에서도 컴파일러에 달렸다. 무조건 인라인 함수일 듯한 인라인 조건을 갖추었는데도, 컴파일러가 인라인 함수의 본문에 대해 코드를 만드는 경우가 있다. 예를 들면 인라인 함수의 주소를 취하는 경우엔, 이 코드를 위해 아웃라인 함수 본문을 만들 수 밖엔 없다.

```cpp
inline void f() {...}
void (*pf)() = f;
...
f(); // 인라인
pf(); // 인라인 X. 함수 포인터를 이용한 호출
```

인라인되지 않는 인라인 함수는 함수 포인터 이외에도 발생할 수 있다. 인라인으로 선언된 생성자/소멸자에 대해 컴파일러는 아웃라인 함수 본문을 만들 수 있다. 생성자/소멸자는 인라인하기에 좋지 않은 함수이다. 예를 들어 한 `Base` 클래스 객체에 5개의 `string` 객체가 있다고 해보자. 이 `string` 객체들의 생성자도 인라인되면, `Base` 객체의 생성자가 호출될 때 똑같은 함수 본문이 다섯개가 되는 것이다. 소멸자의 경우에도 똑같다.

어떤 함수를 인라인으로 선언해야 하고 어떤 것을 선언하지 말아야 하는지에 대한 전략은 간단하다. 우선, 아무것도 인라인하지 말자. 아니면 꼭 인라인해야 하는 함수 혹은 정말 단순한 함수에 한해서만 인라인 함수로 선언하는 것으로 시작하자.

> 함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어두자. 이렇게하면 디버깅 및 라이브러리의 바이너리 업그레이드가 용이해지고, 코드 부풀림 현상 최소화, 프로그램의 속력이 더 빨라질 수 있는 여지가 많아진다.
함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 생각해 이들을 `inline`으로 선언하면 안 된다.