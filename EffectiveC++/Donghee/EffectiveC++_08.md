# 챕터2: 생성자, 소멸자 및 대입 연산자

## 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

소멸자로부터 예외가 터져 나가는 경우를  C++ 언어가 막는 것은 아니다. 하지만 분명히 우리가 막을 필요는 있다. 다음 예제를 보자.

```cpp
class Widget {
public:
	...
	~Widget() { ... }
};

void doSomething()
{
	std::vector<Widget> v;
	...
}
```

v가 소멸될 때, v의 원소들로 들어있는 Widget 객체들을 소멸시킬 책임은 v에게 있다. 이때 v의 Widget 원소들이 10개 있다고 가정하자. v가 소멸되어, Widget 객체들을 소멸시키다가 첫 번째 객체 소멸에서 예외가 발생되었다고 해보자. 나머지 아홉 개의 객체이라도 모두 소멸되어야 하기 때문에, v는 나머지 소멸자들을 호출할 것이다. 그런데 이 과정에서 또 예외가 발생했다고 해보자. 이런 상황에서는 활성화된 예외가 동시에 두 개나 되고, C++의 입장에서는 감당하기에 버겁다.

다른 표준 라이브러리 컨테이너나 TR1의 컨테이너, 배열을 쓰더라도 결과는 마찬가지일 것이다. 중요한 것은 **C++가 예외를 내보내는 소멸자를 좋아하지 않는다**는 것이다.

예외가 나올 수 있는 코드를 소멸자에 넣어야 할 사람이 우리라면 어떻게 해야할까? 다음 예제를 보자.

```cpp
class DBConnection {
public:
	...
	static DBConnection create();
	
	void close();
};

class DBConn {
public:
	...
	~DBConn() { db.close(); }
private:
	DBConnection db;
};
```

DBConnection 클래스는 데이터베이스 연결을 나타내는 클래스이다. 이는 소멸되기 전에 꼭 close 함수를 통해 연결을 종료해야한다. DBConn 클래스는 DBConnection 객체를 담는 클래스로, 소멸자에서 DBConnection 객체의 close를 호출시켜 연결의 종료를 보장해준다.

이 상황의 close 함수에서 예외가 발생했다고 가정하자. 이 얘기는 즉 소멸자에서 예외가 발생할 수 있다는 얘기인데, 우리는 위에서 얘기했던 것처럼 이 상황을 피해야한다. 이를 해결할 방법 두 가지를 알아보자.

- close에서 예외가 발생하면 프로그램을 바로 끝낸다.
    
    ```cpp
    	DBConn::~DBConn() 
    	{
    		try { db.close(); }
    		catch (...) {
    			// 로그 작성
    			std::abort(); // 강제 종료
    		}
    	}
    ```
    
    괜히 소멸자에서 생긴 예외를 흘려 내보냈다가 정의되지 않은 동작까지 이를 수 있다면, 바로 끝내는 것은 나름의 장점이 있다.
    
- close를 호출한 곳에서 예외를 삼켜 버린다.
    
    ```cpp
    	DBConn::~DBConn() 
    	{
    		try { db.close(); }
    		catch (...) {
    			// 로그 작성
    		}
    	}
    ```
    
    대부분의 경우에서 예외 삼키기는 좋은 방법이 아니다. 예외에서 가장 중요한 정보인 **무엇이 잘못됐는지**에 대한 부분이 묻혀 버리기 때문이다.
    

어느 쪽을 택하든 close가 최초로 예외를 던지게 된 요인에 대해 프로그램이 할 수 있는 조치가 없기 때문에, 썩 좋은 방법은 아닌 듯 보인다.

조금 더 나은 방법을 생각해보자. DBConn에서도 close 함수를 제공해, 사용자가 직접 close에 대한 예외처리가 가능하게 만들자. 물론 close가 되지 않은 상태로 소멸한다면, 소멸자에서 close 함수를 호출시켜 최소한의 보장은 해주자.

```cpp
class DBConn {
public:
	...
	void close()
	{
		db.close();
		closed = true;
	}
	
	~DBConn() 
	{
		// 사용자가 close를 호출시키지 않았다면 소멸자에서 호출
		if (!closed)
		try {
			db.close();
		}
		catch (...) {
			// 로그 작성
			...
		}
	}
	
private:
	DBConnection db;
	bool closed;
};
```

위의 코드는 사용자에게 직접 close를 호출할 권한을 주고, 덕분에 소멸자가 아닌 다른 곳에서 예외처리를 진행할 수 있다. 이것마저 없었다면 사용자는 예외를 대처할 기회조차 없는 것이다.

> 소멸자에서는 예외가 빠져나가면 안 된다. 만약 그럴 가능성이 있다면, 예외 삼키기 혹은 강제 종료를 해야한다.
> 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 한다면, 해당 연산의 함수는 반드시 소멸자가 아닌 보통의 함수여야 한다.