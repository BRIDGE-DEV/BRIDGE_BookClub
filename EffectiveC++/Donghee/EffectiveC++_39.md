# 챕터6: 상속, 그리고 객체 지향 설계

## 항목 39: private 상속은 심사숙고해서 구사하자

C++는 public 상속을 is-a 관계로 나타낸다. 반면 private 상속은 분명히 is-a를 뜻하지 않는다. public 상속과 대조적으로, 클래스 사이의 상속 관계가 private이면 컴파일러는 일반적으로 파생 클래스 객체를 기본 클래스 객체로 변환하지 않는다. 또한, 기본 클래스로부터 물려받은 멤버는 파생 클래스에서 모조리 private 멤버가 된다.

private 상속의 의미는 is-implemented-in-terms-of이다. `B` 클래스와 이를 private 상속한 `D` 클래스가 있다고 해보자. 이때 `B` 클래스로부터 private 상속을 통해 `D` 클래스를 파생시킨 것은, `B` 클래스에서 쓸 수 있는 기능들 몇 개를 활용할 목적으로 한 행동이지, `B` 타입과 `D` 타입의 객체 사이에 어떤 개념적 관계가 있어서 한 행동이 아니다. 즉, private 상속의 의미는 ‘구현만 물려받을 수 있다.’라는 뜻이다. private 상속은 소프트웨어 설계 도중에는 아무런 의미도 갖지 않으며, 단지 소프트웨어 구현 중에만 의미를 가질 뿐이다.

하지만 객체 합성도 같은 의미를 가진다고 했다. 어떤 기준으로 둘의 사용 시점을 분간해야 할까? 답은 간단하다. 할 수 있으면 객체 합성을 사용하고, 꼭 해야 하면 private 상속을 사용하자. ‘꼭 해야 하는 시점’은 비공개 멤버를 접근할 때 혹은 가상 함수를 재정의할 경우이다.

현실적으로는 private 상속 대신에 public 상속에 객체 합성 조합이 더 자주 쓰이긴 한다. 파생 클래스에서 합성 대상을 접근 못하게 막는 것이 유리하고, 컴파일 의존성 최소화가 쉽기 때문이다.

하지만 private 상속이 정말 필요한 경우도 있다. 클래스에 공백 클래스 객체를 포함하는 경우다.

```cpp
class Empty {};
class HoldsAnInt {
private:
	int x;
	Empty e;
};
```

이 경우에는 대부분의 컴파일러에서 `sizeof(Empty)`의 값이 1로 나온다. 크기가 0인 독립 구조의 객체가 생기는 것을 언어 차원에서 금지하기 때문이다. 따라서 컴파일러는 슬그머니 `char` 한 개를 끼워넣는다. 하지만 여기서 바이트 패딩 과정이 추가되면, `char` 한 개가 아니라 사실상 `int` 한 개 만큼의 크기를 차지하는 부작용이 발생한다.

이때 private 상속을 진행해, 독립 구조의 객체로 만들지 않는다면 크기를 절약할 수 있다.

```cpp
class Empty {};
class HoldsAnInt: private Empty {
private:
	int x;
};
```

이제는 `sizeof(HoldsAnInt) == sizeof(int)`이다. 이 공간 절약 기법은 **공백 기본 클래스 최적화(EBO)**로 알려져 있다. EBO는 일반적으로 단일 상속하에서만 적용된다.

“공백” 클래스는 사실 진짜로 텅 빈 것은 아니다. 비정적 데이터 멤버는 안 갖고 있지만, `typedef` 혹은 `enum` , 정적 데이터 멤버는 물론이고 비가상 함수까지 갖는 경우가 비일비재하다. 이런 경우에 private 상속을 통한 **EBO**가 도움이 된다.

하지만 이런 경우는 정말 드물다. is-implemented-in-terms-of 관계는 객체 합성이 이해하기에 훨씬 낫다. 따라서 할 수 있다면 객체 합성을 쓰되, 두 클래스 사이의 관계를 나타낼 가장 좋은 방법이 private 상속이라는 결론이 나면 이것을 사용하자.

> private 상속의 의미는 is-implemented-in-terms-of이다. 파생 클래스 쪽에서 기본 클래스의 protected 멤버에 접근해야 할 경우, 상속받은 가상 함수를 재정의해야 할 경우에는 private 상속이 나름대로 의미가 있다.
객체 합성과 달리, private 상속은 공백 기본 클래스 최적화(EBO)를 활성화시킬 수 있다.