# 챕터6: 상속, 그리고 객체 지향 설계

## 항목 33: 상속된 이름을 숨기는 일은 피하자

이번 항목은 상속보다는 유효범위(scope)와 관련이 크다. 아래 코드를 보자.

```cpp
int x;
void someFunc()
{
	double x;
	std::cin >> x;
}
```

`someFunc`에서 입력받는 `x`는 전역 변수 `x`가 아니라 ‘지역 변수’ `x` 이다. 이유는 안쪽 유효범위에 있는 이름이 바깥쪽 유효범위에 있는 이름을 가리기 때문이다. 우선 컴파일러가 `someFunc`의 유효범위 안에서 `x`라는 이름을 만나면, 그 컴파일러는 자신이 처리하고 있는 유효범위, 즉 지역 유효범위를 뒤져서 같은 이름을 가진 것이 있는지 알아본다. 지금의 경우에는 `x`라는 이름이 바로 있기 때문에, 이외의 유효범위는 뒤지지 않는다.

C++의 이름 가리기 규칙은 이렇게 이름을 가린다. 전역 변수 `x` 의 타입은 int지만, 타입과는 관계없이 이름이 같은 double형의 지역 변수 `x`가 이를 가리는 것이다.

상속으로 들어가보자. 기본 클래스에 속해 있는 것들(멤버 함수, 데이터 멤버, 혹은 typedef)을 파생 클래스 멤버 함수 안에서 참조하는 문장이 있으면 컴파일러는 이 참조 대상을 바로 찾아낸다. 이렇게 동작하는 이유는 파생 클래스의 유효범위가 기본 클래스의 유효범위 안에 중첩되어 있기 때문이다. 마치 위의 코드처럼 유효범위가 감싸져 있는 구조라고 생각하면 된다. 다음의 예제를 보자.

```cpp
class Base {
private:
	int x;
public:
	virtual void mf1() = 0;
	virtual void mf2();
	void mf3();
	...
};
class Derived : public Base {
public:
	virtual void mf1();
	void mf4();
	...
}
```

위 코드에서 `mf4` 함수가 아래처럼 구현되어있다고 해보자.

```cpp
void Derived::mf4()
{
	...
	mf2();
	...
}
```

컴파일러는 `mf4` 함수를 읽다가, `mf2` 라는 이름을 발견하고 어떤 것에 대한 이름인지 파악한다. 우선 지역 유효범위를 찾았는데, 없으므로 `Derived`를 감싸는 다음의 유효범위인 `Base` 유효범위를 뒤진다. 여기서 `mf2` 를 찾고 탐색을 종료한다. 만약 `Base` 안에도 `mf2`가 없으면 계속 탐색이 진행되어서 `Base`를 둘러싸는 네임스페이스, 그 이후엔 전역 유효범위까지 간다.

이제 앞의 예제에서 오버로드를 여러개 추가한 버전을 만들어보자.

```cpp
class Base {
private:
	int x;
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
	virtual void mf2();
	void mf3();
	void mf3(double);
	...
};
class Derived : public Base {
public:
	virtual void mf1();
	void mf3();
	void mf4();
	...
}
```

기본 클래스에 있는 함수들 중 `mf1`와 `mf3`이라는 이름이 붙은 것은, 모두 파생 클래스의 `mf1`과 `mf3`에 의해 가려진다. 함수들이 가상 함수인지 비가상 함수인지, 매개변수 타입이 다른지의 여부와는 상관이 없다. 이는 어떤 라이브러리 혹은 응용프로그램 프레임워크를 이용해 파생 클래스를 하나 만들 때, 멀리 떨어져 있는 기본 클래스로부터 오버로드 버전을 상속시키는 경우를 막기 위해서다.

```cpp
Derived d;
int x;
...
d.mf1();
d.mf1(x); // 오류
d.mf3();
d.mf3(x); // 오류
```

가려진 이름은 `using` 선언을 통해 끄집어낼 수 있다. 즉, 어떤 기본 클래스로부터 상속을 받으려고 하는데, 오버로드된 함수가 그 클래스에 들어 있고 이 함수들 중 몇 개만 재정의하고 싶다면, 각 이름에 대해 using 선언을 붙여줘야 한다.

만약 `Dervied`가 `Base`로부터 private 상속이 이루어졌다고 가정하자. 이 경우에는 using 선언을 내릴 시에 그 이름에 해당되는 것들이 모두 파생 클래스로 내려가 버린다. 따라서 using 선언으로 해결할 수 없고, ‘전달 함수’라는 것을 만들어 놓으면 된다.

```cpp
class Base {
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
	...
};

class Derived: private Base {
public:
	virtual void mf1() // 전달 함수
	{ Base::mf1(); }
	...
};
```

> 파생 클래스의 이름은 기본 클래스의 이름을 가린다. public 상속에는 이런 이름 가림 현상이 바람직하지 않다.
가려진 이름을 다시 볼 수 있게 하는 방법으로, using 선언 혹은 전달 함수를 쓸 수 있다.