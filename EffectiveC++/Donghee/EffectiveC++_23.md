# 챕터4: 설계 및 선언

## 항목 23: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

웹브라우저를 나타내는 클래스가 있다고 해보자.

```cpp
class WebBrowser {
public:
	...
	void clearCache();
	void clearHistory();
	void removeCookies();
	void clearEverything(); // clearCache, clearHistory, removeCookies 한번에 호출
	...
};
```

여기서 clearEverything을 멤버 함수가 아니라 비멤버 함수로 제공하는 경우도 있을 것이다.

```cpp
void clearBrowser(WebBrowser& wb)
{
	wb.clearCache();
	wb.clearHistory();
	wb.removeCookies();
}
```

객체 지향 법칙에 관련된 이야기를 찾아보면 데이터와 그 데이터를 기반으로 동작하는 함수는 한 데 묶여 있어야 하며, 멤버 함수가 더 낫다고들 한다. 하지만 그 이야기는 틀렸다.

멤버 버전인 clearEverything을 보자. 비멤버 버전인 clearBrowser보다 캡슐화 정도에서 형편없다. 제대로 왜 비멤버 방법이 멤버 함수보다 여러모로 나은지 알아보자.

캡슐화부터 시작해보자. 어떤 것을 캡슐화하면, 우선 외부에서 이것을 볼 수 없게 된다. 밖에서 볼 수 있는 것들이 줄어들면, 그것들을 바꿀 때 필요한 유연성이 커진다. 쉽게 말해, 이미 있는 코드를 바꾸더라도 제한된 사용자들밖에 영향을 주지 않는 융통성을 확보할 수 있다는 뜻이다. 반대로, 어떤 데이터를 접근하는 함수가 많으면 그 데이터의 캡슐화 정도는 낮다는 이야기이다.

똑같은 기능을 제공하는데 멤버 함수를 쓸 것이냐, 비멤버 비프렌드 함수를 쓸 것이냐를 다시 생각해보자. 멤버 함수는 그 클래스의 private 멤버를 모두 접근할 수 있다. 반면 비멤버 비프렌드 함수는 아무것도 건드릴 수 없다. 캡슐화 정도는 당연히 후자가 높은 것이다.

주의해야 할 부분이 두 가지 있다. 첫째, 이 이야기는 비멤버 비프렌드 함수에만 적용된다. 프렌드 함수는 private 멤버에 대한 접근권한이 클래스 멤버 함수가 가진 접근권한과 똑같기 때문에 캡슐화 정도가 차이가 없어진다.

두 번째, ‘함수는 어떤 클래스의 비멤버가 되어야 한다’라는 주장이 ‘그 함수는 다른 클래스의 멤버가 될 수 없다’라는 의미는 아니다. clearBrowser 함수를 다른 유틸리티 클래스의 정적 멤버 함수로 만들어도 된다는 얘기다. 어쨌든 WebBrowse 클래스의 멤버가 아니기만 하면 된다.

C++로는 더 자연스러운 방법을 구사할 수 있다. clearBrowser를 비멤버 함수로 두되, 클래스와 같은 네임스페이스 안에 두는 것이다.

```cpp
namespace WebBrowserStuff {
	class WebBrowser {...};
	void clearBrowser(WebBrowser& wb);
}
```

네임 스페이스는 클래스와 달리 여러 개의 소스 파일에 나뉘어 흩어질 수 있다. 웬만한 사용자라면 편의 함수 중 몇 개만 알고 있거나 관심을 둘 것이다. 따라서 우리는 특정 관련 기능들을 헤더를 나누어 선언할 수 있다.

표준 C++ 라이브러리가 이러한 구조로 구성되어 있다. std 네임스페이스에 속한 모든 것들이 한 통으로 섞여있지 않고, 몇 개의 기능과 관련된 함수들이 수십 개의 헤더에 흩어져 선언되어 있다. 결국 사용자는 필요한 헤더만 #include 하게 되고, 이렇게 하면 사용자가 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려할 수 있게 되는 것이다. 반면 클래스 멤버 함수로 오게 되면 이런 식으로 기능을 쪼개는 것 자체가 불가능하다.

> 멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰자. 캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어난다.