# Item30. 인라인 함수는 미주알고주알 따져서 이해해 두자
인라인 함수의 이점
+ 함수처럼 보이고 함수처럼 동작
+ 매크로보다 훨씬 안전
+ 오버헤드 걱정 없음
+ 컴파일러가 함수 본문에 대해 문맥별 최적화를 걸기가 용이(컴파일러 최적화는 함수 호출이 없는 코드가 연속적으로 이어지는 구간에 적용되도록 설계됨)

인라인 함수의 단점
+ 함수의 본문을 바꿔치기하는 거라 목적 코드의 크기가 증가한다. 메모리가 제한된 컴퓨터에서 남발시에 메모리 초과 발생이 될 수도 있다.
+ 페이징 횟수가 늘어나고, 명령어 캐시 적중률이 떨어질 가능성도 높다.

반대의 경우도 있는데 본문 길이가 굉장히 짧은 인라인 함수를 사용하면, 함수 본문에 대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어지는 코드보다 작아질 수도 있다. 이런 경우 목적 코드의 크기도 작아지며 명령어 캐시 적중률도 높아진다.

inline은 컴파일러에 대해 '요청'을 하는 것이지, '명령'이 아니다. 이 요청은 inline을 붙이지 않아도 그냥 눈치껏 되는 경우도 있고 명시적으로 할 수도 있다. 우선 암시적인 방법은 클래스 정의 안에 함수를 바로 정의해 넣으면 컴파일러는 그 함수를 인라인 함수 후보로 찍는다.
```cpp
class Person {
public:
	int age() const {return theAge;}  //암시적인 인라인 요청
private:
	int theAge;	
};
```

인라인 함수를 선언하는 명시적 방법은 함수 정의 앞에 inline 키워드를 붙이는 것이다.
```cpp
template<typename T>
inline const T& std::max(const T& a, const T& b)  //명시적 인라인 요청
{return a < b ? b : a;}
```

인라인 함수는 대체적으로 헤더 파일에 들어 있어야 하는 게 맞다. 왜냐하면 대부분의 빌드 환경에서 인라인을 컴파일 도중에 수행하기 때문이다. 인라인 함수 호출을 그 함수의 본문으로 바꿔치기하려면, 일단 컴파일러는 그 함수가 어떤 형태인지 알고 있어야 하기 때문이다. 
템플릿도 마찬가지로 헤더파일에 들어 있어야 한다. 템플릿이 사용되는 부분에서 해당 템플릿을 인스턴스로 만들려면 그것이 어떻게 생겼는지를 컴파일러가 알아야하기 때문이다.

인라인 함수가 실제로 인라인되느냐 안 되느냐의 여부는 전적으로 개발자가 사용하는 빌드 환경에 달려있다. 그 중에서도 칼자루를 쥐고 있는 쪽은 컴파일러이다. 

인라인 함수를 어떻게 호출하느냐 에 따라 인라인되기도 하고 안 되기도 한다.
```cpp
inline void f() {...}   //이 f호출은 컴파일러가 반드시 인라인해 준다고 가정.

void (*pf)() = f;

f();     //이 호출은 인라인 된다. 평범한 함수호출이기 때문

pf();    //이 호출은 인라인 되지 않는다. 함수 포인터를 통해 호출하기 때문
```

라이브러리를 설계하는 사람이라면 함수를 inline으로 선언할 때 그 영향에 대해 많은 고민을 해야한다. 예를 들어 어떤 라이브러리에 f라는 인라인 함수가 있는데 사용자가 f함수의 본문을 컴파일에서 응용프로그램을 만들었다면 라이브러리 설계자는 f의 내부를 바꾸기가 애매해진다. 사용자가 다시 각자의 소스를 컴파일해야 하기 때문이다. 반대로 보통 함수였다면 사용자들은 링크만 다시 해주면 된다.

결론은 우선 아무것도 인라인을 하지말고 아니면 꼭 인라인을 해야하는 함수 혹은 정말 단순한 함수에 한해서만 인라인 함수로 선언하는 것으로 시작해라.


+ 함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어두자. 이렇게 하면 디버깅 및 라이브러리의 바이너리 업그레이드가 용이해지고, 자칫 생길 수 있는 코드 부불림 현상이 최소화되면, 프로그램의 속력이 더 빨라질 수 있는 여지가 최고로 많아진다.
+ 함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 생각해서 이들을 inline으로 선언하면 안된다.