# Item34. 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자
상속이라는 개념을 좀 더 자세하게 들여다보면 두 가지로 나뉜다. 하나는 함수 인터페이스의 상속이고 또 하나는 함수 구현의 상속이다. 인터페이스와 구현 상속의 차이는 함수 선언 및 함수 정의와 같은 맥락이다.

멤버 함수의 인터페이스 만을 파생클래스에 상속 받고 싶은 경우
함수의 인터페이스 및 구현을 모두 상속받고 그 상속 받은 구현이 오버라이드가 가능하도록 하는 경우
인터페이스와 구현을 상속받되 어떤 것도 오버라이드 할 수 없도록 막고 싶은 경우

```cpp
class Shape {
public:
	virtual void draw const = 0;
	virtual void error(const std::string& msg);
	int objectID() const;
	...
};
class Rectangle : public Shape { ... };
class Ellipse : public Shape { ... };
```
Shape 클래스는 추상클래스이기 때문에 직접 인스턴스화 할 수 없고 파생클래스로부터 인스턴스화 할 수 있다. 
이 Shape 가 파생클래스들에게 미치는 영향은 절대 군주와 같다.

이유는 멤버 함수 인터페이스는 항상 상속 되게 되어 있기 때문이다. public 상속의 의미는 is-a이므로 기본 클래스에 해당하는 것들은 모두 파생 클래스에도 해당되어야 한다. 따라서 어떤 클래스에서 동작하는 함수는 그 클래스의 파생클래스에서도 동작해야 한다.

Shape 클래스에는 세 개의 함수가 선언되어 있다.
1. draw 함수는 암시적인 표시 장치에 객체를 그린다. (순수 가상 함수)
2. error 함수는 다른 멤버 함수들이 호출하는 함수이다. (단순 가상 함수)
3. objectID 함수는 주어진 객체에 붙는 유일한 정수 식별자를 반환한다. (비가상 함수)

**순수 가상 함수**의 특징 두가지
1. 어떤 순수 가상 함수를 물려받은 구체 클래스가 순수가상함수를 다시 선언해야 한다. 
2. 순수 가상 함수는 전형적으로 추상클래스 안에서 정의를 갖지 않는다. 
즉, 순수 가상함수를 선언하는 목적은 파생 클래스에게 함수의 인터페이스만을 넘겨주려는 목적이다.
```cpp
Shape *ps1 = new Rectangle;

ps1->Shape::draw();  //Shape::draw를 호출
```
사실 순수 가상 함수에도 정의를 제공할 수 있다. 다시 말하면 Shape::draw 함수에 대해 구현을 붙일 수 있다는 이야기 이다. 단, 구현이 붙은 순수 가상 함수를 호출하려면 반드시 클래스 이름에 한정자를 붙여주어야 한다. 왜냐하면 추상 클래스로는 인스턴스를 만들 수 없기 때문이다.

**단순 가상 함수**의 이면에 들어있는 속뜻은 순수 가상 함수와 비교할 때 몇가지 다른 면이 있다. 파생 클래스로 하여금 함수의 인터페이스를 상속하게 한다는 점은 똑같지만 파생 클래스 쪽에서 오버라이드 할 수 있는 함수 구현부도 제공한다는 점이 다르다. 
즉, 단순 가상 함수의 목적은 파생 클래스로 하여금 함수의 인터페이스 뿐만 아니라 그 함수의 기본 구현도 물려받게 하는 것이다.

위의 Shape::error() 인터페이스가 전하는 바는 다음과 같다. 실행 중에 에러와 마주쳤을 때 자동으로 호출될 함수를 제공하는 것은 모든 클래스가 해야하는 일이지만, 그렇다고 각 클래스마다 그때그때 꼭 맞는 방법으로 클래스를 처리할 필요가 없다는 뜻이다.

단순 가상 함수에서 함수 인터페이스와 기본 구현을 한꺼번에 지정하도록 하는 것은 위험할 수도 있다. 왜냐하면 인터페이스, 기본 구현 두가지를 한꺼번에 제공하기 때문이다. 이것이 위험한 이유는 명시적으로 원하지 않았는데 물려주기 때문이다. 원래라면 오류가 띄어지거나 해야하지만 그런 에러가 나타나지 않는다는 게 문제이다. 아래의 코드를 보며 확인해보자.
```cpp
class Airport { ... };

class Airplane {
public:
	virtual void fly(const Airport& destination);
};

void Airplane::fly(const Airport& destination)
{
	주어진 목적지로 비행기를 날려 보내는 기본 동작을 나타내는 코드
}

class ModelA: public Airplane { ... };
class ModelB: public Airplane { ... };

```
위 코드는 Airplane이라는 클래스를 ModelA와 ModelB가 상속 받았다. 그리고 Airplane::fly 함수는 가상함수로 선언되었다. Airplane::fly 함수를 딱히 재정의 없이 사용하였다. 이후 ModelC 를 새로 만든다고 했을 때 이 AirPlane은 fly방식이 완전히 다른 방식으로 만들 것이다.
```cpp
class ModelC: public Airplane {
	...  //fly함수가 선언되지 않음.
};
```
그런데 이게 왜 인걸 fly함수를 재정의하는 것을 깜빡하였다. 이후 동작에서 확인해보니 기본 구현을 따라간다. 기본 동작을 원한다고 명시적으로 밝히지 않았는 데도 불구하고 이 동작을 물려받는데 아무런 거리낌이 없다는 뜻이다. 이런 위험성이 존재한다.

위를 해결하는 방법은 가상 함수의 인터페이스와 그 가상 함수의 기본 구현을 잇는 연결관계를 끊는 것이다.
```cpp
class Airplane {
public:
	virtual void fly(const AirPort& destination) = 0;
protected:
	void defaultfly(const Airport& destination);
}
```
defaultfly함수가 protected 인 이유는 Airplane 및 그 클래스의 파생클래스만 내부적으로 사용하는 구현 세부사항이기 때문이다. 또한 defaultfly가 비가상 함수인 이유는 파생 클래스에서 이 함수를 재정의해서는 안되기 때문이다.

위의 방법이 fly와 defaultfly를 별도로 마련한 방법인데 이를 싫어하는 경우도 존재한다. 
이유는 중요하지도 않게 얽힌 관계로 클래스의 네임스페이스가 더러워질 수도 있기 때문이다.
해결 방법으로는 순수 가상 함수가 구체 파생클래스에서 재선언되어야 한다는 사실을 활용하며 자체적으로 순수 가상함수의 구현을 구비해 두는 방법이 있다.
```cpp
class Airplane {
public:
	virtual void fly(const Airport& destination) = 0;
	...
};
void Airplane:fly(const Airport& destination) //순수 가상 함수의 구현
{
	주어진 목적지로 비행기를 날려보내는 비행기를 날려보내는 코드
}
```
위는 fly함수가 선언구 및 정의부의 두 쪽으로 나뉜 것이다. 선언부는 이 함수의 인터페이스를 지정하고 정의부는 이 함수의 기본 동작을 지정한다.

단점으로는 fly와 defaultfly가 하나로 합쳐져 각기 다른 보호 수준을 부여할 수 있는 융통성이 날아간 것이다.

**비가상함수**
멤버함수가 비가상 함수라면 이 함수는 파생클래스에서 다른 일이 일어날 것으로 가정하지 않은 것이다. 
비가상함수는 클래스 파생에 관계없이 변하지 않는 동작을 지정하는 데 쓰인다. 
비가상함수를 선언하는 목적은 파생 클래스가 함수 인터페이스와 더불어 그 함수의 필수적인 구현을 물려 받는 것이다.

Shape::ObjectID의 선언은 이렇게 말해야 한다. "Shape 및 이것에서 파생된 모든 객체는 객체의 식별자를 내어주는 함수를 갖게 되겠지. 객체의 식별자를 계산하는 방법은 똑같겠군. 실제 계산 방법은 ObjectID의 정의에서 결정하고 파생클래스는 이것을 바꿀 수 없겠는 걸."

비가상 함수는 파생클래스에서 재정의 할 수 있는 수준의 것이 절대 아니다.

**클래스를 설계할 때 발생할 수 있는 문제점**
1. 모든 멤버 함수를 비가상 함수로 선언
2. 모든 멤버 함수를 가상 함수로 선언하는 것


+ 인터페이스 상속은 구현 상속과 다르다. public 상속에서 파생클래스는 항상 기본 클래스의 인터페이스를 모두 물려받는다.
+ 순수 가상 함수는 인터페이스 상속만을 허용한다.
+ 단순(비순수) 가상 함수는 인터페이스 상속과 더불어 기본 구현의 상속도 가능하도록 지정한다.
+ 비가상 함수는 인터페이스 상속과 더불어 필수 구현의 상속도 가하도록 지정한다.