# Item36. 상속받은 비가상 함수를 파생 클래스에서 재정의하는 것은 절대 금물!
```cpp
class B {
public:
	void mf();
	...
};

class D : public B { ... };

D x;
B *pB = &x;
pB->mf();  //mf 함수 호출

D *pD = &x;
pD->mf();  //mf 함수 호출
```
위의 경우 같은 함수가 호출됨. 근데 다른 함수가 호출 될 수 있는 경우도 있다.

```cpp
class D : public B {
public:
	void mf();
	...
};

pB->mf();  //B::mf를 호출
pD->mf();  //D::mf를 호출
```
위와 같은 경우가 다른 경우로 mf가 비가상 함수이고 D클래스가 자체적으로 mf 함수를 정의하고 있으면 위와 같이 황당한 동작이 발생한다.

이유는 B::mf 및 D::mf 등의 비가상 함수는 정적 바인딩(static binding)으로 묶이기 때문이다.

예를들면 pB를 통해 호출되는 비가상 함수는 항상 B클래스에 있을 것으로 결정한 것이다.

반면, 가상 함수는 동적 바인딩으로 묶인다. 만약 mf 함수가 가상함수였다면, mf가 pB에서 호출되는 pD에서 호출되는 D::mf()가 호출된다.

이유는 pB및 pD가 진짜로 가리키는 대상은 D타입의 객체이다.

public 상속의 의미는 "is-a"이다. 항목34에 의하면 비가상 멤버 함수는 클래스 파생에 관계없는 불변동작을 정해두는 것이라고 말했다. 이 두가지 포인트를 이전 상황에 그대로 대입하면 다음과 같다.

+ B객체에 해당되는 모든 것들이 D 객체에 그대로 적용된다. 왜냐하면 모든 D객체는 B객체의 일종이기 때문이다. 
+ B에서 파생된 클래스는 mf함수의 인터페이스와 구현을 모두 물려받게 된다. mf는 B클래스에서 가상 멤버 함수이기 때문이다.
여기에서 D에 mf를 재정의 해버리면 모순이 발생한다.


+ 상속받은 비가상 함수를 재정의 하는 일은 절대로 하지 말자.