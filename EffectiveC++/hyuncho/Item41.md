# Item41. 템플릿 프로그래밍의 천릿길도 암시적 인터페이스와 컴파일 타임 다형성부터
객체 지향 프로그래밍의 세계를 회전시키는 축은 **명시적 인터페이스**(explicit interface)와 **런타임 다형성**(runtime polymorphism)이다.
```cpp
class Widget {
public:
	Widget();
	virtual ~Widget();
	virtual std::size_t size() const;
	virtual void normalize();
	void swap(Widget& other);
	...
};

void doProcessing(Widget& w)
{
	if (w.size() > 10 && w != someNastyWidget) {
		Widget temp(w);
		temp.normalize();
		temp.swap(w);
	}
}
```
+ w는 Widget 타입으로 선언되었기 때문에 w는 Widget 인터페이스를 지원해야한다. 이 인터페이스를 소스 코드(.h 파일 등)에서 찾으면 이것이 어떤 형태인지 확인할 수 있으므로, 이건 인터페이스를 가리켜 명시적 인터페이스라고 한다. 소스 코드에 명시적으로 드러나는 인터페이스 인 것.
+ Widget의 멤버 함수 중 몇 개는 가상 함수이므로, 이 가상 함수에 대한 호출은 런타임 다형성에 의해 이루어진다. 다시 말해, 특정한 함수에 대한 실제 호출은 w의 동적 타입을 기반으로 프로그램 실행 중, 즉 런타임에 결정된다.

템플릿과 일반화 프로그래밍의 세계에서는 뿌리부터 뭔가 다른 부분이 있다. 이제 암시적 인터페이스(implicit interface)와 컴파일 다형성(compiletime polymorphism)에 대해 살펴보겠다.
```cpp
template <typename T>
void doProcessing(T& w)
{
	if (w.size() > 10 && w != someNastyWidget){
		T temp(w);
		temp.normalize();
		temp.swap(w);
	}
}
```
+ w가 지원해야 하는 인터페이스는 이 템플릿 안에서 w에 대해 실행되는 연산이 결정한다. size, normalize, swap, 복사생성자, 부등 비교 연산을 지원해야 한다. 이 템플릿이 제대로 컴파일 되려면 몇 개의 표현식이 유효해야 하는데 이 표현식들을 T가 지원해야 하는 **암시적 인터페이스** 라는 점이다.
+ w가 수반되는 함수 호출이 일어날 때, 이를 테면 operator > 및 operator != 함수가 호출될 때는 해당 호출을 성공시키기 위해 템플릿의 인스턴스화가 일어난다. 이러한 인스턴스화가 일어나는 시점은 **컴파일 도중**이다. 인스턴스화를 진행하는 함수 템플릿에 어떤 템플릿 매개변수가 들어가느냐에 따라 호출되는 함수가 달라지기 때문에 이것을 **컴파일 타임 다형성** 이라고 한다.

**런타임 다형성 vs 컴파일 타임 다형성**
오버로드된 함수 중 지금 호출할 것을 골라내는 과정(컴파일 중에 일어남)과 가상함수 호출의 동적 바인딩(프로그램 실행 중에 일어남)의 차이점과 흡사.

**명시적 인터페이스 vs 암시적 인터페이스**
명시적 인터페이스는 대개 함수 시그너처로 이루어진다. 시그너처란 함수의 이름, 매개변수 타입, 반환 타입 등을 통틀어 부르는 용어다. 예를 들면 Widget 클래스의 생성자, 소멸자를 포함해서 size, normalize, swap 함수 그리고 이들의 매개변수 타입, 반환 타입 및 각 함수의 상수성 여부로 이루어져 있는 것이다.
반면, 암시적 인터페이스는 사뭇 다르다. 함수 시그너처에 기반하고 있지 않다는 것이 가장 큰 차이점이다. 암시적 인터페이스를 이루는 요소는 유효 표현식(expression)이다.
```cpp
template<typename T>
void doProcessing(T& w)
{
	if (w.size() > 10 && w != someNastyWidget){
		...
	}
}
```
이때 T에서 제공될 암시적 인터페이스에는 다음과 같은 제약이 걸린다.
+ 정수 계열의 값을 반환하고 이름이 size인 함수를 지원해야 한다. -> 사실 정수 계열 반환할 필요는 없음.
+ T 타입의 객체 둘을 비교하는 operator != 함수를 지원해야 한다. -> 꼭 T타입일 필요는 없다. operator != 타입에 맞는 암시적 변환이 이루어지면 되기 때문.
실제로는 연산자 오버로딩 가능성이 있어 T는 위의 두 가지 제약 중 어떤 것도 만족 시킬 필요가 없다.

클래스에서 제공하는 명시적 인터페이스와 호환되지 않는 방법으로 그 클래스의 객체를 쓸 수 없듯이, 어떤 템플릿 안에서 어떤 객체를 쓰려고 할 때 그 템플릿에서 요구하는 암시적 인터페이스를 그 객체가 지원하지 않으면 사용이 불가능하다.(코드가 컴파일 되지 않음.)


+ 클래스 및 템플릿은 모두 인터페이스와 다형성을 지원한다.
+ 클래스의 경우, 인터페이스는 명시적이며 함수의 시그너처를 중심으로 구성되어 있다. 다형성은 프로그램 실행 중에 가상 함수를 통해 나타난다.
+ 템플릿 매개변수의 경우, 인터페이스는 암시적이며 유효 표현식에 기반을 두어 구성된다. 다형성은 컴파일 중에 템플릿 인스턴스화와 함수 오버로딩 모호성 해결을 통해 나타난다.