# Item22. 데이터 멤버가 선언될 곳은 private 영역임을 명심하자_
이번 항목에서는 데이터 멤버가 왜 public이면 안되는지 살펴보고 public 데이터 멤버에 대한 모든 이야기가 protected 데이터 멤버에도 똑같이 적용되는 모습을 확인할 것이다.

## 문법적 일관성
데이터 멤버가 public이 아니라면 사용자 쪽에서 어떤 객체를 접근할 수 있는 유일한 수단은 멤버 함수일 것이다. 어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수뿐이라면 더 이상 생각말고 그냥 쓰기만 하면된다.

함수를 사용하면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할 수 있다.
```cpp
class AccessLevels {
public:
	...
	int getReadOnly() const { return readOnly; }
	void setReadWrite(int value) { readWrite = value; }
	int getReadWrite() const { return readWrite; }
	void setWriteOnly(int value) { writeOnly = value;}
private:
	int noAccess;   //이 int에 대해서는 접근 불가
	int readOnly;   //이 int에 대해서는 읽기 전용 접근
	int readWrite;  //이 int에 대해서는 읽기 쓰기 접근
	int writeOnly;  //이 int에 대해서는 쓰기 전용 접근
}
```
위와 같은 세밀한 접근 제어는 어떤 식으로든 외부에 노출시키면 안 되는 데이터 멤버들이 꽤 많기 때문에 중요하게 사용된다.

## 캡슐화
함수를 통해서만 데이터 멤버에 접근 할 수 있도록 구현해 두면, 데이터 멤버를 나중에 계산식으로 대체할 수도 있다.
```cpp
class SpeedDataCollection {
	...
public:
	void addValue(int speed);
	double averageSoFar() const;
	...
};
```
averageSoFar 멤버 함수를 구현하는 방법
1. 수집한 속도 데이터 전체의 평균 값을 담는 어떤 데이터 멤버를 클래스 안에 넣어두는 방안. averageSoFar함수는 호출될 때마다 그 데이터 멤버의 값을 반환하기만 하면 됨.
   + SpeedDataCollection의 객체 크기가 커진다. 이유는 평균값을 유지하기 위한 공간할당이 필요하다. 현재의 평균값, 누적총합, 데이터의 개수 등이 데이터 멤버로 들어가야 한다.
   + 이는 결국 효율 측면에서 좋다.
2. 호출 될 때마다 평균값을 계산하는 방법
   + 함수 자체의 속도가 느려지지만, SpeedDataCollection 객체 하나의 크기는 줄어든다.

결국 두 가지 방법 모두 상황에 맞춰 사용하면 된다. 중요한 포인트는 "평균값 접근에 멤버 함수를 통하게 한다"(다른 말로 평균값을 캡슐화한다)라는 점인데, 이렇게 함으로써 내부 구현을 바꿀 수도 있고 사용자 쪽에서는 기껏 해 봤자 컴파일만 다시 하면 끝난다.

데이터 멤버를 함수 인터페이스 뒤에 감추게 되면 구현상의 융통성을 전부 누릴 수 있다.
1. 데이터 멤버를 읽거나 쓸 때 다른 객체에 알림 메시지를 보낸다던지
2. 스레딩 환경에서 동기화를 건다든지

캡슐화는 현재의 구현을 나중에 바꾸기로 결정할 수 있는 권한을 예약하는 셈이다. 결국 public 은 '캡슐화 되지 않았다' 라는 뜻이면 '이는 바꿀 수 없다' 라는 의미를 가지고 있다. 

protected 데이터 멤버의 경우도, 앞서 말한 사정과 비슷하다. 결국 똑같게 된다. 문법적 일관성과 세밀한 접근 제어에 관한 이야기라면 public 데이터 멤버처럼 protected 데이터 멤버에도 그대로 적용할 수 있다.


+ 데이버 멤버는 private 멤버로 선언하자. 이를 통해 클래스 제작자는 문법적으로 일관성 있는 데이터 접근 통로를 제공할 수 있고, 필요에 따라서는 세밀한 접근 제어도 가능하며, 클래스의 불변속성을 강화할 수 있을 뿐 아니라, 내부 구현의 융통성도 발휘할 수 있다.
+ protected는 public보다 더 많이 '보호'받고 있는 것이 절대로 아니다.