```cpp
class Widget {
public:
	...
	~Widget () { ... }        //이 함수에서 예외가 발생한다면
};

void doSomething()
{
	std::vector<Widget> v;
	...
}                             //v는 여기서 자동 소멸
```
벡터 v가 소멸될 때 거느리고 있던 Widget을 소멸시킨다. 첫 번째를 소멸시키는 도중에 예외가 발생하고 나머지 것들이 소멸되어야할 때 두 번째 소멸시키는 와중에 예외가 또 발생하여 예외가 동시에 두개가 만들어지는 상황이 발생한다. 이것은 프로그램 종료 혹은 미정의 동작으로 이어지고 이것의 원인은 바로, 예외가 터져 나오는 것을 내버려두는 소멸자에게 있다.
이것을 해결하기 위한 방법으로 두가지가 존재한다.
+ **close에서 예외가 발생하면 프로그램을 바로 끝낸다. 대개 abort를 호출한다.**
```cpp
DBConn::~DBConn()
{
	try { db.close(); }
	catch (...) {
		close 호출이 실패했다는 로그 작성;
		std::abort();
	}
}
```
+ **close를 호출한 곳에서 일어난 예외를 삼켜버린다.**
```cpp
DBConn::~DBConn()
{
	try { db.close(); }
	catch (...) {
		close 호출이 실패했다는 로그를 작성한다.
	}
}
```

```cpp
class DBConn {
public:
	...
	void close()
	{
		db.close();
		closed = true;
	}
	~DBConn()
	{
		if (!closed)
		try {
			db.close();
		}
		catch (...) {
			close 호출이 실패했다는 로그를 작성;
		}
	}
private:
	DBConnection db;
	bool closed;	
};
```

좋은 전략으로는 DBConn 인터페이스를 잘 설계해서, **발생할 소지가 있는 문제에 대처할 기회를 사용자가 가질 수 있도록** 하면 어떨까? 이를 테면 DBConn에서 **close 함수를 직접 제공**하게 하면 이 함수의 실행 중에 발생하는 예외를 직접 처리 할 수 있을 것이다. DBConnection이 닫혔는지의 여부를 유지했다가, 닫히지 않았으면 DBConn의 소멸자에서 닫을 수도 있을 것이다. 이렇게 하면 데이터 베이스의 연결이 누출되지 않는다. 소멸자에서 호출하는 close마저 실패한다면 끝내거나 혹은 삼켜버리거나의 모드로 돌아온다.

+ 소멸자에서는 예외가 빠져나가서는 안된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리든지 프로그램을 끝내든지 해야 한다.
+ 어떤 클래스의 연산이 진행되다가 던진 예외에 대해서 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 한다.
