# Item13. 자원관리에는 객체가 그만!
```cpp
void f()
{
	Investment *pInv = createInvestment();
	...
	delete pInv;
}
```
만약 ... 부분에 예외가 있다던지 return 문 같은게 있다면 pInv가 delete 되지 않는 경우가 존재한다.
createInvestment 함수로 얻어낸 자원이 항상 해제되도록 만들 방법은, 자원을 객체에 넣고 그 자원 해제를 소멸자가 맡도록 하며, 그 소멸자는 실행 제어가 f를 떠날 때 호출되도록 만드는 것이다. 즉, 자원을 객체에 넣음으로써, C++가 자동으로 호출해 주는 소멸자에 의해 해당 자원을 저절로 해제할 수 있다.
### 스마트 포인터
**auto_ptr 스마트 포인터**
+ 자원을 획득한 후에 자원 관리 객체에게 넘긴다.(RAII: Resource Acquisition Is Initialization)
+ 자원 관리 객체는 자신의 소멸자를 사용해서 자원이 확실히 해제되도록 한다.
+ auto_ptr은 자신이 소멸될 때 자신이 가리키고 있는 대상에 대해 자동으로 delete를 먹이기 때문에, 어떤 객체를 가리키는 auto_ptr의 개수가 둘 이상이면 절대로 안된다. 이렇게 되면 자원이 두 번 삭제되는 결과를 낳는다.
+ 객체를 복사하면 원본 객체는 null로 만든다. 이는 복사하는 객체만이 자원의 유일한 소유권을 갖게하기 위해서 이다.
+  STL 컨테이너의 경우에 정상적인 복사 동작을 가져가야 하기 때문에 auto_ptr이 원소로 허락되지 않는다. 그렇기 때문에 이 대안으로 참조 카운팅 방식 스마트 포인터(reference-counting smart pointer: RCSP)가 아주 좋다.
**tr1::shared_ptr 스마트 포인터**
+ TR1에서 제공되는 tr1::shared_ptr이 대표적인 RCSP이다.
+ RCSP는 특정한 어떤 자원을 가리키는 외부 객체의 개수를 유지하고 있다가 개수가 0이 되면 해당 자원을 자동으로 삭제하는 스마트 포인터이다. 이는 가비지 컬렉션과 흡사한 방식이다. 차이점은 참조 상태가 고리를 이루는경우(서로 참조하는 경우) 없앨 수 없다는 점은 가비지 컬렉션과 다르다.
+ RCSP는 복사 동작이 예상대로 이루어지며 STL에서도 사용할 수 있다.
auto_ptr과 tr1::shared_ptr은 소멸자 내부에서 delete연산자를 사용한다. delete [] 연산자가 아니다. 즉 동적 배열을 쓰면 난감하다. 그런데 컴파일 에러도 나지 않는다..

+ 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 사용하자.
+ 일반적으로 널리 쓰이는 RAII 클래스는 tr1::shared_ptr 그리고 auto_ptr이다. 이 둘 가운데 tr1::shared_ptr이 복사 시의 동작이 직관적이기 때문에 대개 더 좋다. 반면 auto_ptr은 복사되는 객체(원본 객체)를 null로 만들어 버린다.