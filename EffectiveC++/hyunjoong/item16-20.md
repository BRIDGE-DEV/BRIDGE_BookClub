# 항목 16

배열일 경우에 delete[]를 잘 호출하자.
typedef 안에 []를 넣어둬서 문제가 생길 수도 있다니.. 하지 말아야겠다.

> 배열 맨 앞에 원소의 개수를 적는 컴파일러가 있다길래.. 한번 메모리를 들쑤시며 확인 해 봤는데, 의외로 그런 것은 찾을 수 없었다. 일단 맥 llvm은 이 방식은 아닌 것 같은데, 컴파일러는 그냥 배열 크기가 얼마인지 모르고 그냥 작동하는 것 같기도 하고.. 모르겠다.

> operator new[]는 그냥 operator new를 호출할 뿐이었다. 책에 나온 대로 100개의 int에 해당하는 배열을 operator new[]로 만들자, 100이라는 숫자 대신에 0x190(dec 400)이라는 숫자를 줬을 뿐이다. 0x200도 아니고 0x190은 도대체 어디서 나온 숫자란 말인가..? 그리고 operator new는 malloc을 호출하며 포인터를 돌려준다.

> operator delete[]도 마찬가지다. 그냥 operator delete를 호출하고, 그게 또 free를 호출한다.

> 깊게 파고 보니 의문만 남기고 끝나버렸다..

# 항목 17

https://en.cppreference.com/w/cpp/language/eval_order

놀랍게도 함수 인수들의 서순은 미정이다. 책에서 나온 대로 이상한 일들이 일어날 수 있다. 항상 생각해서 다른 줄에 떼어 놓자.

또 다른 점으로 std::make_unique, std::make_shared를 사용해서 애초에 포인터를 만드는게 좋다.

```cpp
std::unique_ptr<int> p = std::make_unique<int>(); // c++14
std::unique_ptr<int[]> q = std::make_unique<int[]>(100); // c++14

std::shared_ptr<int> ps = std::make_shared<int>(); // c++11
std::shared_ptr<int[]> qs = std::make_shared<int[]>(100); // c++20
```

std::make_shared는 control block(ctrlblk)의 allocation도 같이 해주기 때문에 필수다. 쓰지 않으면 두 번 allocation해야 한다. 다만 이 네 개의 문장이 다른 c++버젼에 등장했음에 주의하자..

# 항목 18

'enum의 타입 안정성이 그리 믿음직하지 못하다'라고 돼 있는데, c++11에 추가된 enum class를 사용하면 된다.

```cpp
enum class Month {
    Jan = 1,
    Feb,
    Mar,
    Apr,
    ...
};


Date d{Day{1}, Month::Jan, Year{1}};
```

이렇게 쓰면 된다.

non-local static object는 translation unit들 사이에서 초기화 서순을 알 수 없다! 역시 이번에도 머리 한 대 맞고 간 기분이었다.. 머릿속에 지우개 인정.
근데 아무리 봐도 그냥 enum class가 해답인 듯 하다.

int와 비슷하게 만들어라. 좋은 문장인 것 같다.

> 사실 자바는 좀 잘못 만들었다에 동의하지만, C#은 Length와 Count는 생각보다 다른 개념이다.
Length는 할당된 C# 배열의 전체 크기지만, Count는 동적 배열의 전체 크기가 아니라 원소의 수이다.
그러니깐 Length는 좀 sizeof array랑 비슷하고, Count가 size()고 Capacity가 capacity()인 느낌이다.
C#은 솔직히 무죄인듯..

아무튼 포인트는 통일성 있는 인터페이스를 제공하라는거니, 그거는 십분 동의한다.


std::unique_ptr은 deleter를 직접 할당할 수 있으니 책의 내용도 업데이트가 필요할 것이다.

사실 여기 부분에서 나오는 문제가 c 프로그래밍 하다 .
