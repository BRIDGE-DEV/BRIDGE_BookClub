# item 21

dangling reference/pointer에 대한 이야기이다. 함수 안에 있는 local variable에 대한 포인터나 레퍼런스를 반환 할 경우, 함수가 종료되며 해당 스택이 dealloc되기 때문에 dangling pointer가 된다.

지난 시간에 얘기했던 rvo에 대한 이야기도 나온다. 자세한 조건까지는 외우진 못하겠지만 이런 식으로 리턴 문 위나 그 근처에 쓰면 함수 안에서 객체를 만들지 않고, 함수를 호출한 곳에 바로 생성해 준다.

# item 22

캡슐화를 하고 get/set을 만드는 것은 우선 좋은 일이라고 생각한다. 일단 밖에서 값을 쓰지 않는다는 것에 대한 보장이 코드를 수정할 때 마음의 안정감(?)을 주는 것 같다. 다만 반대로 get/set이 예상치 못한 side effect가 있거나 예상치 못한 if문과 여러 성능상의 해악이 존재할 수 있다는 것이다. 개인적으로는 get/set에서는 뭔가 예상치 못한 대단한 일을 하지 않는 것이 좋다고 생각한다.

개인적인 생각으로는, 만약에 hp를 set했을 때 hp바 ui가 바뀐다고 해 보자.

```C#
player.Hp -= 10;
```

```c++
player->AddHp(-10);
```

위의 코드는 C#의 코드고, 아래는 C++의 코드이다. 위 코드는 그냥 아무런 일 없이 해맑게 숫자만 낮춰줄 것 같은데, 실제로는 hp ui 업데이트도 해 주고, ui 업데이트 할 때 0보다 낮으면 그냥 0으로 나오게 해 주는 if문이 숨어있을 수 있는데도 불구하고, 그냥 숫자만 내리는 것 같아서 방심하게 한다고 생각한다.
반대로 c++의 코드는 딱 봐도 함수고, 뭔가 다른 일을 할 수도 있다는걸 생각하게 해 준다. 그래서 나는 C#에서도 이런 side-effect가 있는 친구들은 함수로 하는게 맞지 않을까 생각을 하는데... 논의해보고 싶다. (물론 1프레임에 hp를 백 만번 낮추는게 아니기 때문에 차이는 미미할 수 있겠다.)

public이나 protected나 거기서 거기라는 점을 기억하자. 둘 다 외부에 api를 노출하는 접근제한자이다.

public/protected인데 '사용자가 그것을 사용하기 시작했으면, 그 멤버는 완전히 코 꿰인 겁니다.'라는 말이 공감이 된다.. 그래도 사용처가 한두개면 그나마 괜찮지만.. public 멤버를 수정하는 곳은 최대한 적은게 좋긴 한듯..

또 다른 논의 사항은, 나는 개인적으로 한창 개발하는 단계고, get, set을 둘 다 만들어 두고 특별한 일을 하지 않는다면, 그냥 public으로 두는게 나은 상황도 있다는 생각이다. 일단 그냥 public으로 두는게 더 심플하기 때문이다. 물론 책에서 이야기한대로 나중에 바꿀 여지를 더 두긴 하지만.. 일단 확실히 특별한 일이 없을 것 같으면 나는 public으로 두는 편인 것 같다. 그리고 특히 엄청 큰 플젝이 아니고 해당 변수를 접근하는 곳이 많지 않을 것 같을 때, 그냥 public으로 두는게 개발 속도 측면에서 이득이지 않나..싶다.
또 다른 포인트로 그렇게 외부에서 그냥 get, set을 써 둘 경우에 외부에서 set하는 경우가 많을 경우에, 코드를 수정하기 쉽지 않아지는 것은 매한가지가 아닐까? 개발 초기 단계나 빨리 움직여야 할 때는 오히려 독이 될 수 있다는 생각이다.

# item 23

세 함수를 동시에 호출해주는 새 함수가 멤버 함수가 된다면, 오히려 데이터 멤버에 접근하는 방법을 늘려서 반대로 캡슐화에 좋지 않다는 접근이 흥미로웠다.

우선 이 주장도 맞다고 생각은 들지만... 반대로 코드를 복잡하게 하는 건 아닐까. 사실 컴파일되는 결과만 생각하면 두 방법은 아무 차이가 없다. 다만 문법의 차이, 그리고 캡슐화를 더 타이트하게 하기 위해서 코드가 복잡해질 뿐이라는 생각이다. 하지만 또 여러 헤더에 나눠서 넣을 수 있다는 점은 필요하다면 장점이 될 수 있다는 생각이 든다. 뭔가 완벽히 설득되는 항목은 아니었지만 이런 방법도 잘 알아둬야겠다.

...

생각을 좀 정리해 보니, 사실 저 세 개를 한 번에 호출해주는 건, 이 클래스의 기능이라기보단 어떻게 보면 그냥 매크로같은 존재다. 그렇기 때문에 이렇게 하는게 오히려 말이 된다느 생각이 들었다.

# item 24

요약: 이런식으로 암시적 변환이 먹히는 연산을 하고 싶을 때는 비멤버로 해서, 두 파라미터가 모두 보이는 함수를 만들어야 한다. 그리고 굳이 friend함수가 아니어도 될 때는 안붙이면 된다.

# item 25

솔직히 어렵다.. 이렇게 어려울 때는 직접 짜 보면 된다.

하지만 모던에서는 이 항목을 사실 몰라도 된다. move semantic의 등장 때문이다. rule of five/zero만 잘 지키면 된다. rule of five/zero는 ./ruleoffive.cpp, ./ruleofzero.cpp 참고.

c++98로 짠 코드를 볼 때는 알아야되기 때문에 공부를 해 보자.

1. 일단 swap을 직접 구현하지 않아도 되면 안하면 된다.

2. 해야 한다면
    a. public 멤버 함수로 두 객체의 값을 바꾸는 swap이라는 함수 만들기
    b. 비멤버 swap을 같은 네임스페이스에 두고 a.를 호출하게 함
    - 만약에 템플릿 클래스라면 std::swap의 특수화 버젼을 만들기. 그리고 a. 호출.

3. 사용자 입장에서 호출할 때
    std::swap이라 하지 말고 using std::swap; swap(...)를 하기. std::swap하면 우리가 열심히 만들어놓은게 호출이 안 됨.

그리고 기억할 것: std namespace에 완전 특수화를 제외한 뭔갈 추가하면 ub이다. 새 템플릿 추가하면 ub.

근데 직접 짜면서 꺠닫게 된 것이.. rule of five를 지키면 이걸 안해도 된다.
왜냐면 std::swap 구현이 std::move를 사용하게 바뀌었기 때문이다.

일단 책의 저자가 쓴 버젼은 c++98이고, 요즘은 거의 17, 20을 쓴다.
아무튼 std::move의 등장으로 코드의 결과값이 완전히 달라졌는데, item25.cpp와 item25-98.cpp를 참고 바란다.

