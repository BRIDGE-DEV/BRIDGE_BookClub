# Effective C++
## 1장. C++에 왔으면 C++의 법을 따릅시다.
### 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

객체의 값을 초기화하는 데 있어서 C++은 이랬다 저랬다 한다. 어떤 상황에서는 초기화되지만, 또 어떤 상황에서는 그것이 보장되지 않는다.

초기화되지 않은 값을 읽도록 내버려 두면 정의되지 않은 동작이 나오게 된다. 프로그램이 멈출 수도 있고, 대체로는 적당히 무작위 비트 값을 읽고 객체의 내부가 이상한 값을 갖게 된다.

C++의 객체(변수) 초기화가 중구난방인 것은 절대 아니다. 언제 초기화가 보장되며 언제 그렇지 않은지에 대한 규칙이 명확하다. 안타까운 점은 규칙이 조금 복잡하다는 것이다.

_(그러고보니 왜 뭐는 초기화되고 뭐는 안되는지 궁금해해본 적이 없다.. 이래서야 프로그래머를 할 수 있을까나)_

가장 좋은 방법은 모든 객체를 사용하기 전에 항상 초기화하는 것이다. 기본제공 타입으로 만들어진 미멤버 객체에 대해서는 초기화를 손수 하자.

이런 부분을 제외하고 나면, C++ 초기화의 나머지 부분은 생성자로 귀결된다. 생성자에서 지킬 규칙은 지극히 간단하다. 그 객체의 모든 것을 초기화하자!

지키기 쉬운 규칙이지만 대입과 초기화를 헷갈리지 않는 것이 가장 중요하다. C++ 규칙에 의하면 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화되어야 한다고 명시되어 있다. 

해답은 대입문 대신에 멤버 초기화 리스트를 사용하는 것이다. 데이터 멤버에 사용자가 원하는 값을 주고 시작한다는 점에서는 똑같지만, 방금 만든 생성자는 앞의 것보다 더 효율적일 가능성이 크다. 대입만 사용한 버전의 경우 앞서 한 초기화가 쓸모 없어진다. 이 문제는 멤버 초기화 리스트를 사용하면 피해 갈 수 있다. 초기화 리스트에 들어가는 인자는 바로 데이터 멤버에 대한 생성자의 인자로 쓰이기 때문이다. 대부분의 데이터 타입에 대해서는, 기본 생성자 호출 후에 복사 대입 연산자를 연달아 호출하는 이전의 방법보다 복사 생성자를 한 번 호출하는 쪽이 더 효율적이다.

앞서 말한 '대부분의 타입'에 포함되지 않는 타입이 기본 제공 타입이다. 기본제공 타입의 객체는 초기화와 대입에 걸리는 비용의 차이는 없지만 역시 멤버 초기화 리스트에 넣어 주는 쪽이 좋다. 또 데이터 멤버를 기본 생성자로 초기화하고 싶을 때도 멤버 초기화 리스트를 사용하는 습관을 들이는 것이 좋다. 기본 생성자이든 아니든 클래스 데이터 멤버는 모두 초기화 리스트에 항상 올려주는 센스를 정책으로 박아 두셔야만, 어쩌다가 리스트에서 어떤 멤버를 빼먹었을 때 어떤 멤버가 초기화되지 않을 수도 있다는 사실을 끌고 가야 하는 부담이 없어진다.

기본제공 타입의 멤버를 초기화 리스트로 넣는 일이 선택이 아니라 의무가 될 때도 있다. 상수이거나 참조자로 되어 있는 데이터 멤버의 경우가 그렇다. 상수와 참조자는 대입 자체가 불가능하기 때문이다.

C++에서 변하지 않는 부분은 객체를 구성하는 데이터의 초기화 순서이다. 이 순서는 어떤 컴파일러를 막론하고 항상 똑같다. (1) 기본 클래스는 파생 크래스보다 먼저 초기화되고, (2) 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다.

마지막 문제는 이것이다. '비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.' 그러니까 별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체(전역 객체, 네임스페이스에 있는 객체, 클래스 혹은 파일에 있는 정적 객체)가 한 개 이상 들어 있는 경우에 어떻게 되느냐 하는 것이다. 실제적인 문제는 이것이다. 한쪽 번역 단위에 있는 비정적 객체의 초기화가 진행되면서 다른 쪽 번역 단위에 있는 비지역 정적 객체가 사용되는데, 불행히도 이 (다른 쪽의) 객체가 초기화되어 있지 않을지도 모른다는 점이다.

방법은 간단하다. 비지역 정적 객체를 하나씩 맡는 함수를 준비하고 이 안에 각 객체를 넣는 것이다. 함수 속에서도 이들은 정적 객체로 선언하고, 그 함수에서는 이들에 대한 참조자를 반환하게 만든다. 사용자는 비지역 정적 객체를 직접 참조하지 않고 함수 호출로 대신한다. 정리하면 '비지역 정적 객체'가 '지역 정적 객체'로 바뀐 것이다!

지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있다. 이것은 C++에서 보장하는 사실이며, 위의 방법은 바로 그 사실을 이용한 것이다. 

물론 초기화 순서 문제를 방지하기 위해 참조자 반환 함수를 사용하는 아이디어는 여러분이 객체들의 초기화 순서를 제대로 맞춰 둔다는 전제조건이 뒷받침되어 있어야 한다.

> 기본제공 타입의 객체는 직접 손으로 초기화한다. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문이다.

> 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열합시다.

> 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.