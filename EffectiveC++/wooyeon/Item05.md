# Effective C++
## 2장. 생성자, 소멸자 및 대입 연산자
### 항목 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

C++(컴파일러)가 빈 클래스를 훑고 지나갈 때, 클래스는 비어 있지만 비어 있는 게 아니다. C++의 어떤 멤버 함수는 여러분이 클래스 안에 직접 선언해 넣지 않으면 컴파일러가 저절로 선언해 주도록 되어있다. 바로 복사 생성자, 복사 대입 연산자, 그리소 소멸자가 그러한데, 좀더 자세히 말하면 이때 컴파일러가 만드는 함수의 형태는 모두 기본형이다. 게다가, 생성자조차도 선언되어 있지 않으면 역시 컴파일러가 여러분 대신에 기본 생성자를 선언해 놓는다.

그렇다면 컴파일러가 만드는 함수가 하는 일이 대체 무엇이길래 저절로 만들어지기까지 할까? 기본 생성자와 소멸자가 하는 일은 일차적으로 컴파일러에게 "배후의 코드"를 깔 수 있는 자리를 마련하는 것이다. 기본 클래스 및 비정적 데티어 멤버의 생성자와 소멸자를 호출하는 코드가 여기서 생기는 것이다. (이때 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 가상 소멸자로 되어 있지 않으면 역시 비가상 소멸자로 만들어진다.)

컴파일러가 몰래 만들어낸 복사 생성자/복사 대입 연산자가 하는 일은 단순하다. 원본 객체의 비정적 데이터를 사본 객체 쪽으로 그냥 복사하는 것이다.

참조자를 데이터 멤버로 갖고 있는 클래스에 대입 연산을 지원하려면 여러분이 직접 복사 대입 연산자를 정의해 주어야 한다. 데이터 멤버가 상수 객체인 경우에도 C++ 컴파일러가 비슷하게 동작하니 주의하자. 상수 멤버를 수정하는 것은 문법에 어긋나기 때문에, 자동으로 (컴파일러에 의해) 만들어진 암시적 복사 대입 연산자의 내부에서는 상수 멤버를 어떻게 처리해야 할지 애매해졌다.

> 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.