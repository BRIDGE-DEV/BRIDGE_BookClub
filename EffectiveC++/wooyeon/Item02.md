# Effective C++
## 1장. C++에 왔으면 C++의 법을 따릅시다.
### 항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자

```cpp
#define ASPECT_RATIO = 1.653
```
이라는 코드를 썼다고 가정하자. 우리에겐 `ASPECT_RATIO`가 기호식 이름으로 보이지만 컴파일러에겐 전혀 보이지 않는다. 소스 코드가 어떻게든 컴파일러에게 넘어가기 전에 선행 처리자가 밀어버리고 숫자 상수로 바꾸어 버리기 때문이다. 그래서 숫자 상수로 대체된 코드에서 컴파일 에러라도 발생하게 되면 꽤나 헷갈릴 수 있다. 소스 코드엔 `ASPECT_RATIO`가 있었는데 에러 메시지엔 1.653이 있으니까. 행여 여러분이 작성한 것이 아니라면 대체 1.653이 어디에서 왔는지 모를 수 있고, 이것을 찾아 들어가느라 시간을 허비할 수도 있다. 이 문제는 기호식 디버거에서도 나타날 수지가 있다.

이 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.
```cpp
const double AspectRatio = 1.653;
```
`AspectRatio`는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일러의눈에도 보이며 기호 테이블에도 당연히 들어간다. 게다가 상수가 부동소수점 실수 타입일 경우에는 컴파일을 거친 최종 코드의 크기가 #define을 썼을 때보다 적게 나올 수 있다. 매크로를 쓰면 코드에 `ASPECT_RATIO`가 등장하기만 하면 선행 처리자에 의해 1.653으로 모두 바뀌면서 결국 목적 코드 안에 1.653의 사본이 등장 횟수만큼 들어가게 되지만, 상수 타입의 `AspectRatio`는 아무리 여러 번 쓰이더라도 사본은 딱 한 개만 생기기 때문이다.

#define을 상수로 교체할 때에는 두 가지 경우를 특별히 조심해야 한다.

첫째는 상수 포인터를 정의하는 경우다. 상수 정의는 대개 헤더 파일에 넣는 것이 상례이므로 포인터는 꼭 const로 선언해 주어야 하고, 이와 아울러 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다. (문자열 상수를 쓸 때 char* 기반의 구닥다리 문자열보다는 string 객체가 대체적으로 사용하기 좋다.)

```cpp
const char * const authorName = "Scott Meyers"; // X
const std::stringchar * const authorName = "Scott Meyers"; // O
```

두 번째 경우는 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우이다. 어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들어야 하는데, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적 멤버로 만들어야 한다.

```cpp
class GamePlayer {
   private:
      static const int NumTurns = 5;
      int scores[NumTurns];
}
```

여기서 `NumTurns`는 '정의'가 아닌 '선언'이다. C++에서는 여러분이 사용하고자 하는 것에 대한 정의가 마련되어야 있어야 하는 것이 보통이지만, 정적 멤버로 만들어지는 정수류(각종 정수 타입, char, bool) 타입의 클래스 내부 상수는 예외이다. 이들에 대해 주소를 취하지 않는 한, 정의 없이 선언만 해도 아무 문제가 없게 되어있다.

단, 클래스 상수의 주소를 구한다던지, 정의를 제공해야 할 때는 아래와 같이 사용한다.

```cpp
const int GamePlayer::NumTurns;
```

이때 클래스 상수의 정의는 헤더 파일이 아닌 구현 파일에 둔다. 정의에는 상수의 초기값이 있으면 안되는데, 왜냐하면 클래스 상수의 초기값은 해당 상수가 선언된 시점에서 바로 주어지기 때문이다.

클래스 상수를 #define으로 만드면 안되는 이유는 #define은 유효범위가 뭔지도 모르고, 매크로는 일단 정의되면 컴파일이 끝날 때까지(중간에 #undef되지만 않으면) 유효하기 때문이다. 정리하면 #define은 클래스 상수를 정의하는 데 쓸 수도 없을 뿐만 아니라 어떤 형태의 캡슐화 혜택도 받을 수 없다. ('private' 성격의 #define 같은 것은 없다.) (물론 이와 대조적으로 상수 데이터 멤버는 캡슐화가 된다. NumTurns처럼)

#define 지시자의 또 다른 오용 사례는 매크로 함수이다.

```cpp
#define CALL_WITH_MAX(a, b) f((a)>(b)?(a):(b));
```
이런 식의 매크로는 단점이 한두 개가 아니다.
이런 매크로를 작성할 때는 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워 줘야 한다. (안 되어 있으면 표현식을 매크로에 넘길 때 골치 아픈 일이 발생할 수 있다.)

```cpp
int a=5, b=0;
CALL_WITH_MAX(++a, b); // a가 두번 증가
CALL_WITH_MAX(++a, b+10); // a가 한번 증가
```
_매크로는 단순히 텍스트 치환이기 때문에 두 번째 줄의 경우 `f((++a) > (b) ? (++a) : (b));` 이런 식으로 작동하기 때문에 문제가 됨_

기존 매크로의 효율을 그대로 유지함은 물론 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이 있다. 바로 함수에 대한 템플릿을 준비하는 것이다.

```cpp
template<typename T>
inline void callWithMax(const T& a, const T& b)
{
   f(a > b ? a : b);
}
```
이 함수는 템플이기 때문에 동일 계열 함수군을 만들어낸다. 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조이다. 함수 본문에 괄호로 분칠할 필요도 없고, 인자를 여러 번 평가할지도 모른다는 걱정도 없어진다. 또한 `callWithMax`는 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라간다.

const, enum, inline을 늘 유념해 두면, 선행 처리자(특히 #define)를 꼭 써야 하는 경우가 많이 줄어들게 된다.

> 단순한 상수를 쓸 때는 #define보다 const 객체 혹은 enum을 우선 생각하자

> 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자