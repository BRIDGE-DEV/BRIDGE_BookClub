# Effective C++
## 1장. C++에 왔으면 C++의 법을 따릅시다.
### 항목 3: 낌새만 보이면 const를 들이대 보자!

const의 멋진 부분은 '의미적인 제약'(const 키워드가 붙은 객체는 외부 변경을 불가능하게 한다.)을 소스 코드 수준에서 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점일 것이다. 어떤 값이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있는 수단인 것이다.

const는 유용하다. 클래스 바깥에서는 전역 혹은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있다. 그뿐 아니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있다. 클래스 내부의 경우에는, 정적 멤버 및 비정적 데이터 멤버를 모두 상수로 선언할 수 있다. 

포인터의 경우 포인터 자체를 상수로, 혹은 포인터가 가리키는 데이터를 상수로 지정할 수 있는데, 둘 다 지정할 수도 있고 아무것도 지정하지 않을 수도 있다. const 키워드가 *에 있으면 포인터가 가리키는 대상이 상수, const가 *의 오른쪽에 있으면 포인터 자체가 상수, const가 *표의 양쪽에 다 있으면 포인터가 가리키는 대상 및 포인터가 다 상수이다.
(타입 앞에 const를 붙이든 타입 뒤쪽이자 *의 앞에 const를 붙이든 의미적인 차이는 전혀 없다.)

STL 반복자는 포인터를 본뜬 것이기 때문에 기본적인 동작 원리가  T* 포인터와 흡사하다. 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉, T* const 포인터)과 같다.
반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만, 반복자가 가리키는 대상 자체는 변경이 가능하다. 만약 변경이 불가능한 객체를 가리키는 반복자가 필요하다면 const_iterator를 쓰면 된다.

const의 가장 강력한 용도는 함수 선언에 쓸 경우이다. 함수 선언문에 있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체에 대해 const 성질을 붙일 수 있다.

```cpp
class Rational {...}
const Rational operator*(const Rational& lhs, const Rational& rhs);
```
_(매개변수가 const면 값이 아닌 참조에 의한 복사가 되므로 비용이 줄어듦)_

함수 반환 값을 상수로 정해 주면, 안전성이나 효율을 포기하지 않고도 사용자측의 에러 돌발 상황을 줄이는 효과를 꽤 자주 볼 수 있다. (e.g., `a\b==c`를 실수로 `a\b=c`로 한 경우..)

#### 상수 멤버 함수

멤버 함수에 붙는 const 키워드의 역할은 "해당 멤버 함수가 상수 객체에 대해 호출될 함수이다"라는 사실을 알려 주는 것이다. 이런 함수가 중요한 이유는 두 가지다.

첫째는 클래스의 인터페이스를 이해하기 좋게 하기 위해서이다. 둘째는 이 키워드를 통해 상수 객체를 사용할 수 있게 하자는 것인데, 코드의 효율을 위해 아주 중요한 부분이기도 하다.

C++ 프로그램의 실행 성능을 높이는 핵심 기법 중 하나가 객체 전달을 '상수 객체에 대한 참조자'로 진행하는 것이기 때문에, 이 기법이 제대로 살아 움직이려면 상수 상태로 전달된 객체를 조작할 수 있는 const 멤버 함수(상수 멤버 함수)가 준비되어 있어야 한다는 것이 포인트이다.
(실제 프로그램에서 상수 객체가 생기는 경우는 (1) 상수 객체에 대한 포인터 혹은 (2) 상수 객체에 대한 참조자로 객체가 전달될 때이다)

어떤 멤버 함수가 상수 멤버라는 것이 어떤 의미일까? 하나는 비트수준 상수성(bitwise/physical constness)이고, 또 하나는 논리적 상수성(logical constness)이다.

비트수준 상수성은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 'const'임을 인정하는 개념이다. (사실 C++에서 정의하고 있는 상수성이 비트수준 상수성이다.)

그런데 사실 '제대로 const'로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 적지 않다. '어떤 포인터가 가리키는 대상을 수정하는 멤버 함수'들 중 상당수가 그러하다. 하지만 그 포인터가 객체의 멤버로 들어있는 한, 이 함수는 비트수준 상수성을 갖는 것으로 판별되고 컴파일러도 불평하지 않는다. 그런데 이것 때문에 상식적으로 이해가 안 되는 동작이 생길 수도 있다.

논리적 상수성이란 개념은 이런 황당한 상황을 보완하는 대체 개념으로 나오게 됐다. 상수 멤버여도 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것이다.
하지만 컴파일러의 검열을 통과하려면 비트 수준의 상수성이 지켜져야 한다. 해답은 `mutable`이다. mutable은 비정적 데이터 멤버를 비트수준 상수성의 족쇄에서 풀어주는 키워드이다.

#### 상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법

mutable은 '생각지도 않던 비트 수준 상수성이 웬 말이냐'란 문제를 해결하는 꽤 괜찮은 방법이지만 이것으로 const에 관련된 골칫거리 전부를 말끔히 씻어내진 못한다.

여러가지 코드를 operator[]의 상수/비상수 버전에 넣어버리면 무시무시한 코드 중복이 생긴다. 코드 중복에는 컴파일 시간, 유지보수, 코드 크기 부풀림 등의 문제들이 따라온다.

operator[]의 핵심 기능을 한 번만 구현해 두고 두 번 사용할 수 있다면 어떨까? 그러니까, operator[]의 한 버전만 제돼로 만들고 다른 버전은 이것을 호출하는 식이다. const 껍데기를 캐스팅으로 날리면 어떨까.

캐스팅은 일반적으로도 통념적으로도 좋은 아이디어는 아니다. (항목 27에서는 이를 하지 말라는 이야기를 다룬다.) 그러나 캐스팅이 필요하긴 하지만, 안전성도 유지하면서 코드 중복을 피하는 방법은 비상수 operator[]가 상수 버전을 호출하도록 구현하는 것이다.

문법이 이상해 보이기도 하지만 코드 중복을 피하지는 원하는 효과는 얻을 수 있다. 이 방법에 대한 판단은 여러분의 몫이지만 비상수 멤버 함수의 구현에 상수 멤버 쌍둥이를 사용하는 기법 자체는 꼭 알아둘 가치가 있다.

반대 방법(상수 버전이 비상수 버전을 호출)하는 것도 생각할 수 있는데, 그것은 우리가 원하는 바가 아니다. 상수 멤버 함수는 해당 객체의 논리적인 상태를 바꾸지 않겠다고 컴파일러와 약속했기 때문이다. 이는 위험한 방법이다.

아무튼, 할 수 있으면 const를 남발하자.

> const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.

> 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만 여러분은 개념(논리)적인 상수성을 사용해서 프로그래밍해야 한다.

> 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하게 만들어라.