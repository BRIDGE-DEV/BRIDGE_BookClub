# Item6~10

### ***6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해버리자***

- **내용**:
    - 컴파일러가 자동으로 생성하는 함수(기본 생성자, 복사 생성자, 대입 연산자, 소멸자)가 필요하지 않다면, 이들의 사용을 **명시적으로 금지**해야 한다.
    - 클래스에 따라서는 컴파일러가 자동 생성하는 함수들이 불필요하거나 잘못된 동작을 초래할 수 있다.
    - 특히 **자원 소유 클래스(**동적 할당 자원을 사용하는 클래스**)**에서는 컴파일러가 생성한 복사 생성자와 대입 연산자가 문제를 일으킬 수 있다.
- **해결책**:
    - 다형성을 위한 클래스에서는 반드시 **가상 소멸자**를 사용하여, 파생 클래스의 소멸자가 올바르게 호출되도록 해야 한다.
    - C++11부터는 더 이상 불필요한 복사 생성자나 대입 연산자를 수동으로 구현할 필요 없이, 명시적으로 컴파일러가 생성하는 함수들을 금지(`delete`)하거나, 명시적으로 디폴트 함수(`default`)를 지정할 수 있다.
    - 예시
        
        ```cpp
        class Example {
        public:
            Example() = default;                      // 기본 생성자 명시적 허용
            Example(const Example&) = delete;         // 복사 생성자 삭제
            Example& operator=(const Example&) = delete; // 대입 연산자 삭제
        };
        ```
        

---

### ***7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자***

- **내용**:
    - 다형성을 사용하는 클래스에서는 소멸자를 가상 소멸자로 선언해야 한다.
    - 다형성을 가지는 클래스에서는 **기본 클래스**의 포인터를 통해 파생 클래스 객체를 삭제할 수 있다.
    - 이때 소멸자가 가상 함수가 아니면, 파생 클래스의 소멸자가 호출되지 않아 **메모리 누수**와 같은 자원 관리 문제를 일으킬 수 있다.
- **해결책**:
    - 다형성을 위한 클래스에서는 반드시 **가상 소멸자**를 사용하여, 파생 클래스의 소멸자가 올바르게 호출되도록 해야 한다.
    - C++11 이후, 가상 함수와 관련된 오류를 방지하기 위해, `override`와 `final` 키워드를 사용할 수 있다.
    - `override`는 재정의 한 함수가 실제로 베이스 클래스의 가상 함수를 덮어쓰는지 컴파일러가 확인하게 하고, `final` 키워드는 더 이상 파생 클래스를 만들지 않도록 방지한다. 이를 통해 다형성 계층에서 가상 함수의 재정의 및 종결을 명확히 표시할 수 있으며, 특히 소멸자를 가상으로 선언할 때 유용하게 사용할 수 있다.
    - 예시
        
        ```cpp
        class Base {
        public:
            virtual ~Base() = default;  // 가상 소멸자
            virtual void doSomething() const = 0;
        };
        
        class Derived final : public Base {
        public:
            ~Derived() override = default;  // override 사용
            void doSomething() const override { /* 구현 */ }
        };
        ```
        

---

### ***8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자***

- **내용**:
    - C++에서는 소멸자가 호출될 때 예외가 발생하더라도 **예외를 전파해서는 안된다.**
    - 소멸자가 호출되는 시점에서 예외가 발생하고, 동시에 다른 예외도 활성화 상태라면, 프로그램이 비정상적으로 종료된다.
- **해결책**:
    - 소멸자 내부에서 예외가 발생할 가능성이 있으면, 그 예외를 처리하고 **무시하거나** 예외를 기록하는 식으로 처리해야 한다. (try, catch, abort)
    - 소멸자에서 예외가 발생하지 않도록 보장하는 대신, C++11부터는 **`noexcept`** 키워드를 소멸자에 붙여 예외가 발생하지 않음을 컴파일러에 명시할 수 있다. 이는 표준 라이브러리 컨테이너에서 사용될 때 성능 최적화에 도움을 준다.
    - 예시
    
    ```cpp
    class Example {
    public:
        ~Example() noexcept {  // 소멸자는 예외를 발생시키지 않음을 보장
            // 자원 해제 작업
        }
    };
    ```
    

---

### **9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자**

- **내용**:
    - **생성자**와 **소멸자**에서 가상 함수를 호출하지 말라. **예상치 못한 동작**이 발생할 수 있다.
    - 생성자나 소멸자가 호출되는 동안에는 객체가 아직 **완전히 초기화되지 않거나**, 이미 일부가 소멸된 상태일 수 있어, 파생 클래스의 가상 함수가 의도대로 동작하지 않을 수 있습니다.
- **해결책**:
    - 생성자나 소멸자 내에서는 가상 함수를 호출하지 않고, 필요한 작업은 나중에 객체가 완전히 생성된 후에 처리하도록 해야 한다.
    - 객체 생성 및 소멸 시 가상 함수를 호출하지 않으려면, **스마트 포인터**를 이용해 객체 관리와 수명을 제어할 수 있다. 특히 `shared_ptr`와 `make_shared`는 안전하게 객체를 생성 및 관리하면서 자원의 수명 관리에 도움을 준다.
    - 스마트 포인터는 객체의 소멸 시점을 명확히 제어할 수 있으며, 특히 **소멸자의 가상 함수 호출 문제를 피할 수 있는 방식**을 제공한다. C++20에서는 `make_unique`도 사용할 수 있다.
    - 예시
    
    ```cpp
    class Base {
    public:
        virtual void doSomething() const = 0;
    };
    
    std::shared_ptr<Base> createObject() {
        return std::make_shared<Derived>();  // 안전하게 객체 생성 및 관리
    }
    ```
    

---

### *10: 대입 연산자는 this의 참조자를 반환하게 하자*

- **내용**:
    - 대입 연산자(`operator=`)를 구현할 때는 **반환 값으로 `this`의 참조**를 반환해야 한다는 내용.
    - 대입 연산자가 자기 자신을 참조하는 `this`를 반환하면, **연속된 대입**(예: `a = b = c`)이 가능하다. 이는 C++에서 대입 연산자가 기대하는 기본적인 동작 방식.
- **해결책**:
    - 대입 연산자에서 반환 값으로 `this`를 반환하여 연쇄적인 대입을 가능하게 해야한다.
    - C++11에서는 **이동 연산자**와 **이동 생성자**를 활용하여 더 나은 성능을 낼 수 있다. 또한 복사 대입 연산자와 마찬가지로 `default`로 기본 이동 연산자를 컴파일러에게 위임할 수 있다.
    - 예시
    
    ```cpp
    class Example {
    private:
        int* data;
    public:
        Example(Example&& other) noexcept : data(other.data) {
            other.data = nullptr;  // 소유권 이전 후 원본 무효화
        }
    
        Example& operator=(Example&& other) noexcept {
            if (this != &other) {
                delete data;         // 기존 자원 해제
                data = other.data;   // 소유권 이동
                other.data = nullptr;  // 원본 무효화
            }
            return *this;
        }
    };
    ```
    

---