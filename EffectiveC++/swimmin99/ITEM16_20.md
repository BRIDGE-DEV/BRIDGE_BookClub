## Item16
- `new` 연산자 사용 시:
  - 객체가 메모리에 할당됨(`operator new` 함수 사용).
  - 할당된 메모리에 대해 한 개 이상의 생성자가 호출됨.
  
- `delete` 표현식 사용 시:
  - 기존에 할당된 메모리에 대해 한 개 이상의 소멸자가 호출됨.
  - 메모리가 해제됨.

### 객체 메모리 배치 구조
1. **객체**: 객체 그 자체만 존재.
2. **객체 배열**: 배열에 대한 정보(배열 사이즈)가 레이아웃에 포함됨.

#### 예시
`string*`로 `stringArray`를 가리킬 때 `delete` 할 경우, 배열을 제대로 인식하지 못하면 문제가 생길 수 있다.
- 배열을 삭제할 때는 `delete[]`를 사용해야 배열 사이즈를 인식하고 올바르게 해제한다.
- `delete[]`를 사용하지 않으면 배열 전체가 아닌 첫 번째 객체만 삭제된다.

---

## Item17
- 자원을 객체로 관리하기 위해 `shared_ptr`을 사용하는 것이 좋다.
- `shared_ptr` 생성자가 `explicit`이므로 `processWidget(new Widget, priority())` 호출 시 실패.
- `processWidget(shared_ptr<Widget>(new Widget), priority()); 시 가능.
- 그러나 컴파일러마다 함수 호출 순서가 다를 수 있어 여기서도 예외 발생 가능성이 존재한다.
-> processWidget을 하기 위해서 priority()를 호출하고, new Widget을 실행하고 shared_ptr 생성자를 호출해야한다.
  컴파일러는 이 세 task의 실행 순서를 저마다 다르게 해석할 수 있기에, priority()에서 예외가 발생하면, 자원이 유실될 수 있다.

### 안전한 방법
1. `new`로 생성한 객체를 변수에 담는다.
2. 그 다음에 `shared_ptr` 생성자로 넘겨준다.

#### 예시
```cpp
Widget* w = new Widget;
shared_ptr<Widget> sp(w);
```
이렇게 하면 함수 호출 순서에 따른 예외 발생을 방지할 수 있다.


# CH4.

## Item18

인터페이스(개념)는 실수하기 어렵게 설계한다. -> 의도 하지 않은 대로 사용할 시 컴파일 되지 않도록 한다.

#### 예시
Date 3 (30, 3, 1995)의 경우보다
struct나 class로 Day, Month, Year로 래핑을 하여 타입으로 만들어준다. (이렇게 되면 각 타입마다의 제약 사항을 넣을 수도 있다.)

또한 객체를 사용하지 않고, 함수를 사용하는 것도 좋은 방법이다 (비지역 정적 객체의 경우 초기화에 문제 발생 가능)

이외에도 const를 붙여서 강제로 사용 법의 제약을 주는 것도 좋은 방식이다.
또한 STL이 인터페이스를 일관성 있게 만들었듯이 일관성을 유지하려고 노력하고, 기본제공 타입과의 동작 호환성 유지하고, 관리를 사용자에 넘기지 않는 게 좋다.

​

## Item19

C++로 클래스를 정의하는 것은 타입을 하나 정의하는 것과 같다.
따라서 타입 시스템을 제대로 구축하는 것이 C++ 프로그래머의 역할이다.

#### 좋은 타입 설계 고려할 점

1) 생성 및 소멸
2) 객체 초기화와 객체 대입 
3) 값에 의해 전달될 때 어떤 의미(복사 생성자)
4) 새로운 타입이 가질 수 있는 값에 대한 제약
5) 기존 클래스 상속 계통망에 맞출 것인지
6) 어떤 타입 변환을 허가할 것인지
7) 어떤 연산자와 함수를 둘지
8) 표준 함수들 중 어떤 것을 허용하지 말지
9) 새로운 타입의 멤버에 대한 접근권한을 어느쪽에 줄 것인지
10) 선언되지 않은 인터페이스로 무엇을 둘 것인지
11) 얼마나 일반적이어야 할 것인지
12) 꼭 필요한지...

​

## Item20
#### 결론
상수 객체 참조자에 의한 전달이 대부분 낫다.
#### 케이스
- 값전달(함수 매개변수) : (C++에서 기본적으로 사용) 넘겨지는 매개변수는 실제 인자의 사본을 통해 초기화 되고, 어떤 함수를 호출 한 쪽은 그함수가 반환한 값의 사본을 돌려받는다. (복사 생성자 사용) - 타고타고 가면서 다불림 (고비용 연산)

- 참조자에 의한 전달 : 복사 손실 문제도 없음(기본 객체로 전달시 값 복사는 객체가 slice 될 가능성 존재)

- 참조자는 포인터를 전달하는 것과 유사함

- 이외의 경우 : 반복자와 함수 객체는 값 전달이 효율


​
