Item16

new/delete를 사용할 경우 타입 맞추기가 어렵다. 항상 주의 해야 한다.
new 연산자 사용 시 : 어떤 객체가 메모리에 할당됨(operator new 함수 사용) -> 할당된 메모리에 대해 한 개 이상의 생성자가 호출 됨.
delete 표현식 사용 시 : 기존에 할당된 메모리에 대해 한개 이상의 소멸자가 호출 -> 메모리 해제
- 객체 메모리의 배치구조
- 1) 객체 : 객체 그 자체만 존재
  2) 객체 배열 : 배열에 대한 정보(배열 사이즈)가 layout에 포함
따라서 아래와 같은 경우라면 유의해야 한다.
사례) string*로 stringArray를 가리킬때 delete할 경우 
delete를 할 경우 delete 연산자 뒤에 []를 붙여주지 않으면, 객체가 배열로 존재한다는 것을 인지하지 못한다.
반대로 []를 붙여 줄 경우에는 포인터를 가리킨다는 것을 인지하고 레이아웃에서 배열 정보를 가져와 사이즈 만큼 할당 해제를 한다. 따라서 []를 잘 넣어주도록 한다.

​

Item17 
사례) 자원을 객체로 관리하기 위해 매개변수로 동적생성한 객체를 넘길 때 shared_ptr을 사용하는 경우.
1) 스마트 포인터 shared ptr
- 생성자가 explicit이기에, 함수 호출 시 (new Widget) 하면 실패한다.
- 컴파일러마다, 호출 순서가 정해져 있지 않기에, 만약 인수가 두개이고 shared_ptr<Widget>(new Widget, priority())로 되어 있는 경우에는 new Widget의 실행과 shared_ptr 생성자의 실행 사이에 piority 함수가 호출 될 수 있어 예외 발생에 대해서 무방비 상태이다.
가장 안전한 방법 : new로 생성한 객체를 변수에 담고 그 다음에 넘겨준다.

기억해야 할 것은 컴파일러에 따라 인수로 넘겨지는 함수 호출 순서가 다를 수 있다는 사실이다. 
따라서 예외가 끼어들 수 있는 여지가 생긴다. 이럴 땐 따로 스마트 포인터와 같은 객체를 저장하는 라인을 두고 저장한 객체를 인수로 넘기는게 안전하다.

​

CH4.

Item18

인터페이스(개념)는 실수하기 어렵게 설계한다. -> 의도 하지 않은 대로 사용할 시 컴파일 되지 않도록 한다.
예)
Date 3 (30, 3, 1995)의 경우보다
struct나 class로 Day, Month, Year로 래핑을 하여 타입으로 만들어준다. (이렇게 되면 각 타입마다의 제약 사항을 넣을 수도 있다.)
또한 객체를 사용하지 않고, 함수를 사용ㅇ하는 것도 좋은 방법이다 (비지역 정적 객체의 경우 초기화에 문제 발생 가능)
이외에도 const를 붙여서 강제로 사용 법의 제약을 주는 것도 좋은 방식이다.
또한 STL이 인터페이스를 일관성 있게 만들었듯이 일관성을 유지하려고 노력하고, 기본제공 타입과의 동작 호환성 유지하고, 관리를 사용자에 넘기지 않는 게 좋다.

​

Item19

C++로 클래스를 정의하는 것은 타입을 하나 정의하는 것과 같다.
따라서 타입 시스템을 제대로 구축하는 것이 C++ 프로그래머의 역할이다.

좋은 타입 설계 고려할 점

1) 생성 및 소멸
2) 객체 초기화와 객체 대입 
3) 값에 의해 전달될 때 어떤 의미(복사 생성자)
4) 새로운 타입이 가질 수 있는 값에 대한 제약
5) 기존 클래스 상속 계통망에 맞출 것인지
6) 어떤 타입 변환을 허가할 것인지
7) 어떤 연산자와 함수를 둘지
8) 표준 함수들 중 어떤 것을 허용하지 말지
9) 새로운 타입의 멤버에 대한 접근권한을 어느쪽에 줄 것인지
10) 선언되지 않은 인터페이스로 무엇을 둘 것인지
11) 얼마나 일반적이어야 할 것인지
12) 꼭 필요한지...

​

Item20

상수 객체 참조자에 의한 전달이 대부분 낫다.
값전달(함수 매개변수) : (C++에서 기본적으로 사용) 넘겨지는 매개변수는 실제 인자의 사본을 통해 초기화 되고, 어떤 함수를 호출 한 쪽은 그함수가 반환한 값의 사본을 돌려받는다. (복사 생성자 사용) - 타고타고 가면서 다불림 (고비용 연산)
참조자에 의한 전달 : 복사 손실 문제도 없음(기본 객체로 전달시 값 복사는 객체가 slice 될 가능성 존재)
참조자는 포인터를 전달하는 것과 유사함
이외의 경우 : 반복자와 함수 객체는 값 전달이 효율

​
