Item5

없으면 컴파일러가 만드는 함수들 : 컴파일러에게 배후의 코드를 깔 수 있는 자리를 마련하는 것

기본 생성자 : 객체 멤버 변수를 초기화

복사 함수들(Item12) : 복사 생성자, 복사 대입 연산자

소멸자 : 기본 클래스의 소멸자가 가상소멸자가 아니면 비가상 소멸자로 생성됨

​

Item6

생성되지 않아야 할 함수라면(컴파일러 발), 선언만 남기고(구현 X) private화 한다. 
신박하지만? -> 이제 delete 키워드 가능 (STL관련, 스마트 포인터 관련 처리를 보다가 delete를 발견한 기억!)

​

Item7

비가상 소멸자 : base 클래스로 쓰일 의지를 상실

사례 : 기본 클래스의 포인터 변수에 자식 클래스 객체를 얻어 사용한 후 삭제시(기본 클래스 포인터로 삭제될 시) 기본 클래스의 소멸자가 비 가상 소멸자일 경우, 기본 클래스의 소멸자만 불려 덜 지워짐

그렇다고 가상 소멸자를 무조건 붙이면, 이식성이 낮아지고 용량 차지만 늘어남

Item8

소멸자에서 예외가 빠져나가지 못하도록 -> 소멸자에서 모두 받아낸 후에 삼키거나 프로그램 종료

​

Item9

객체 생성 시 가상함수 호출 X

사례 : 기본 클래스의 생성자에서 순수 가상함수를 부를 때, 자식 클래스에서 해당 순수 가상함수를 정의할 경우.

(객체 생성시 기본 클래스부터 생성됨) 순수 가상함수를 부를 수 없다(아직까지는 현재 객체는 기본 클래스기 때문)

소멸될 경우 : 파생 클래스의 소멸자가 호출되고 나면 파생 클래스만의 데이터 멤버는 비워지기에 없는 것으로 취급해야 한다. 따라서 이 때도 가상함수를 무턱대고 불러선 안된다.

​

Item10

대입 연산자의 경우 규약에 따르기 위해서 *this 참조자를 반환해야 한다. (대입 사슬 지원)

​
