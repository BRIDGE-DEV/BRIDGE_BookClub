Item11 

자기에 대한 대입을 따로 처리하지 않으면 위험할 수 있다.
중복참조 : 여러 곳에서 하나의 객체를 참조하는 상태(aliasing)
객체로 자원을 관리할 때 자기 대입에 대한 처리를 빼먹지 않아야 한다.
사례)
Widget::operator=(const Widget& rhs){
  delete pb;
  pb = new Bitmap(*rhs.pb);
  
  return *this;
}
​ 이러한 상황에서, *this와 매개변수 rhs가 같다면
  delete pb;
 이 줄은, 자기 자신을 파괴하는 동시에 매개변수로 넘어온 위젯의 pb 포인터 변수도 파괴하고 만다.
방법1) 일차성 검사
if(this == &rhs) return *this;
자기대입을 점검한다.

이외에도 예외에 대한 처리 또한 신경써야 하나, 이는 Item29에서 깊게 다룬다.

Item12

복사 함수가 부분 복사되지 않도록 조심해야 한다. 전체를 다 복사해야 한다. 
-> 부분 복사가 일어나도 컴파일러가 경고를 주지 않는다! 컴파일러가 자동생성해주는 함수를 구현하려는 것이기에! (지금도 그럴까?)

따라서 해당 객체의 데이터 멤버를 모두 복사하고, 기본 클래스의 본사 함수도 호출해 주어야 함.
classB:ClassB9const ClassB& rhs) : ClassA(rhs)
복사 생성자와 복사 대입 연산자는 본문이 비슷하게 나오는 경우가 많으나, 둘의 역할이 서로 다르기에, 한쪽으로 다른 쪽을 호출하는 식으로 접근해선 안된다.
공통 기능을 따로 멤버 메서드로 빼는 방식은 괜찮다.
복습
 복사 생성자 : 새로 만들어진 객체를 초기화 하는 것. 원본 객체의 비정적 데이터를 사본 객체 쪽으로 복사하는 것
 복사 대입 연산자 : 이미 초기화된 객체에 적용되는 대입 연산.

​

CH3 자원관리

Item13
자원을 관리할 때는 객체를 사용한다
1) 자원 획득한 후 자원관리 객체에게 바로 넘긴다
RAII : 자원 획득 즉 초기화 (생성자 안에서 자원을 획득하고, 획득된 자원을 소멸자에서 해제하는 객체)
2) 자원 관리 객체는 자신의 소멸자를 사용해 자원을 확실히 해제 한다
보통 사용자는 raw 포인터에 동적할당한 메모리에 대한 할당 해제를 까먹는다. (중간에 많은 로직이 들어갈 경우)
따라서 객체를 사용해 관리하면, 스코프(유효범위)가 끝날 때 자연스레 해제되도록 소멸자에서 해제해주도록 한다-> 스마트 포인터 (auto_ptr의 구현(deprecated))
따라서 이런 경우 대비를 위해 반환 타입을 포인터가 아닌 스마트 포인터로 하면 좋다.

​RCSP : 레퍼런스 카운팅 방식으로, 개수가 0이 되면 해당 자원을 삭제한다.
GC와 부분적으로 유사할 수 있으나, (순환 참조를 해결하지 못한다는 의미에선 다르다) 전체적으로는 많이 다르다
shared_ptr이 사용하는 방식이다.

추가로 알아둘 점은, 두 포인터 모두 delete[]가 아닌 delete를 사용하기에 배열 할당 해제에 대해서는 명시적으로 타입에 []를 넣어주어야 한다.

Item14
힙에서 관리되지 않는 객체의 경우 


RAII 객체가 복사 될경우 처리 방법

1) 복사를 금지
복사해서는 안되는 객체에 대해서는 복사를 금지하는 게 맞다. (복사 함수 선언에 delete, 혹은 private 후 구현X)

2) 참조 카운팅 수행 : shared_ptr의 방식
-> 어! mutex도 참조 카운팅 쉽게 사용하려면 (shared_ptr)로 담으면 되지 않나? -> 삭제되니까 그냥은 안된다
shared_ptr의 삭제자를 지정하여 넘겨주면 (두번째 매개변수) 가능
class Lock {
public : 
explicit Lock(Mutex *pm) : mutextPtr(pm, unlock)//삭제자 전달 
{
  lock(mutexPtr.get());
}
private:
std::shared_ptr<Mutex> mutexPtr;
}

3) 관리하고 있는 자원을 깊은 복사
 실제로 string 타입이 이러한 방식으로 구현되어 있는 경우가 존재. 
4) 관리 자원의 소유권 자체를 옮김
 auto_ptr의 복사 방식

​

Item15

자원객체를 만들 때
보통은 Get함수를 통해 명시적 변환을 열어주는게 낫다
명시적 변환 예
class Font{
private:FontHandle f;

FontHandle get() const {return f;}
}
암시적 변환 예
class Font{
private:FontHandle f;

operator FontHandle() const { return f;}
}
그러나 이러한 경우 사용자가 의도하지 않은 동작이 일어날 수 있다.
Font f1(getFont());
'''
FontHandle f2 = f1;
자동으로 Font 객체인 f1이 f2로 사용가능한 상태가 되어, 한 자원이 여러 객체에 접근가능해진다. -> 댕글링 포인터
그러니, 환경과 사용용도에 맞게 잘 선택해서 쓰자.
