## 항목 3: 낌새만 보이면 const를 들이대 보자!
const는 어떤 값이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있는 수단이다.

### 클래스 바깥 const
전역 혹은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있다.
파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있다.

### 클래스 내부 const
정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수 있다.
포인터 자체, 포인터가 가리키는 데이터를 상수로 지정할 수 있다. 둘 다 지정할 수도, 지정하지 않을 수도 있다.

```cpp
char greeting[] = "Hello";
char *p = greeting;					// 비상수 포인터, 비상수 데이터

const char *p = greeting;			// 비상수 포인터, 상수 데이터

char * const p = greetng;			// 상수 포인터, 비상수 데이터

const char * const p = greeting;	// 상수 포인터, 상수 데이터
```

const가 * **왼쪽**에 있으면 **포인터가 가리키는 대상**이 상수, **오른쪽**에 있으면 **포인터 자체**가 상수, **양쪽**에 다 있으면 **포인터가 가리키는 대상 및 포인터가 상수**이다.

### STL 반복자(iterator)
포인터를 본뜬 것이기 때문에, 동작 원리가 T* 포인터와 흡사하다.
반복자를 const로 선언하는 것은 포인터를 상수로 선언하는 것과 같다.
반복자는 자신이 가리키는 대상이 아닌 것을 가리킬 수 없다. 그러나, 반복자가 가리키는 대상 자체는 변경 가능하다.
**const_iterator**는 변경이 불가능한 객체를 가리키는 반복자이다.
```cpp
std::vector<int> vec;
...

const std::vector<int>::iterator iter = vec.begin(); // iter는 T* const처럼 동작

*iter = 10;											// OK, iter가 가리키는 대상 변경
++iter;												// 에러! iter는 상수

std::vector<int>::const_iterator cIter = vec.begin(); // cIter는 const T*처럼 동작

*cIter = 10;										  // 에러! *cIter가 상수이므로 불가
++cIter;											  // cIter를 변경하므로 문제없다.
```

### 함수에서의 const
#### const 함수 반환 값
안전성이나 효율을 지키면서 사용자측의 에러 돌발 상황을 줄이는 효과를 볼 수 있다.
```cpp
class Rational {...};
const Rational operator*(const Rational& lhs, const Rational& rhs);
```
```cs
Rational a, b, c;

(a * b) = c;
```
```cs
if(a * b = c) ...
```
오타로 인해 두 수의 곱에 대입 연산이 취해지는 것을 방지한다.
두 수의 곱에 대해 대입 연산이 되는 비호환성을 피할 수 있다.
반환 값이 const이므로 변경이 불가능해 컴파일 오류가 발생하여 이상 동작을 방지한다.

#### const 매개변수
매개변수 혹은 지역 객체를 수정할 수 없게 하고 싶다면 const로 선언한다.

#### 상수 멤버 함수
멤버 함수에 붙는 const는 "해당 멤버 함수가 상수 객체에 대해 호출될 함수"라는 것을 알려준다.
이런 함수가 중요한 이유는
1. 클래스의 인터페이스를 이해하기 좋게 하기 위함이다.
2. const를 통해 상수 객체를 사용할 수 있게 한다. 객체를 '상수 객체에 대한 참조자'로 전달하면 C++ 프로그램의 실행 성능을 높일 수 있다.
한편, const 유무 차이만 있는 멤버 함수들은 오버로딩이 가능하다.

### 비트수준 상수성
어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 const임을 인정하는 개념이다. (정적 멤버 제외) 즉, 그 객체를 구성하는 어떤 비트도 바꾸어서는 안 된다는 의미이다.
대입 연산 수행만 확인하면 되므로 상수성 위반 발견이 쉽다.
C++에서 정의하고 있는 상수성이다.

데이터 멤버 값을 바꾸어 비트수준 상수성을 위반함에도 걸리지 않는 문제점이 있다.
```cs
class CTextBlock{
public:
	...
    char& operator[] (std::size_t position) const	// 부적절한(그러나 비트수준 상수성이 있어서 허용되는) operator[]의 선언
    { return pText[position] };
    
private:
	char *pText;
};
```
operator[] 함수 내부는 pText를 건드리지 않기 때문에 컴파일러에 걸리지 않는다.
```cs
const CTextBlock cctb("Hello");	// 상수 객체 선언
char *pc = &cctb[0];			// 상수 버전 operator[]를 호출하여 cctb 내부 데이터에 대한 포인터를 얻는다.

*pc = 'J'; 						// cctb는 "Hello"라는 값을 얻는다.
```
그러나, 초기화된 상수 객체를 만들고 상수 멤버 함수를 호출했더니 값이 변해버렸다.
이를 보완하기 위해 논리적 상수성이 등장했다.

### 논리적 상수성
상수 멤버 함수라도 일부 몇 비트 정도는 바꿀 수 있되, 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다.
컴파일러의 검열을 통과하면서 (비트 상수성이 지켜지면서) 비정적 데이터 멤버를 비트 상수성의 족쇄로부터 풀어주는 키워드가 **mutable**이다.
<br>

### 상수 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법
캐스팅이 필요하긴 하지만, 안전성도 유지하면서 코드 중복을 피하는 방법은 **비상수 멤버 함수가 상수 버전을 호출하도록 하는 것**이다.
```cs
class TextBlock{
public:
	const char& operator[] (std::size_t position) const
    {
    ...
    return text[position];
    }
    
    char& operator[] (std::size_t position)
    {
    	return
    		const_cast<char&>(					// operator[]의 반환 값에서 const를 떼어내는 캐스팅
            	static_cast<const TextBlock&>	// *this에 const를 붙이는 캐스팅
                	(*this) [position]			// 재귀호출이 아닌 상수 operator[]를 호출하기 위해 *this 타입 캐스팅을 사용
            );
    }
    ...
};
```
상수 멤버 함수에서 비상수 버전을 호출하는, 위와 반대의 경우에는, 수정하지 않겠다고 약속한 그 객체를 배신하는 셈이고 안전성이 위험해진다.
<br>

- **const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다.
const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.**
- **컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 개념적인(논리적인) 상수성을 사용해서 프로그래밍 해야 한다.**
- **상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만들어라.**