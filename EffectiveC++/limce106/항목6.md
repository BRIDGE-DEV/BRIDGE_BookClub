## 항목 6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
프로그래머가 선언하지 않으면 컴파일러가 암시적으로 만들어내는 함수가 있다. (**복사 생성자, 복사 대입 연산자, 소멸자, 기본 생성자**)

### 컴파일러가 만들어낸 함수가 필요 없다면
컴파일러가 이 함수들을 선언하지 않도록 하기 위해서는
- **private 멤버 함수로 만든다.**
컴파일러가 생성하는 함수는 모두 public 멤버이다.
private 멤버로 선언하면 **외부로부터의 호출을 차단**할 수 있고, 클래스 멤버 함수가 명시적으로 선언되므로 컴파일러는 기본 버전을 만들지 못 한다.

- **정의하지 않는다.**
그 클래스의 멤버 함수 및 프렌드 함수가 호출하려는 것을 방지할 수 있다. 정의되지 않는 함수를 호출하려고 하면 링크 시점에서 에러가 뜰 것이다.

### 링크 시점 에러를 컴파일 시점 에러로 옮기기
에러 탐지는 미리 하는 것이 좋으므로 컴파일 시점 에러로 옮겨보자.

**1. 복사 방지만 맡는 기본 클래스를 만든다.**
```cpp
class Uncopyable{
protected:
	Uncopyable() {} // 생성과 소멸을 허용
	~Uncopyable() {}

private:
	Uncopyable(const Uncopyable&);	// 복사 방지
    Uncopyable& operator=(const Uncopyable&);
};
```
**2. 복사를 막고 싶은 클래스가 Uncopyable를 상속받게 한다.**
```cpp
class HomeForSale: private Uncopyable{
...	// 복사 생성자, 복사 대입 연산자가 선언되지 않는다.
};
```


#### Uncopyable의 구현과 사용법
- Uncopyable로부터의 상속은 public일 필요가 없다.
- Uncopyable의 소멸자는 가상 소멸자가 아니어도 된다.
- 데이터 멤버가 없기 때문에 **공백 기본 클래스 최적화 기법**이 먹힐 여지가 있으나, 기본 클래스에 이 기법을 사용하면 **다중 상속**의 가능성이 있다.
다중 상속 시에는 공백 기본 클래스 최적화가 돌아가지 못할 때가 종종 있지만 정확히 돌아가기 때문에 대강 무시해도 무관하다.
- **부스트** 라이브러리의 noncopyable 클래스는 Uncopyable과 같은 역할을 하므로 이를 사용해도 된다.
<br>

<br>

- **컴파일러가 자동으로 제공하는 기능을 혀용치 않으려면, 대응되는 멤버 함수를 private으로 산언한 후에 구현은 하지 않은 채로 두자. Uncopyable과 비슷한 기본 클래스를 쓰는 것도 한 방법이다.**