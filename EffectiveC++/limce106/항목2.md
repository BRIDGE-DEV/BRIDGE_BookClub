## 항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자
가급적 선행 처리자보다 컴파일러를 더 가까이 하자.

```cpp
#define ASPECT_RATIO 1.653
```
<br>

### #define의 문제점1) 
소스 코드가 컴파일러에게 넘어가기 전에 선행 처리자가 숫자 상수로 바꾸기 때문에 **컴파일러가 쓰는 기호 테이블에 들어가지 않는다.**
따라서 숫자 상수로 대체된 코드에서 컴파일 에러가 발생하면 에러 메시지엔 1.653이 있기 때문에 헷갈릴 수 있다.
이 문제는 기호식 디버거에서도 나타날 수 있다.

이 문제의 해결법은 **매크로 대신 상수를 쓰는 것**이다.
```cpp
const double AspectRatio = 1.653;
```
언어 차원에서 지원하는 상수 타입의 데이터이므로 컴파일러 눈에도 보이고 **기호 테이블에도 들어간다.**
상수가 부동소수점 실수 타입이라면 최종 코드의 크기가 #define을 썼을 때보다 작게 나올 수 있다. 매크로 사용 시 1.635의 사본이 ASPECT_RATIO 등장 횟수만큼 들어가지만, ASPECT_RATIO이 상수 타입일 경우 사본은 딱 한 개만 생기기 때문이다. 

> ### 상수 사용 시 주의할 점
#### 상수 포인터(constant pointer)를 정의하는 경우
포인터와 포인터가 가리키는 대상은 const로 선언해주어야 한다.
```cpp
const char* const authorName = "Scott Meyers";
```
또는
```cpp
const std::string authorName("Scott Meyers");
```
#### 클래스 멤버로 상수를 정의하는 경우
어떤 클래스 멤버인 상수의 사본 개수가 한 개 이하이길 원한다면 **정적 멤버**로 만들어야 한다.
```cpp
class GamePlayer{
private:
	static const int NumTurns = 5; // 상수 선언
    int scores[NumTurns]; // 상수를 사용하는 부분
};
```
C++에서는 사용하고자 하는 것에 대해 '정의'가 있어야 하지만, 정적 멤버로 만들어지는 정수류(각종 정수 타입, char, bool 등) 타입의 클래스 내부 상수는 예외이다.
#### 별도의 정의가 필요한 경우
- 클래스 상수의 주소를 구할 때
- 컴파일러가 잘못 만들어진 관계로 정의를 요구하는 경우
```cpp
const int GamePlayer::NumTurns;
```
정의에는 상수의 초기값이 있으면 안 된다. 클래스 상수의 초기값은 해당 상수가 선언된 시점에서 바로 주어지기 때문이다.
상수의 정의는 구현 파일에 둔다.
#### 컴파일러가 위의 문법을 받아들이지 않는 경우
정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 맞지 않다고 판단하기 때문이다.
초기값을 상수 '정의' 시점에 주면 해결된다.
```cs
class CostEstimate{
private:
	static const double FudgeFactor; // 정적 클래스 상수의 선언
    ...								// 헤더 파일에 둔다.
};
const double CostEstimate::FudgeFactor = 1.35; // 정적 클래스 상수의 정의. 구현 파일에 둔다.
```
#### 예외) 클래스를 컴파일하는 도중에 클래스 상수의 값이 필요할 때
**'나열자 둔갑술(enum hack)'**을 사용한다.
enum은 const보다 #define에 가깝다. enum은 #define처럼 주소를 얻을 수 없고 쓸데없는 메모리 할당을 하지 않는다.
다른 사람이 주소를 얻거나 참조자를 쓰는 것이 싫다면 enum이 유용하다.
enum은 템플릿 메타프로그래밍의 핵심 기법이다.

<br>

### #define의 문제점2)
#define으로 매크로 함수 구현 시 사용하는 괄호 수가 많아지거나 인자를 여러 번 평가할 수 있다.
```cs
int a = 5; b = 0;
CALL_WITH_MAX(++a, b);		// a가 두 번 증가
CALL_WITH_MAX(++a, b+10);	// a가 한 번 증가
```

inline 함수를 사용하면 이러한 문제점을 해결할 수 있다. 기존 매크로의 효율을 그대로 유지하고 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있다.
inline 함수는 템플릿이기 때문에 동일 계열 함수군을 만들어낸다. 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조이다.
```cs
template<typename T>
inline void callWithMax(const T& a, const T& b)	// T가 정확히 무엇인지 모르기 때문에, 매개변수로 상수 객체에 대한 참조자를 쓴다.
{
	f(a > b ? a : b);
}
```
<br>

- **단순한 상수를 쓸 때는, #define보다 const 객체 또는 enum을 우선 생각하자.**
- **함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자.**