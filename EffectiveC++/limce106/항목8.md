## 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
<br>

### 문제
예외를 내보내는 소멸자가 있을 때 이를 내버려두면 프로그램 종료나 미정의 동작을 보이게 된다.
```cpp
class DBConn{
public:
	...
    ~DBConn()		// DBConn 객체 소멸. 객체에 대한 close 함수 호출이 자동으로 이루어진다.
    {
    	db.close();	// 데이터베이스의 연결이 항상 닫히도록 확실히 챙겨주는 함수
    }
};
```
예를 들어, 위 코드에서 close()를 호출했는데 예외가 발생한다면 소멸자는 이 예외를 전파할 것이다.

### 해결
**1. 예외가 발생하면 프로그램을 바로 끝낸다.**
대개 abort를 호출한다.
```cpp
DBConn::~DBConn()
{
	try { db.close(); }
    catch (...) {
    	close 호출을 실패했다는 로그를 작성합니다;
        std::abort();
    }
}
```
소멸자에서 생긴 예외로 인한 미정의 동작을 막을 수 있다.

**2. 예외를 발생시킨 함수를 호출한 곳에서 예외를 삼켜버린다.**
**무엇이 잘못됐는지 알려주는 정보**가 묻혀버리기 때문에 좋은 방법은 아니다.
```cpp
DBConn::~DBConn()
{
	try { db.close(); }
    catch (...) {
    	close 호출을 실패했다는 로그를 작성합니다;
    }
}
```
이 방법을 사용 후에는, 발생한 예외를 그냥 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속할 수 있어야 한다.
<br>

두 방법 다 최초로 예외가 발생한 요인에 대한 조치를 취하지 않아 문제점이 있기 때문에 좋은 방법은 아니다.
사용자가 발생할 소지가 있는 문제에 대처할 기회를 가지도록 하자.

**3. 예외를 발생시킨 함수를 직접 제공한다.**
```cpp
class DBConn
{
public:
	...
    void close()
    {
    	db.close();
        closed = true;
    }
    
    ~DBConn()
    {
    	if(!closed)
        try{
        	db.close();
        }
        catch (...) {		// 연결을 닫다가 실패하면, 실패를 알린 후 실행을 끝내거나 예외를 삼킨다.
        	close 호출을 실패했다는 로그를 작성합니다;
            ...
        }
    }
}
```
close 호출의 책임을 DBConn의 소멸자에서 사용자가 호출할 수 있는 close로 넘긴다.
어떤 동작이 예외를 일으켜서 실패할 가능성이 있고, 또 그 예외를 처리해야 한다면, **그 예외는 소멸자가 아닌 다른 함수에서 비롯된 것이어야 한다.**

<br>

<br>

- **소멸자에서는 예외가 빠져나가면 안 된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리거나 프로그램을 끝내야 한다.**
- **어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 한다.**