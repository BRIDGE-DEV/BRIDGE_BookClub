## Item 6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

만약 해당 객체에 대한 유일성과 불변을 보장해야 한다면 컴파일러가 만들낸 함수들은 금제해야 한다. 이를 위해 `private`로 선언하고 구현하지 않는다. 이를 통해 컴파일러가 만들어낸 함수들을 사용하려고 하면 컴파일 에러가 발생한다.

```cpp
class Uncopyable {
protected:
    Uncopyable() {}
    ~Uncopyable() {}
private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};
```

해당 클래스를 상속받아서 사용하면 된다. 이를 통해 컴파일러가 만들어낸 함수들을 사용하려고 하면 컴파일 에러가 발생한다. 꼭 이런 방식이 아니더라도 해당 클래스에서 private로 선언하고 구현하지 않으면 된다.

but 전자는 friend 함수나 클래스에서는 사용이 가능하다. 이는 해당 클래스의 멤버로서 사용되기 때문이다. 후자는 어느정도 제약이 발생한다.

### 정리

- 컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 `private`로 선언하고 구현하지 않는다.

### 느낀점

책에서 다루는 트릭같은 방법보다 명확하게 `private`으로 돌리는 방법이 가능 명확하지 않을까? 라는 생각이 든다. 또한 자동 생성이 주는 트레이드 오프도 생각해보면 좋을 것 같다.
