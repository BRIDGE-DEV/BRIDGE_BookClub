## 항목 6: = delete로 간단하게
C++11에서 = delete가 도입되면서, 이전에 사용하던 생성자나 복사 생성자 등을 private로 선언하는 트릭이 불필요해졌다. 이제는 HomeForSale(const HomeForSale &) = delete; 한 줄로 컴파일러가 자동으로 생성하는 기능을 막을 수 있다. 예전 코드에서는 이 트릭을 쓰곤 했지만, 이제는 = delete를 쓰면 충분하다.

### 요약:
HomeForSale(const HomeForSale &) = delete; 이렇게 쓰자.

## 항목 7: 상속받는 클래스의 가상 소멸자
상속받을 일이 있는 베이스 클래스는 가상 소멸자를 선언하는 것이 필수적이다. C++20부터 operator delete 사용 시 개선이 있었지만, 여전히 안전하게 가상 소멸자를 쓰는 것이 좋다. 상속받지 않을 클래스에서는 굳이 virtual을 사용하지 않아도 되며, 성능 저하를 막기 위해 타이트한 루프에서 가상 함수 호출은 피하는 것이 좋다.

### 요약:
상속받는 클래스에는 가상 소멸자를 쓰자. 상속받지 않으면 굳이 쓰지 말자.

## 항목 8: 소멸자에서 예외 처리
소멸자에서 예외가 발생하면, 가장 좋은 방법은 예외를 유저가 처리하도록 하거나 소멸자 내부에서 예외를 잡아 std::abort를 호출하는 것이다. 또한 optional<T> 같은 방법을 사용하는 것이 차세대 에러 핸들링 방법으로 더 유용할 수 있다.

### 요약:
소멸자에서는 예외를 캐치하거나 유저가 처리하도록 유도하자.

## 항목 9: 생성자/소멸자에서 가상 함수 호출 금지
생성자나 소멸자에서 가상 함수를 호출하지 말아야 한다. 관련 내용을 다룬 블로그 글과 cppreference의 설명을 참조하자.

### 요약:
생성자와 소멸자에서 가상 함수를 호출하지 말자.

## 항목 10: this 레퍼런스 반환
this에 대한 레퍼런스를 반환하면 여러 상황에서 편리하다. 특히 std::cout << "Hello " << "World!" << std::endl;처럼 체이닝이 가능해진다. C++에서는 this가 포인터이기 때문에 레퍼런스를 반환하려면 *this로 dereference를 한 후 반환해야 한다.

### 요약:
this의 레퍼런스를 반환할 때는 *this를 사용하자.