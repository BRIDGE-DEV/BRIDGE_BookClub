## 항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자

생성(new) 에 대응되는 소멸(delete)를 호출하자. new 표현식에서 배열 타입 [] 를 사용했다면, 
delete에서도 동일하게 배열 타입 호출이 필요하다. 특히 typedef로 배열을 정의한 경우 주의해야 하는데,
배열 타입의 정의 후 delete 시도 시에도 배열 타입으로 사용해야 한다.

+) 예시로 마지막에 언급된 vector<string>으로 작성한다면, vector.clear()로 모든 벡터 내 원소의 소멸자를 호출할 수 있다.
+) vector.clear()를 호출하여 내부의 원소들을 모두 해제하더라도 vector에 할당된 용량은 해제되지 않는다.
+) C++에서는 이 경우 shrink_to_fit() 또는 clear-and-minimize / move sementic 기법을 활용할 수 있다.

### 요약 :
new 표현식에 []를 썼다면, 대응되는 delete 표현식에도 []를 써야 한다.

## 항목 17 : new 로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자

new로 생성하는 스마트 포인터(unique / shared)들은 매개변수에 한번에 작성할 때 자원을 흘릴 가능성이 있다.
그 이유는 함수의 매개변수로 전달되는 과정에서 연산이 실행되는 순서가 컴파일러마다 다르기 때문인데,
함수의 호출이 일어나는 과정에서 new -> 스마트 포인터의 생성자 -> 또 다른 매개변수... 순서가 아닌
new -> 다른 매개 변수 -> 스마트 포인터의 생성자 일 수도 있는데, new 객체의 초기화와 스마트 포인터의 생성자 사이에 예외가 발생한다면
new로 생성한 객체의 포인터가 제대로 할당되지 않고 유실될 가능성이 있다.

따라서 스마트 포인터로 객체를 저장할 때에는, 어딘가로 넘기기 이전에 별도의 한 문장으로 만들어
실행 순서를 명확히 만들어 주어야 한다.

### 요약 : 
new로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장으로 만듭시다. 이것이 안 되어 있으면, 예외가 발생될 때 디버깅하기 힘든 자원 누출이 초래될 수 있습니다.

## 항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

인터페이스를 개발할 때 사용자가 유발시킬 수 있는 실수를 최소화할 수 있도록 미리 가이드라인을 마련해 두자.
되도록 매개변수는 암시적 형변환을 허용하지 않는 타입 또는 구조체로 명확히 표현하고, 포인터로 넘겨야 할 필요가 있는 경우,
애초에 팩토리 함수를 만들어 스마트 포인터를 반환하게 만드는 것이 안전하다.

### 요약 : 
인터페이스는 제대로 쓰기 쉬우며 엉터리로 쓰기에 어렵게 만들자.
사용자의 실수를 방지하기 위해 새로운 타입 만들기 / 타입에 대한 연산을 제한하기 / 객체의 값에 대해 제약 걸기 / 자원 관리 작업을 사용자 책임으로 놓지 않기 등이 있다.

## 항목 19 : 클래스 설계는 타입 설계와 똑같이 취급하자

클래스 설계를 효과적으로 하기 위해 신경써야 하는 부분들에 관해 정리
- 객체의 생성 및 소멸을 어떻게 수행하느냐에 따라 클래스의 생성자/소멸자의 설계가 달라지고 메모리 할당 함수를 직접 작성할 경우에도 영향이 있다.
- 객체의 초기화와 대입은 호출되는 함수가 아예 다르기 때문에 헷갈리지 않고 명확하게 인지해야 한다.
- 새로운 타입의 객체가 call by value로 전달되는 경우 복사 생성자를 고려하자.
- 클래스의 불변속성을 유지시키자. 클래스의 데이터 멤버의 몇 가지 조합값들은 반드시 유효하게 구성하자.
- 상속받은 클래스의 경우 기존 클래스의 상속 제약을 따를 것인가? 아닌가를 고려하자. 이 선택으로 인해 멤버 함수가 가상인가 비가상인가의 설계가 결정되게 되고, 특히 소멸자에 영향을 준다.
- 어떤 종류의 타입 변환을 허용할 것인지, 암시적 형변환의 경우 클래스에 타입 변환을 작성하고, 명시적 변환만 허용할 경우, 별도의 변환 연산자를 작성하자.
- 어떤 멤버 함수를 작성할 것인가?
- 표준 함수들 중 어떤 것들을 비활성화 시킬 것인가? (Uncopyable 등)
- 객체 멤버에 대한 접근 권한(public, private, protected) 영역을 고려하자.
- 인터페이스로 무엇을 둘 것인가?
- 정말로 필요한 타입인가?

### 요약 :
클래스 설계 = 타입 설계로 보는 것이 좋다. 새로운 타입을 정의하기 전에 고려해야 할 점들을 기억하자.

## 항목 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다.

C++에서 보통 함수의 매개변수로 정보를 전달할 때 포인터나 참조자를 사용하지 않으면 전달되는 값은 '사본'으로 전달된다.(call by value)
이같은 방식은 사본을 생성할 때 초기화와 함수가 종료될 때 소멸을 반복하게 되는데, 이로 인한 불필요한 오버헤드나 메모리 사용이 할당될 수 있다.
이같은 손해를 최소화하기 위한 방법은 상수객체 참조자, const T&를 사용하는 방법인데, 애초에 사본의 복사가 발생하지 않고, 복사 손실(상속된 객체가 부모 클래스의 타입으로 전달되어 파생 클래스의 정보가 손실되는 현상)을
방지할 수도 있다. 

### 요약 : 
값에 의한 전달 보다는 상수 객체 참조자에 의한 전달을 선호하자. 효율적이며 복사 손실 문제까지 방지된다.
위 사항은 기본 제공 타입 및 STL 반복자, 함수 객체 타입에는 맞지 않다. 이들은 오히려 '값에 의한 전달'이 더 적합하다.