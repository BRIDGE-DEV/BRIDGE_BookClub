A Tour Of C++

CH1 기초 쌓기

1) 프로그램
  컴파일 과정 :  소스 텍스트를 컴파일러가 오브젝트 파일로 만들고, 오브젝트 파일은 링커에 의해 합쳐져서 실행 파일을 만들어 낸다. 

  ISO 표준은 내장타입과 컨테이너로 엔티티를 정의한다. 내장 타입은 기본 타입과 루프 같은 핵심 언어 기능이고, 컨테이너는 입출력이나 기본 컨테이너 같은 라이브러리 컴포넌트를 의미한다. 이 표준 라이브러리 컴포넌트 또한 기본 C++로 구현되어 있다.

  정적 타입 언어
  모든 엔티티의 타입을 사용 시점에 컴파일러에 알려야 한다.

  선언 (타입 지시 명령문)
  - 타입은 가능한 값 집합과 연산 집합(객체일 때)을 정의한다.
  - 객체는 어떤 타입의 값을 저장하는 메모리 영역이다. 
  - 값은 타입에 따라 다르게 해석되는 비트 집합이다.
  - 변수는 명명된 객체이다.

  타입을 명시할 필요가 없으면 auto를 사용한다.
  - 초기자의 타입 분명하지 않을 때 제외
  - 변수 범위나 정밀도를 밝히고 싶을 때

  범위와 수명
  지역 범위 : 함수나 람다에 선언된 이름
  클래스 범위 : 클래스 안이나 함수 람다 이넘 클래스에 정의 된 이름은 멤버
  네임스페이스 범위 : 클래스 범위 밖 네임스페이스 안에 정의된 이름
  전역 범위 : 어떤 구조체 안에도 속하지 않는 이름

  상수
  const : 값을 바꾸지 않겠다. (불변)
  constexpr : 컴파일 시점에 평가 (평가 시기, 주체) - 암묵적으로 런타임에 실행 가능
  consteval : 강력하게 컴파일 시점에 평가하도록 고정

  배열 순회
  for (auto x : arr)는 arr를 auto x에 복사하여 순회하라는 의미
  for (auto& x : arr)를 통해 복사하지 않고 참조로 순회 가능, 인수 수정 막고 싶을 시 const 추가

  할당
  내장 타입의 할당은 단순히 머신의 복사 연산
  모든 객체가 독립적
  C++과 C# (그리고 Java)의 중요한 차이점 중 하나는 변수가 값을 직접 저장하는 방식(값 타입)과 객체의 메모리 주소를 저장하는 방식(참조 타입)을 다루는 데 있다.

  C++에서는 사용자가 명시적으로 포인터(*)나 참조(&)를 사용하지 않는 한, 객체(클래스 인스턴스 포함)를 다른 객체에 할당하면 기본적으로 깊은 복사(deep copy) 또는 값에 의한 복사가 일어난다.
  (복사 생성자나 복사 대입 연산자가 호출됨). 
  그래서 할당 후 두 객체는 서로 독립적이다.

  C#에서는 Ref타입과  Val type 중 Val 타입은 C++와 같이, 깊은 복사가 일어나 독립적이지만, Ref는 얕은 복사가 일어나 종속적이다.

  초기화
  초기화는 메모리 조각을 유효한 객체로 만드는 작업
  할당은 객체가 값을 가지게 되는 것.


1) 프로그램
 C++은 의도적으로 추상적으로 저수준 내장 타입으로 다 만들 수 있도록 사용자 정의 타입을 설계하게끔 한다.
 내장 타입 : 기본 타입, const 한정자, 선언자 연산자로 만들 수 있는 타입

 구조체
 가자 원시적인 사용자 정의 타입
 기본적으로 한정자 안 쓸 시 public

 클래스
 기본적으로 한정자 안 쓸 시 private
 타입의 인터페이스 부분과 구현을 구분하는 매커니즘을 적용한 사용자 정의 타입
 멤버들의 집합

 열거
 값을 열거할 수 있는 사용자 정으 타입
 enum class A에서 class는 열거가 강형임을 명시하고, 열거자의 범위를 지정함.
 -> 강형이기에 암시적 변환을 막을 수 있음

 공용체
 모든 멤버를 같은 주소에 할당한 struct
 가장 큰 멤버의 크기만큼 공간을 차지함.

 type t;
 - Node* valN
 - int valI
 일 때, 한 사용자 정의 타입이 type에 따라 valN으로만 쓰이거나 valI로만 쓰일 경우 이렇게 공간 낭비하지말고 union을 사용하는게 낫다


3) 모듈성
  분리 컴파일
   C++는 사용할 타입과 함수 선언만 보여지는 분리 컴파일을 지원함.
   헤더 파일 : 별개의 파일에 선언만 담은 후 선언이 필요한 곳에서 #include
   모듈 : module 파일을 정의해 별도로 컴파일한 후 필요한 곳에서 import하는 방식
   (명시적으로 export한 선언만이 보여진다)

   헤더 파일로 분리 시 긴 구현이 담긴 cpp(번역 단위) 대신 선언만이 담긴 짧은 코드를 포함하기에 효율적
   따라서 사용처 - 헤더 - 구현 이렇게 연결 구조가 형성된다.

   단점 : 
   1) 수 많은(n) cpp에서 h를 포함하면 수 많은(n) 횟수 만큼 컴파일러가 처리해야 한다.
   2) 순서 종속성 때문에 header2.h header1.h를 먼저 #inlude하면 의미가 바뀌거나 코드에 영향이 갈 수 있다.
   3) 비일관성 : 같은 타입이나 함수 같은 엔티티를 서로 다르게 정의하면 찾기 어려운 오류가 발생

   모듈
   export module Name; //정의
   export class Vector {
   }
    export bool operator(== const Vector...)

   모듈을 정의 하고 export 하면, export 키워드가 달린 클래스(멤버 함수 포함), export 키워드 달린 비멤버 함수를 export 한다

   모듈은 딱 한번만 컴파일 되기에, 헤더처럼 n만큼 반복 처리되지 않는다/
   의미에 영향을 주지 않으면서 어떤 순서로든 임포트 가능하다.
   
   다른 코드에서 이 모듈을 import할 때는, 소스 코드를 다시 파싱하는 것이 아니라 이 미리 컴파일된 BMI를 읽어온다고 한다.

   다시말해, 단순 복사 붙여넣기가 아니라, 별도로 export 키워드를 사용한 것만 노출하며, 인터페이스를 BMI 형식으로 따로 정의하고 재사용하기에 모든 문제점이 해결된다.

   인수전달
   함수로 값을 넣는 것은 복사가 기본이고(값으로 전달), 호출자 환경에서 객체를 참조하면 참조를 사용(참조로 전달)
   성능을 고려할 때 크기가 작으면 값으로 크면 참조로 전달한다. 작다는 두 세 포인터 정도의 크기로 설명하고 있다. 

   반환 타입 추론
   함수의 반환값으로부터 반환 타입 추론 가능
   auto mul( param) { ... }

   후위 반호나 타입
   반환 타입 명시를 원할 시 auto 사용하면서 인수 목록 뒤에 반환 타입 추가하면 된다
   -> auto는 반환 타입을 나중에 언급하거나 추론하겠다고 해석한다.
   auto mult( param) -> double {...}

   구조적 바인딩
   함수는 값 하나만 반환할 수 있으나, 여러개를 반환하고 싶으면 구조적 바인딩을 사용한다.
   Entry { string name; int value;}
   Entry func(param){
    ...
    return {s, i};
   }
   auto [n,v] = func(pass);

   여기서 두 수 n,v를 선언하고, 각각 타입은 func의 반환 타입으로부터 추론한다. 클래스 객체의 멤버에 지역명을 부여하는 매커니즘을 구조적 바인딩이라고 한다.
   


