# Chapter08

---

# 고객 앞으로! 소프트웨어 전달

### 소프트웨어 전달의 4가지 단계

~~정해진 업계 표준은 없다.~~

이번 8장에서는 소프트웨어 전달 단계를 빌드, 릴리스, 배포, 롤아웃의 4가지로 구분한다.

- 소프트웨어는 반드시 패키지로 **빌드** 돼야 한다.
- 패키지는 생성되면 반드시 **릴리스** 돼야 한다.
- 발행된 릴리스 산출물은 반드시 테스트 환경이나 프로덕션 환경에 **배포**해야 한다.
- 일단 배포가 완료되면 사용자가 새로운 소프트웨어를 사용하도록 이동시켜서 **롤아웃**한다.

각 전달 단계에는 일련의 권장 기법이 존재한다. 하지만 각 전달 단계를 더 깊이 살펴보기에 앞서 소스 컨트롤 브랜칭 전략을 먼저 살펴봐야 한다.

### 효과적인 버전 제어를 위한 브랜칭 전략

릴리스 패키지는 버전 제어 시스템의 코드로부터 빌드한다. 

- **트렁크**는 변경 이력을 가진 주 버전의 코드베이스다.
- **브랜치**란 코드를 수정하기 위해 트렁크로부터 ‘가지 쳐 나온 것’이다. 개발자들은 여러 브랜치를 이용해 병렬적으로 일하고 준비가 되면 트렁크로 변경사항을 머지한다.

다양한 브랜칭 전략마다 각각 브랜치를 얼마나 오래 유지할지, 브랜치가 소프트웨어의 릴리스 버전과 어떤 관련이 있는지, 변경사항을 여러 브랜치로 어떻게 전파하는지 등에 대한 나름의 정의가 있다.

브랜치 전략 중 가장 보편적인 2가지는 트렁크 기반 개발 방식과 기능 브랜치 기반 개발 방식이 있다.

**트렁크 기반 개발**

- 모든 개발자가 브랜치를 트렁크에서 가지 치기 한다.
- 브랜치는 하나의 작은 기능, 버그 수정, 업데이트 등에 사용된다.
- 개발자가 브랜치를 공유하지 않으며 시간 단위가 아닌 일 단위로 신속하게 트렁크로 머지하는 환경에 적합하다. → 소규모 프로젝트 개발, 게임잼 등
- 이처럼 자주 머지하는 방식을 지속적 통합(CI) 라고한다.

**기능 브랜치 기반 개발**

- 기능 브랜치가 상당히 오래 유지되며 많은 개발자가 동시에 이 브랜치에서 작업한다.
- 각 기능 브랜치는 제품의 특정 기능과 관련이 있다.
- 기능 브랜치는 오래 유지되므로 개발자는 기능 브랜치의 코드가 너무 오래된 상태로 유지되는 일이 없도록 리베이스를 수행한다.
- 기능 브랜치의 안정성은 리베이스를 수행하는 시점을 이용해 제어한다.
- 릴리스가 준비되면 기능 브랜치를 릴리스 브랜치로 가져온다. 그런 다음 릴리스 브랜치에서 테스트를 진행하는 동안 기능 브랜치에서는 계속해서 변경이 일어난다.
- 패키지는 안정화된 릴리스 브랜치에서 빌드한다.
- 트렁크의 코드가 사용자에게 릴리스하기엔 너무 불안정해서 트렁크를 안정화시키는 동안 개발자가 기능 개발을 수행할 수 없는 경우에 사용하는 방법이다.
- 고객이 각자 다른 버전의 소프트웨어를 사용하는 경우 보편적으로 기능 브랜치 기반 개발 전략을 채택한다.
- 가장 보편적인 기능 브랜치 전략은 2010년 빈센트 드리센이 소개한 깃플로라고 부르는 전략이다.
- [https://www.youtube.com/watch?v=EV3FZ3cWBp8](https://www.youtube.com/watch?v=EV3FZ3cWBp8)

정말 장기간 유지해야할 기능 브랜치가 필요한 경우가 아니라면 (회사가 아니라면) 트렁크 기반 브랜칭 전략을 채택하자. → 관리가 복잡하다.

### 빌드 단계

소프트웨어를 전달하기에 앞서 반드시 먼저 패키지를 빌드해야 한다. 소프트웨어 빌드는 의존성 해석 및 링킹, 린터 실행, 컴파일, 테스트, 소프트웨어 패키징 등 여러 단계로 구성된다.

패키지는 각 릴리스마다 빌드하므로 소프트웨어를 실행할 각 머신마다 빌드를 수행할 필요는 없다.

소프트웨어가 2가지 이상의 플랫폼이나 환경을 대상으로 한다면 빌드를 통해 여러 개의 패키지를 생성할 수도 있다. (크로스 플랫폼을 지원하는 원신, 명조 등)

대부분 빌드는 운영체제나 CPU 아키텍처, 언어 런타임에 따라 다양한 패키지를 생성한다.

### 패키지에 버전을 명시하자.

### 리소스는 각각 별도로 패키징하자.

### 릴리스 단계

사용자가 소프트웨어를 사용할 수 있게 하는 릴리스는 소프트웨어 전달의 다음 단계인 배포를 위한 단계다. 릴리스는 소프트웨어의 종류와 크기 및 사용자의 숙련도에 따라 다양한 방법으로 수행한다.

- 내부 웹 서비스의 릴리스 절차는 소프트웨어 패키지를 공유 패키지 리포지터리에 발행하는 하나의 단계로 끝나기도 한다.
- 반면 사용자가 직접 사용하는 기능의 릴리스는 산출물 발행, 문서 업데이트, 릴리스 노트, 사용자와의 소통 등 다양한 절차가 필요하다.

릴리스 관리는 안정적이며 문서화가 잘된 소프트웨어를 예측 가능한 시점에 발행하는 기술이다. 복잡한 소프트웨어를 여러 팀이 함께 개발하는 경우에는 릴리스 관리 담당 인력을 별도로 두기도 한다.

릴리스 관리자는 테스트 기능 검증, 보안 절차, 문서화 등의 절차를 조율한다.

### 릴리스를 남의 일로 여기지 말자.

### 패키지를 릴리스 리포지터로리로 발행하자.

릴리스 패키지는 대부분 패키지 리포지터리에 발행하거나 아니면 깃 같은 버전 제어 시스템에 간단히 태그로 생성하기도 한다. 두 방법 다 괜찮지만 가능하다면 릴리스 패키지는 전용 패키지 리포지터리에 발행하는 편이 좋다. 

버전 제어 시스템을 릴리스 리포지터리처럼 사용할 수는 있지만 원래 용도라고 보긴 어렵다. 버전 제어 시스템에서는 검색이나 배포 관련 기능을 별로 제공하지 않는다. 문제를 일으킬 수 있다.

개발자는 작은 커밋을 자주하는 반면 체크아웃은 그다지 빈번히 수행하지 않는다. 반면 배포는 대부분 한 번에 여러 머신으로부터 코드를 체크아웃한다.

### 자주 릴리스하자.

### 릴리스 일정은 투명하게 공유하자.

### 변경 로그와 릴리스 노트를 발행하자.

### 배포 단계

소프트웨어 배포란 소프트웨어 패키지를 실행할 곳으로 옮기는 것이다. 배포 메커니즘은 다양하지만 기본 원리는 같다.

### 배포를 자동화하자.

소프트웨어 배포는 직접 수행하지 말고 스크립트를 이용해 자동화해라. 버전 제어가 가능하므로 좀 더 예측 가능한 배포를 구현할 수 있다. 배포가 잘못될 경우 이유를 유추하기도 쉽다.

### 배포는 원자적으로 수행하자.

매번 실행할 때마다 모든 단계가 성공할 것이라고 간주하지 말자.

### 애플리케이션을 독립적으로 배포하자

배포는 순서에 상관없이 가능하도록 만들자. 배포 순서에 의존하지 않는 소프트웨어는 반드시 하위 및 상위 호환성을 가져야 한다.(11장 참고)

### 롤아웃 단계

변경 사항은 점진적으로 롤아웃하고 시스템 상태 지표를 모니터링 하는 편이 좋다.

**롤아웃 전략**

- 기능 플래그 - 각각의 코드 경로를 실행하는 사용자의 비율을 제어 가능.
- 서킷 브레이커 - 문제가 발생하는 경우, 자동으로 코드 경로를 바꿔줌.
- 동시에 여러 버전의 소프트 웨어를 실행하는 방법 - 다크 론치, 카나리, 블루 - 그린 배포

이런 패턴들을 적절히 활용한다면 위험성을 내포한 변경사항이 문제를 일으키는 상황을 완화할 수 있다. 하지만 너무 복잡한 롤아웃 전략을 채택하지는 말자.

### 롤아웃을 모니터링 하자.

새 코드를 활성화 할 때는 에러율, 응답 시간, 리소스 사용량 등 상태 지표를 모니터링하자.

### 기능 플래그를 활용하자.

### 서킷 브레이커를 이용해 코드를 보호하자.

### 서비스 버전은 병렬로 올리자

병렬 배포를 이용하면 천천히 버전을 올리면서 위험을 완화할 수 있으며 뭔가 잘못된 경우 신속하게 롤백할 수 있다. 가장 보편적인 배포 전략은 **카나리** 배포와 **블루-그린** 배포다.

카나리 배포 - 대규모 트래픽을 처리하며 수많은 인스턴스에 배포되는 서비스에 활용.

블루-그린 - 두 가지 버전의 애플리케이션을 하나는 액티브 모드로, 다른 하느는 패시브 모드로 동시에 실행한다.

### 다크 모드로 론칭하자.

트래픽 섀도잉이라고도 부르는 다크 론치는 최종 사용자는 볼 수 없는 상태에서 새로운 코드를 실제 트래픽에 노출하는 방법이다. 그래서 다크 코드가 잘못 동작해도 사용자에게는 별다른 영향이 없다. 

다크 론치가 적용된 소프트웨어는 여전히 활성화 되어 있고 코드도 실행되지만 그 결과는 저장되지 않게 해준다. 

그래서 개발자와 운영자는 사용자의 영향을 최소화 하면서도 소프트웨어가 프로덕션 환경에서 어떻게 실행되는지 파악할 수 있다.

특히 복잡한 변경사항을 릴리스할 때는 다크 론치를 활용하는 것이 좋다. 이 패턴은 특히 시스템 마이그레이션을 검증할 때 유용하다.

# 논의사항

---

여러분들은 어떻게 브랜치를 나눠서 사용하고 계신가요? 본인만의 방식이 있다면 공유해주세요.