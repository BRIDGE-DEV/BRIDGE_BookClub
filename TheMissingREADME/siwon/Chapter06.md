# Chapter06

---

# 테스트! 개발자의 든든한 지원군

### 테스트의 기능

- 소프트웨어가 원하는 대로 동작하는지 검증.
- 의도치 않게 코드의 동작이 바뀌는 것을 방지.
- 깔끔한 코드 작성 장려.
- 개발자가 자신의 API를 사용하도록 강제.
- 컴포넌트를 어떻게 사용하는지에 대한 문서 역할.
- 실험을 위한 공간.

### 테스트의 종류

단위 테스트 

- 메소드나  동작 하나를 검증.
- 빠르고 작으며 집중적이어야 한다.

통합 테스트

- 여러 컴포넌트가 함께 어우러져 동작하는지 검증.
- 대체로 단위 테스트보다 느리며 더 정교한 셋업이 필요.
- 독립적인 단위를 개별적으로 테스트하는 것 만으로는 식별하기 어려운 문제를 찾아낼 수 있음.

시스템 테스트

- 시스템 전체를 검증.
- 실제 사용자의 동작을 시뮬레이션 한다.
- 어떤 조직에서는 릴리스 전에 시스템 테스트를 모두 통과하도록 규정.

성능 테스트

- 주어진 설정하에서 시스템의 성능을 측정.
- 부하 테스트 : 시스템에 다양한 수준의 부하를 걸고 성능을 측정.
- 스트레스 테스트 : 장애가 발생하는 수준까지 시스템의 부하를 올려 테스트.

인수 테스트

- 사용자나 사용자의 대리인이 제공된 소프트웨어가 인수 조건을 만족하는지 검증하는 테스트.
- ISO 보안 표준의 일부로서 요구.

### 테스트 도구

- 테스트 작성 도구 : 깔끔하고 효율적인 테스트 작성에 도움.
- 테스트 실행 프레임워크 : 테스트를 실행하게 도와주는 도구. 결과를 저장, 빌드 시스템과 통합.
- 코드 품질 도구 : 코드 커버리지와 복잡도 등을 분석. 버그 발견 및 코딩 스타일 에러 검사에 사용.

**모킹 라이브러리**

- 객체지향 코드의 단위 테스트에 주로 사용. 코드는 주로 외 부 시스템이나 라이브러리 또는 객체에 의존하는 경우가 많기 때문.
- 모의 객체(mock)는 실제 시스템이 제공하는 인터페이스를 유사하게 모방하는 스텁 객체로 외부 의존성을 대체.
- 모의 객체는 입력에 대해 하드코딩된 응답을 리턴함으로써 테스트에 필요한 기능을 구현한다.
- 모의 객체를 활용하면 테스트를 하기 위한 메소드나 파라미터, 변수를 애플리케이션 코드에 추가할 필요가 없다.

**테스트 프레임워크**

- 테스트 프레임워크는 테스트 코드를 작성하고 실행하는 도구다. 프레임 워크 중에는 단위 테스트, 통합 테스트, 성능 테스트, 심지어 UI 테스트까지 조율하고 실행해 주는 것도 있다.

프레임 워크의 역할

- 테스트 셋업과 해제.
- 테스트 실행 및 조율.
- 테스트  결과 보고서 생성.
- 추가 검증 메소드 등의 도구 제공.
- 코드 커버리지 도구와의 통합.

**코드 품질 도구**

- 린터 : 코드 품질 규칙을 강제하는 도구. 정적 분석과 스타일 검사를 실행한다. 코드 품질 모니터링 도구는 복잡도나 테스트 커버리지 같은 지표도 보고해준다.
- 정적 코드 분석기 : 파일 핸들을 열린 채로 둔다거나 값이 대입되지 않은 변수를 사용하는 등의 일반적인 실수를 찾아준다.
- 코드 스타일 검사기 : 모든 소스 코드를 동일한 방식으로 작성할 수 있다. 예컨대 한 줄당 최대 문자 수나 캐멀 표기법와 스네이크 표기법의 혼용 여부, 적절한 들여쓰기 같은 것을 검사한다.
- 코드 복잡도 도구 : 순환 복잡도를 계싼하거나 간단하게 코드의 분기 횟수를 검사함으로써 너무 복잡한 로직을 생성하지 않게 해준다.
- 코드 커버리지 도구 : 테스트가 몇 줄의 코드를 실행했는지를 찾아낸다.

**QA팀의 업무**

- 블랙박스나 화이트 박스 테스트 작성
- 성능 테스트 작성
- 통합 테스트, 사용자 인수 테스트, 시스템 테스트 수행
- 테스트 도구 제공 및 유지보수
- 테스트 환경과 인프라스트럭처 유지보수
- 테스트 환경과 인프라스트럭처 유지보수
- 정식 테스트 인증과 릴리스 절차 정의

### 테스트는 깔끔하게 작성하자.

테스트도 유지보수 및 리팩터링 필요. 좋은 프로그래밍 기법 적용. 상세 구현보다는 근본적인 기능을 테스트하는 데 중점을 둬야 한다.

### 과도한 테스트는 삼가자.

꼭 필요한 테스트만 작성. 실패했을 때 충분한 의미를 갖도록 작성. 커버리지 지표를 올리기 위한 목적으로 테스트 코드를 작성하지 말자. 코드 커버리지는 규칙이 아닌 가이드 정도로 생각해라.

### 테스트 결정성

결정적 코드란 입력이 같으면 그 출력도 항상 같은 코드를 말한다. 비결정적 코드는 그 반대이다.

네트워크 소켓을 통해 원격 웹서비스를 호출하는 단위 테스트는 비결정적이다. 네트워크에 문제가 생기면 테스트가 실패하기 때문이다.

비결정적 코드는 테스트의 가치를 떨어트린다. 매번 동일한 현상이 발생하지 않는다는 뜻은 재현과 디버깅이 어렵다는 뜻이다.

간헐적으로 실패하는 테스트는 비활성화 시키거나 즉시 수정해야 한다.

### 난수 생성기에 적절한 시드 값을 활용해라.

비결정성은 슬립이나 타임 아웃 난수 생성 등을 제대로 처리하지 못해서 발생하기도 한다. 난수 생성기는 반드시 원하는 난수가 나올 수 잇는 시드 값을 사용해야 한다. 

### 단위 시스템에서 원격 시스템을 호출해서는 안된다.

네트워크는 대체로 안정적이지 않다. 네트워크 호출에 타임 아웃이 발생해서 단위 테스트에 비결정성이 추가되기도 한다. 이런 테스트는 수백 번 실행해도 성공하지만 어쩌다 네트워크 타임 아웃이 발생하면 실패하기도 한다. 원격 시스템에 문제가 생기면 테스트도 실패하게 된다.

### 클럭을 주입하자.

특정한 간격의 시간에 의존하는 코드는 제대로 처리하지 않으면 비결정성을 유발한다. 시간을 리턴하는 정적 메소드를 사용하는 것보다는 테스트 시점에 시간을 제어할 수 있도록 모의 객체를 사용해 클럭을 의도적으로 주입하는 편이 좋다. **이를 의존성 주입이라고 부른다.**

### 슬립과 타임 아웃의 사용을 삼가자.

만일 테스트에서 슬립 메소드를 호출하거나 타임 아웃을 설정해야 한다면 테스트를 재구성해서 모든것이 결정적으로 실행될 수 있는지 검토해보자.

### 네트워크 소켓과 파일 핸들을 닫자.

### 0번 포트에 바인딩하자.

### 파일과 데이터베이스에 대해 고유한 경로를 생성하자.

### 이전 테스트의 상태를 격리하고 해제하자.

### 테스트의 실행 순서에 의존하지 말자.

순서에 대한 의존성은 보통 한 테스트가 데이터를 기록하고 그 다음 테스트는 데이터가 기록된 상태임을 가정할 때 주로 발생한다. 이 패턴이 문제인 이유는 여러가지가 있다.

- 첫 번째 테스트가 실패하면 두 번째 테스트 역시 실패한다.
- 두 번째 테스트는 첫 번째 테스트가 완료되기 전까지 실행할 수 없으므로 테스트의 병렬 실행이 어렵다.
- 첫 번째 테스트를 수정하면 의도치 않게 두 번째 테스트가 실패할 수 있다.
- 테스트 실행기의 변경으로 테스트가 다른 순서로 실행될 수 있다.

테스트 사이에 로직을 공유하려면 셋업과 해제 메소드를 사용하면 된다. 각 테스트에 필요한 데이터는 셋업 메소드를 이용해 마련하고 해제 메소드에서 해당 데이터를 제거하면 된다. 각 테스트를 실행할 때마다 상 태를 리셋해주면 상태의 변화로 인해 테스트가 서로 간섭 받는 일이 없다.

# 논의사항

---

제가 보기엔 게임 개발에서 필요한 테스트는 단위 테스트 보다는 통합 테스트에 더 가까워 보이는데 여러분은 어떻게 생각하시나요? 게임 개발에서 단위 테스트가 필요한 것 일까요? 필요하다면 어떤 식으로 활용해야 할까요?