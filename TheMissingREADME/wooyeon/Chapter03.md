# 필독! 개발자 온보딩 가이드

## 3장. 코드와 함께 춤을

> 레거시 코드에 임하는 우리의 자세

요구사항의 변화는 코드의 사용 방식과 얽혀 있다. 코딩 작업은 그래서 어려운 일이다. 그리고 여러분이 해야 할 가장 우선순위가 높은 업무이기도 하다.

3장에서는 이미 만들어진 기존 코드를 활용해 작업하는 방법을 보여준다. 먼저 코드를 엉망으로 만드는 엔트로피와 기술 부채 등의 개념을 설명한다. 그리고 나서 코드를 안전하게 바꾸는 실질적인 가이드를 알아보고, 코드를 어지럽히는 실수를 줄일 수 있는 팁을 살펴보는 것으로 마무리한다.

<br>

### 소프트웨어 엔트로피는 늘어나기 마련이다

코드를 살피다 보면 단점을 발견하게 될 것이다. 코드를 바꾸다 보면 지저분해지는 것은 자연스러운 일이다. 이렇게 코드가 지저분해지는 것을 **소프트웨어 엔트로피**라고 부른다.

소프트웨어 엔트로피는 여러 이유로 생겨난다. 개발자가 다른 사람이 쓴 코드를 이해하지 못하거나, 서로 코딩 스타일이 달라서 발생하기도 한다. 기술 스택과 제품 요구사항을 개선하다 보면 혼란이 가중된다. 버그 수정과 성능 최적화 또한 복잡도를 증가시킨다.

다행히 소프트웨어 엔트로피는 관리가 가능하다.
- 코딩 스타일, 버그 탐지 도구, 코드 리뷰, 리팩터링 등

<br>

### 결코 피할 수 없는 기술 부채

**기술 부채**는 소프트웨어 엔트로피를 가중시키는 주요 요인이다. 기술 부채란 기존 코드의 단점을 수정하면서 나중으로 미뤄둔 작업을 말한다.

금융 부채와 마찬가지로 기술 부채에도 원금과 이자가 있다.
- 원금: 수정해야 할 원래의 단점
- 이자: 본질적인 단점을 수정하지 않고 코드를 개선할 때 발생하는 비용

기술 부채를 해결하지 않고 그냥 내버려두는 일은 매우 흔히 일어나며, 레거시 코드에는 수많은 기술 부채가 산재해 있다.

부채는 두려운 것이지만 그렇다고 모든 부채가 나쁜 것만은 아니다. 마틴 파울러는 기술 부채를 2차원 매트릭스로 나눠 설명한다.

- 의도한 선택 + 신중하지 못한 선택
   - _설계할 시간이 없어요_
- 의도한 선택 + 신중한 선택
   - _일단 출시 후 결과를 보고 대처합시다_
- 의도치 않은 선택 + 신중하지 못한 선택
   - _계층화가 도대체 뭔가요?_
- 의도치 않은 선택 + 신중한 선택
   - _뭘 실수했는지 이젠 알겠네요_

신중히 고민하고 의도적으로 만들어진 부채는 보편적으로 발생하는 기술 부채 유형이다. **코드의 단점과 출시 속도 사이에서 고민하다 결정한 실용적인 트레이드오프인 것이다.** 나중에라도 팀이 해결 가능하도록 훈련된 부채라면 이는 좋은 부채라 할 수 있다.

신중하지 못했지만 의도적으로 만들어진 부채는 주로 팀이 출시일 압박을 받는 상황에서 만들어진다. 어떤 결정이 신중하지 못한 부채임을 의미하는 단어는 바로 '일단'이다.

신중하지도 못하고 의도치도 않았던 부채는 **알려지지 않은 미지**, 즉 몰라서 모르는 것들 때문에 발생한다. 이런 부채 유형은 사전에 구현 계획을 작성해 피드백을 받고 코드 리뷰를 수행하거나 꾸준한 학습을 통해 완화할 수 있다.

신중했지만 의도치 않게 발생되는 부채는 성장 과정에서 자연스럽게 나타나는 결과다. 어떤 상황은 뒤늦게 깨닫기도 한다. 이런 유형의 부채는 단순히 누군가가 제대로 일을 하지 않아서 생기는 것이 아니라 문제 도메인에 대해 배우는 과정이나 소프트웨어 아키텍트가 성장하는 과정 중에 발생하는 자연스러운 결과다. 건전한 팀은 프로젝트 회고 같은 절차를 활용해 의도치 않았던 부채를 찾아내고 부채의 해결 여부와 적절한 해결 시점을 논의한다.

중요한 점은 예기치 않은 실수는 피할 수가 없으므로 필연적으로 발생하는 부채가 있다는 사실이다. **부채는 성공의 표시일 수도 있다. 프로젝트가 지저분해질 정도로 오래 살아남았다는 뜻이기도 하니까.**

_(신중X 의도O 부채는 내가 가장 많이 발생시킨 부채의 유형이다. 반대로 가장 적은 건 가장 이상적인 신중O 의도O 부채.. ㅠㅠ)_

_(우리 프로젝트가 회고를 멈춘지 좀 됐는데 다음 회의 때 월 1회라도 회고하는 룰을 다시 도입하자고 말해봐야겠다.)_

<br>

#### 기술 부채를 상환하는 방법

문제를 해결할 수 있도록 한달 동안 온세상이 멈춰주지는 않는다. 그러니 업무를 진행하면서 필요한 부분은 정리하고 조금씩 **리팩터링**을 하자. 변경사항은 작고 독립적인 커밋과 PR로 만들자.

조금씩 꾸준히 하는 리팩터링이 비효율적이고 오히려 한 번에 크게 변경해야 할 때도 있다. 대규모 리팩터링은 꽤 중요한 결정이다. 장기적인 관점에서는 부채를 해결하면 출시 속도가 빨라질 수도 있다.

대규모 리팩터링이나 재작성을 제안하려 한다면 팀과 먼저 의논해보자. 기술 부채를 논의하는 좋은 방법은 다음과 같다.

1. 상황을 사실 그대로 설명한다.
2. 부채의 위험과 비용을 기술한다.
3. 해결책을 제안한다.
4. 대안에 대해 논의한다. (부채를 유지하는 방법 포함)
5. 트레이드오프를 따져본다.

제안 내용은 문서로 작성하자. 부채를 해결하는 데 드는 비용과 그럼으로써 얻을 수 있는 장점에만 집중하자. 구체적으로 서술하되, 누군가가 장점이 완료된 후 어떤 점이 좋아졌는지 보여달라고 요구하더라도 결코 당황하지 말자.

<br>

### 코드 변경으로 인한 고통을 조금이라도 줄이려면

기존의 동작을 유지하면서 변경해야 한다. 다른 개발자의 사고 방식을 이해하고 기존 스타일과 패턴을 유지해야 한다. 또한 업무를 진행하면서 코드베이스를 서서히 개선해야 한다.

새로운 기능을 추가하든, 리팩터링을 하든, 코드를 지우든, 아니면 버그를 수정하든, 코드를 변경하는 기법은 거의 같다. 사실 이 중 몇 가지 기법을 혼합하는 경우도 많다.

이미 존재하는 대규모 코드베이스를 변경하는 작업은 사람들이 수십 년에 걸쳐 단련해온 스킬이다. 이 스킬을 익히려면 지금부터 설명하는 몇 가지 팁을 활용해보기 바란다.

<br>

#### 레거시 코드 변경 알고리즘을 활용하자

마이클 C. 페더스는 자신의 저서 <레거시 코드 활용 전략>에서 기존 코드를 안전하게 수정할 수 있는 과정을 다음과 같이 소개했다.

1. 변경 지점을 확인한다.
2. 테스트할 지점을 확인한다.
3. 의존성을 나눈다.
4. 테스트를 작성한다.
5. 변경을 적용하고 리팩터링한다.

처음 4개의 과정은 밭에 씨를 뿌리는, 5번째 과정 전에 주변을 정리하고 울타리를 치는 과정이라고 생각하자. 울타리가 없으면 야생동물이 마구 돌아다니면서 애써 심어놓은 씨앗을 다 먹어치우지 않겠는가. 변경해야 할 코드를 찾아 테스트할 방법을 알아내자. 필요하다면 테스트가 가능하도록 코드를 리팩터링하자. 그다음 기존의 동작을 확인할 테스트를 추가한다. 이렇게 완성된 울타리로 변경할 지점을 잘 보호하게 되면 그 울타리 안에서 코드를 바꾸면 된다.

코드를 읽고 이것저것 실험해보며 질문을 던져보면서 변경해야 할 코드를 알아내자. (씨를 뿌리는 지점)

변경할 코드를 확인하고 난 뒤에는 테스트해야 할 부분을 알아내야 한다. **테스트 지점**은 수정하고자 하는 코드의 진입점, 즉 테스트가 직접 호출하고 값을 넣어보는 부분이다. 테스트 지점은 변경 전에 현재 코드가 어떻게 동작하는지 보여주며 이 지점을 이용해 여러분이 변경하는 코드를 테스트하게 된다.

운이 좋다면 테스트 지점은 쉽게 찾을 수 있다. 그렇지 않다면 테스트 지점을 찾기 위해 의존성을 나눠야 할 필요가 있다. 여기서 의존성은 여러분의 코드를 테스트하기 위해 필요한 객체나 메소드를 의미한다. **의존성을 나눈다**라는 말은 테스트가 용이하지 않은 코드의 구조를 바꾼다는 뜻이다. 테스트 코드를 결합해서 원하는 입력값을 대입할 수 있도록 코드를 수정해야 한다. 이 변경으로 코드의 동작이 바뀌어서는 안 된다.

의존성을 나누기 위한 리팩터링은 이 작업에서 가장 위험한 과정이다. 어쩌면 이미 작성된 테스트까지 바꿔야 할 수도 있는데 그러면 동작이 바뀌었는지를 알아내기 더 어려워진다. 조금씩 작업을 진행하되 이 과정에서 새로운 기능을 추가해서는 안 된다. 테스트는 자주 실행할 수 있도록 빨리 동작하게 만들자.

의존성을 나누는 방법은 다음과 같이 여러 가지다.

- 크고 복잡한 메소드는 더 작은 크기의 메소드로 나눠서 각기 분리된 기능이 독립적으로 테스트될 수 있게 한다.
- 인터페이스를 이용해서, 복잡한 객체를 완전하지는 않아도 테스트하기에는 충분한 단순 구현체로 대체할 수 있는 방법을 마련한다.
- 시간의 흐름같이 제어하기 어려운 실행 환경을 시뮬레이션할 수 있는 명시적 제어 지점을 주입한다.

조금 더 쉽게 테스트하려는 목적으로 접근제어자를 변경해서는 안 된다. 비공개 메소드와 변수를 공개하면 테스트가 코드에 접근할 수는 있지만 캡슐화에 문제가 생기므로 좋은 방법이 아니다. 캡슐화에 문제가 생기면 프로젝트에서 보장해야 할 동작의 노출 범위가 커진다.

_(이런 적이 있었다.. 그때도 긴가민가 하면서 바꾸긴 했지만 안좋다는 건 알고 있었을 것이다.)_

의존성을 나누고 리팩터링을 하면서 기존 동작을 확인할 수 있는 새로운 테스트를 추가하게 된다. 작업을 반복하면서 기존 테스트는 물론 새로운 테스트도 자주 실행하자.

의존성을 나누고 제대로 된 테스트가 준비됐다면 이제는 '정말로' 코드를 변경할 때다. 변경사항을 확인할 테스트를 추가하고 코드를 리팩터링해서 설계를 고도화하자. 코드가 안전하다는 사실을 알면 더 견고한 변경을 만들 수 있다.

<br>

#### 코드는 처음보다 더 깔끔하게 유지하자

인터넷에서 코딩 지식을 찾다 보면 간혹 "캠핑장을 떠날 때는 도착했을 때보다 깨끗하게 정리하라."라는 보이스카우트 원칙이 인용된다. 캠핑장처럼 코드베이스도 공유 공간이므로 가능하면 깔끔한 상태로 유지하는 편이 좋다. 이 철학을 코드에 적용하면 시간이 지나면서 코드는 점점 더 나아진다. 프로젝트를 리팩터링하기 위해 다른 기능 구현을 중단할 필요는 없다. 리팩터링에 드는 비용은 여러 변경으로 조금씩 나누면 된다.

버그를 수정하거나 새로운 기능을 추가할 때는 주변 코드를 정리하자. 그렇다고 지저분한 코드를 일부러 찾을 필요는 없다. 그저 기회가 생길 때 정리하면 된다. 코드를 정리하는 커밋은 동작을 변경하는 커밋과 구분하자. 커밋을 구분해두면, 코드를 정리하는 커밋을 유지하면서도 변경된 코드를 되돌릴 수 있다. 커밋의 크기가 작을수록 변경사항을 리뷰하기도 편하다.

리팩터링은 코드를 정리하는 유일한 방법이 아니다. **코드 스멜**이란 버그는 아니지만 문제를 유발할 수 있는 패턴을 사용하는 코드를 말한다.

_(생략된 중괄호도 코드 스멜 중 하나.. 쓰면 좋다는 걸 알지만 귀찮거나 보기 깔끔하게 하려고 종종 쓰는데 역시 고쳐야겠다)_

이런 문제는 물론이고 이름이 너무 긴 메소드나 클래스, 중복 코드, 너무 많은 분기나 루프, 너무 많은 매개변수 같은 문제들을 찾아주는 린터나 코드 품질 도구가 많다._(린터(linter): 소스 코드를 분석하여 프로그램 오류, 버그, 스타일 오류, 의심스러운 구조체에 표시(flag)를 달아놓기 위한 도구)_ 안티 패턴이 교묘하게 숨겨져 있으면 도구나 경험 없이는 찾아내기가 힘들어진다.

<br>

#### 점진적으로 변경하자

리팩터링은 대부분 둘 중 한 가지 유형을 띈다. 첫 번째는 수십 개의 파일을 한 번에 수정하는 '모조리 바꿔' 식의 변경이다. 두 번째는 리팩터링과 새로운 기능이 뒤섞인 PR이다. 이 두 가지 변경은 리뷰하기가 훨씬 어렵다. 커밋을 뒤섞으면 리팩터링한 부분을 유지하면서 기능 변경을 롤백하기가 어려워진다. 따라서 리팩터링 커밋은 작게 유지해야 한다. 코드 변경 알고리즘의 각 단계마다 별도로 PR을 만들자. 변경사항을 추적하기가 어렵다면 더 작은 커밋을 사용하자. 마지막으로, 리팩터링을 마구잡이로 수행하기에 앞서 우선 팀의 동의를 얻어야 한다. 여러분은 팀의 코드를 변경하는 중이며, 팀도 그 책임을 함께 져야 하니 말이다.

_(머리로는 알고있지만 '앗 이미 해버렸으니 내자~' 식의 커밋이 많았던 것 같다 ㅠ 단점을 체감해본 적 있음에도..)_

<br>

#### 리팩터링은 실용적으로 진행하자

리팩터링이 항상 현명한 결정은 아니다. 마감일도 생각해야 하고 우선순위도 고려해야 한다. 리팩터링에는 시간이 필요하다. 어쩌면 팀은 새로운 기능을 출시하기 위해 리팩터링을 미루기로 결정할 수도 있다. 이런 결정은 팀의 기술 부채를 늘리지만 올바른 결정일지도 모른다. 리팩터링으로 얻을 수 있는 가치보다 리팩터링에 드는 비용이 더 클 수도 있다. 오래되고 사용되지 않는 코드는 물론이거니와, 위험도가 낮거나 거의 호출되지 않는 코드는 리팩터링이 필요 없다. 리팩터링을 할 때는 실용성에 무게를 두고 고려하자.

<br>

#### IDE를 활용하자

(일부 코더는 IDE의 도움을 받는 것을 우둔하다고 여기며 빔Vim이나 이맥스Emacs 같은 IDE를 고집한다. 좋지 않다.)

**통합개발환경(IDE)**은 리팩터링을 할 때 특히 도움이 된다. 이름을 변경하거나 코드의 위치를 바꾸는 기능, 메소드와 필드를 추출하는 기능, 메소드 시그니처의 수정을 비롯한 다양한 보편적인 작업을 도와주는 여러 기능을 내장하고 있기 때문이다. 코드베이스가 거대하면 간단한 코드 작업은 지루할 뿐더러 에러가 발생하기도 쉽다. IDE는 자동으로 이런 코드를 파악해서 새로운 변경사항을 적용해 수정해준다.

그렇지만 IDE가 변경한 코드느느 반드시 사람이 리뷰해야 한다. 리플렉션이나 메타프로그래밍 형태로 참조하는 메소드의 이름을 바꾸면 관련 코드가 수정되지 않을 수도 있다.

<br>

#### 버전 제어 시스템의 권장 기법을 활용하자

변경한 코드는 깃Git 같은 **버전 제어 시스템**에 커밋해야 한다. 버전 제어 시스템은 코드베이스의 변경(커밋)을 만든 주체와 시기 등의 이력을 추적한다. 그리고 각 커밋에는 **커밋 메시지**를 추가해야 한다.

코드를 개발하는 동안 변경사항은 일찍 그리고 자주 커밋해야 한다. 커밋을 자주 하면 시간의 흐름에 따라 코드가 어떻게 변화해가는지 볼 수 있고, 변경을 되돌릴 수도 있으며, 원격 백업으로서 활용도 가능하다. 하지만 커밋이 너무 잦으면 '어이쿠'나 '망가진 테스트 수정' 같은 의미 없는 메시지로 도배되는 경우도 있다. _(찔린다.)_ 별 문제될 것은 없지만, 나머지 동료들에게는 아무 의미도 없는 메시지가 된다. 리뷰를 요청하기 전에는 브랜치를 리베이스rebase하거나 커밋을 스쿼시squash해서 커밋 메시지를 명료하게 정리하자. _(이 부분은 꼭 실천해봐야겠다.)_

커밋을 스쿼시할 때는 팀의 규칙에 따라 커밋 메시지를 작성해야 한다. 팀에 커밋 메시지 규칙이 없다면 크리스 빔이 조언한 '깃 커밋 메시지를 작성하는 7가지 요령'을 따르는 것도 좋다.

- 제목과 본문 사이에 빈 줄을 한 행 삽입한다.
- 제목은 50자 이내로 제한한다.
- 제목은 대문자로 쓴다.
- 제목 끝에 마침표를 붙이지 않는다.
- 제목은 명령형 문장으로 작성한다.
- 본문의 각 행은 72자를 넘지 않게 한다.
- 본문에는 코드가 '어떻게' 바뀌었는지보다는 '무슨' 코드가 '왜' 바뀌었는지를 설명한다.

_(2~5번 요령은 지키는 편이다. 7번 요령은 지켜보려고 노력해야겠다.)_

<br>

### 소프트웨어 개발에서 빠지기 쉬운 함정을 최대한 피하려면

기존 코드에는 라이브러리, 프레임워크, 패턴 등 이미 많은 것이 담겨 있다. 그중 몇몇 표준은 마음에 들지 않을 수도 있다. 깔끔하게 정리되고 더 현대적인 기술 스택을 갖춘 코드로 작업하길 당연히 원하겠지만, 코드를 처음부터 다시 작성하려 한다거나 표준을 무시하는 행동은 위험하다. 또한 코드를 쉽게 읽는 데 도움이 되는 코딩 표준을 무시하면 다른 개발자들이 코드를 읽기 어려워진다.

코드를 재작성하거나 규칙을 깨뜨리거나 또는 기술 스택에 새로운 기술을 추가할 때는 주의를 기울이자. 고부가가치를 낼 수 있는 상황에서만 코드를 재작성하자. 가능하다면 평범한 기술을 사용하자. 설령 동의하기 어렵더라도 규칙을 무시해서는 안 되며, 코드를 포크fork하는 상황은 피하자.

<br>

#### 되도록 검증된 기술을 사용하자

소프트웨어는 빠르게 변하는 분야다. 성공적인 기업이 오래된 라이브러리와 오래된 패턴으로 견고한 코드를 유지할 수 있는 데는 이유가 있다. 성공을 거두는 데는 시간이 걸리며, 기술을 갈아타는 것은 집중을 방해하는 요소가 되기 때문이다.

새로운 기술의 문제점은 성숙하지 못하다는 점이다. 댄 맥킨리는 <평범한 기술을 선택하자>라는 발표에서 "평범한 기술은 어디서 문제가 발생하는지가 잘 알려져 있다는 장점이 있다."고 언급한 바 있다. 모든 기술은 문제가 발생할 여지가 있지만, 오래된 기술에서 야기되는 문제는 예측이 가능하다. 새로운 기술은 의외의 방법으로 문제를 유발한다. 또한 기술의 성숙도가 낮다는 것은 커뮤니티 규모가 작으며, 안정성도 낮고, 문서화도 미흡하며, 호환성도 낮다는 사실을 의미한다. 게다가 새로운 기술은 스택 오버플로에서 관련 답변을 찾기도 어렵다. _(Yarn Spinner를 사용해보며 뼈저리게 체감했다.)_

새로운 기술을 도입했을 때의 장점이 도입 비용보다 커야 한다.

프로젝트에 새로운 프로그래밍 언어를 도입하는 것은 결과에 지대한 영향을 미친다. 새로운 언어를 선택하는 것은 회사의 생태계에 기술 스택 전체를 때려넣는 것이다. 새로운 빌드 시스템, 테스트 프레임워크, IDE, 라이브러리 등을 반드시 지원해야 하기 때문이다.

C, 자바, PHP, 루비, 닷넷 등으로 작성된 훌륭한 소프트웨어도 많다. 언어가 사장되지 않는 한, 단지 오래됐다거나 관심이 줄었다는 사실이 그 언어를 사용하지 않을 이유는 되지 못한다.

<br>

#### 제발 악동은 되지 말자

단지 마음에 들지 않는다는 이유로 회사의(또는 업계의) 표준을 무시해서는 안 된다. 비표준 코드를 작성하는 것은 기업 환경에 맞지 않는 코드를 작성한다는 뜨싱다. 여러분 멋대로 표준에서 벗어난다면 곧 그에 따른 비용이 발생할 것이다.

어쩌면 여러분이 수행하려는 방식이 정말로 더 나은 방법일 수도 있다. 그렇다고 해도 단기적으로는 다른 사람이 하는 대로 따르자. 그 방법이 표준으로 채택된 이유를 되도록 이해해야 한다. 어쩌면 여러분이 이해하지 못하고 있는 문제를 해결하기 위한 방안일 수도 있다. 그래도 답을 찾을 수 없다면 여러분의 팀장이나 해당 기술의 소유권을 확보한 팀과 대화를 시도해보자.

<br>

#### 업스트림 커밋 없이 포크만 하는 것은 금물이다

포크fork란 다른 소스 코드 리포지토리에 대한 안전하며 독립적인 복사본으로서 자체적인 트렁크, 브랜치, 태그 등을 갖는다. 깃허브 같은 코드 공유 플랫폼에서는 업스트림 리포지토리 _(:포크의 대상이 되는 원본 리포지토리)_ 에 PR을 보내기 전에 해당 리포지토리를 포크한다. 포크를 해두면 해당 프로젝트의 주 리포지토리에 쓰기 원한이 없는 사람도 코드에 기여할 수 있다. 보편적이고도 건전한 방법이다.

하지만 코드에 기여할 생각이 없으면서 해당 리포지토리를 포크하는 것은 그다지 권장되지 않는다. 보통은 해당 프로젝트의 방향이 마음에 들지 않거나 원래 프로젝트가 취소되거나 주 리포지토리에 변경사항을 병합하는 것을 허락받기가 어려운 상황에서 주로 포크를 한다.

회사 내부에서 포크한 리포지토리를 관리하는 것은 위험한 일이다. 소소한 변경은 시간이 지나도 업스트림 리포지토리에 적용되지 않는다. 그러다 보면 결국 완전히 다른 소프트웨어를 운영하게 되고, 결국 업스트림 리포지토리에 기능을 추가하거나 버그를 수정하는 것이 엄청나게 어려워진다.

<br>

#### 코드 재작성에 대한 욕구를 견디자

리팩터링을 하다 보면 기존 코드를 완전히 버리고 새로 작성하게 되는 경우가 있다. 기존 코드 리팩터링이 벅찬 나머지 기존 시스템을 통째로 날려버리고 모두 새로 작성하면 어떨까라는 생각까지 하게 된다. 코드를 새로 작성하는 것은 최후의 수단이라고 생각해야 한다.

코드 재작성이 더 나은 경우도 있지만 대부분은 그렇지 않다. 코드 재적성은 그에 들어가는 비용보다 장점이 클 때만 시도해야 한다. 코드 재작성은 위험할 뿐더러 소요 비용도 높기 대문이다.

코드 재작성이 항상 옳은 것도 아니다. 만일 시스템을 새로 작성하기로 했다면 선을 지나치게 넘지 않도록 각별히 유의하자.

<br>

### 개발자의 필수 체크리스트

![image](https://github.com/BRIDGE-DEV/BRIDGE_BookClub/assets/80298207/4109b98f-3cce-445e-89ff-1b6375ef9da2)

<br>

### 레벨업을 위한 읽을거리

마틴 파울러 <리팩터링>

<br>

### 생각

정말 나에게 도움이 되었던 장이다.
리팩터링하면서 '이러는 게 낫겠지?'라던가 'A보단 B가 나을 것 같은데 귀찮으니 A로 할까..'와 같이 혼자 고민했던 부분들이 잘 정리되어 있어 큰 참고가 되었다.

### 논의사항

- 여러분은 팀에서 어떤 깃 커밋 메시지 규칙을 적용하고 있나요?