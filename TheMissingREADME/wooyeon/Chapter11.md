# 필독! 개발자 온보딩 가이드

## 11장. 소프트웨어 수명주기 관점의 진화하는 아키텍처 구현

> 성장하고 발전하는 소프트웨어를 만들기 위한 핵심 원칙

### 복잡도를 이해하자

오스터하우트에 따르면, 복잡한 시스템은 높은 의존성dependency와 높은 모호성obscurity이라는 두 가지 특성을 작는다. 우리는 여기에 세 번째 특성인 높은 관성inertia을 추가하고자 한다.

의존성이 높은 소프트웨어는 다른 코드의 API나 동작에 의존하게 된다. 의존성은 분명히 불가피한 것으로서, 때로는 필요한 경우도 있지만 반드시 균형을 맞춰야 한다. 새로운 연결과 추정이 많아질수록 코드를 변경하기는 어려워진다. 의존성이 높은 싯템은 강한 결합tight coupling과 변경의 영향도 확대change amplification로 인해 수정이 어렵다. 강한 결합이란 어떤 모듈이 다른 모듈에 심하게 의존하는 것을 말한다. 그러면 변경의 영향도가 확대되어 하나를 변경하려면 의존성도 변경해야 한다. 강한 결합과 변경 영향도를 최소화하려면 API를 주의 깊게 설계하고 추상화를 적절히 활용해야 한다.

모호성이 높으면 프로그래머는 변경의 부작용, 코드의 동작, 변경이 필요한 지점 등을 예측하기가 어려워진다. 모호한 코드는 학습에도 오랜 시간이 걸리며 개발자의 부주의로 문제가 일어날 확률 또한 높아진다. 너무 많은 작업을 '담당'하는 신 객체god object, 부작용을 유발하는 전역 상태global state, 코드를 이해하기 어렵게 만드는 과도한 간접성, 프로그램의 전혀 무관한 부분의 동작에 영향을 주는 원격 작용action at distance 등은 모두 높은 모호성의 증상이다. 이런 모호성을 줄이려면 명확한 계약과 표준 패턴을 적용해 API를 설계해야 한다.

관성은 오스터하우트가 내린 정의에 우리가 추가한 특성으로서, 소프트웨어를 계속 사용하려는 성향을 말한다. 간단한 실험에 사용하고 난 뒤 쉽게 없앨 수 있는 코드의 관성은 낮다고 볼 수 있다. 반면 비즈니스에 요긴한 수십 가지 애플리케이션을 실행하는 서비스는 관성이 높다고 할 수 있다. 복잡도의 비용은 시간이 지나면서 누적되므로 관성이 높고 변경이 잦은 시스템은 반드시 간소화해야 하는 반면, 관성이 낮고 변경이 드문 시스템은 복잡한 상태 그대로 남겨뒤도 무방하다.

복잡도를 항상 제거할 수 있는 것은 아니지만 적어도 복잡하게 남겨둘 부분을 선택할 수는 있다. 변경사항의 하위 호환성을 고려하면 코드를 사용하기 쉽게 만들 수는 있지만 구현하기는 훨씬 복잡해진다. 하위 시스템과의 결합도를 낮추기 위해 간접 수단을 겹겹이 쌓으면 의존성은 줄어들지만 모호성이 증가한다. 언제 어디서 어떻게 복잡도를 관리할 것인지에 대해 충분히 생각하자

### 진화하는 아키텍처를 위한 설계 원칙

최대한 간단하게 구현하자Keep things simple(KISS-Keep it simple, stupid)

간결함을 염두에 두고 시스템을 구현할 수 있도록 이 KISS라는 약어를 꼭 기억해두자.

코드를 간결하게 유지하는 가장 쉬운 방법은 모든 것을 한꺼번에 작성하지 않는 것이다.

"그건 필요하지 않을 거야. You ain't gonna need it(YAGNI)"라고 스스로에게 주문을 걸자.

코드를 작성할 때는 최소 충격 원칙과 캡슐화 원칙을 적용하자.

#### YAGNI 원칙: 당장 필요치 않다면 구현하지 말 것
#### 최소 충격 원칙: 사용자를 놀래키지 말 것
#### 도메인 지식은 캡슐화돼야 한다
### 진화하는 API를 위한 설계 원칙
#### API 크기는 작게 유지하자
#### 잘 정의한 서비스 API를 노출하자
#### API 변경에는 호환성을 유지하자
#### API의 버전을 관리하자
### 진화하는 데이터를 위한 설계 원칙
#### 데이터베이스를 격리하자
#### 스키마를 사용하자
#### 스키마 마이그레이션을 자동화하자
#### 스키마 호환성을 유지하자

<br>

### 생각

(x)