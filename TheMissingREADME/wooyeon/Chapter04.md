# 필독! 개발자 온보딩 가이드

## 4장. 운영 환경을 고려한 코드 작성

> 개발 환경과 프로덕션 환경은 엄연히 다르다

코드는 '실제 세계'로 노출되면 이상한 동작을 한다. 실 세계의 사용자는 예측이 어려우며, 네트워크도 믿을 수 없다. 그래서 뭔가 잘못되는 상황이 벌어진다. 프로덕션 소프트웨어는 지속적으로 동작해야 한다. 따라서 운영 가능한 코드를 작성해야 예상하지 못한 상황에 대처할 수 있다. 운영 가능한 코드란 보호 장치, 분석 장치, 제어 장치가 내장된 코드를 말한다. 안전하고 회복성 있는 코딩 기법을 이용해 방어적으로 프로그래밍해서 시스템을 보호해야 한다. 안전한 코드는 다양한 장애를 극복하며, 회복성을 갖춘 코드는 장애가 발생해도 복구가 가능하다.

이번 4장에서는 프로덕션 환경에서 코드를 쉽게 운영할 수 있는 권장 기법 몇 가지를 설명한다. 이번 장을 다 읽을 때쯤이면 소프트웨어를 운영 가능하게 하는 주요 개념과 도구에 익숙해질 것이다. 게다가 운영 관련 주석은 코드 리뷰에서 자주 발견할 수 있다. 이 정보는 더 나은 피드백을 주고받는 데 도움이 될 것이다.

<br>

### 장비에 대비하기 위한 방어적 프로그래밍 방법

방어적 코드는 여러분의 코드를 운영하는 모두를 위한 배려다. 방어적 코드는 장애가 발생하는 빈도가 낮으며, 장애가 발생하더라도 대부분 복구된다. 코드를 안전하고 회복성 있게 만들자. **안전한 코드**는 컴파일 타임의 유효성 검사를 통해 런타임 장애를 최소화환다. 불변 변수를 사용하고, 접근 제어자를 이용해 범위를 제한하며, 정적 타입 검사기를 활용해 버그를 줄이자. 런타임에 예상치 못한 일이 벌어지지 않도록 입력값을 검사하자. **회복성 있는 코드**는 권장되는 예외 처리 기법을 활용하며 장애를 적절하게 처리한다.

<br>

#### null 값 사용은 피하자

대부분의 언어는 값이 할당되지 않은 변수의 기본값으로 null을 할당한다. 널 포인터 예외는 매우 보편적으로 발생한다. 변수가 널값을 갖진 않았는지 검사하거나, 널 객체 패턴이나 옵션 타입 등을 사용해서 널 포인터 예외를 방지하자.

널 검사는 메소드의 시작지점에서 해야 한다. 변수의 값이 널이 아님을 사전에 확인하면 나ㅓ지 코드에서는 그 변수를 실제 값을 가진 안전한 변수로 사용할 수 있다. 그러면 코드는 더욱 깔끔하고 읽기 쉬워진다.

**널 객체 패턴**은 널 값 대신에 객체를 사용하는 패턴이다. 원하는 객체를 찾지 못했을 때 null이 아니라 빈 배열을 리턴하는 검색 메소드가 바로 널 객체 패턴의 좋은 예시라고 할 수 있다. 빈 배열을 리턴하면 호출자는 리턴된 값을 확인하는 특별한 코드가 없어도 안전하게 검색 결과를 확인할 수 있다.

<br>

#### 불변 변수를 사용하자

불변 변수는 값이 한 번 대입되고 나면 그 값을 바꿀 수 없다. 여러분이 사용하는 언어에서 불변 변수를 명시적으로 선언할 수 있는 방법(자바 final 등)이 제공 된다면 가능한 한 활용하기 바란다. 생각했던 것보다 훨씬 많은 변수가 불변 변수가 될 수 있다. 또한 불변 변수를 사용하면 병렬 프로그래밍은 더 간단해지며, 변수 값이 바뀌지 않을 것임을 인지하는 컴파일러나 런타임은 더 효율적으로 동작할 수 있다.

<br>

#### 타입 힌트와 정적 타입 검사를 사용하자

변수가 보관할 수 있는 값을 제한하자. 예를 들어 몇 가지 문자열 값 중 하나만 가질 수 있는 변수 String 타입보다는 Enum으로 선언할 수 있다. 변수를 제한하면, 예상치 못한 값을 대입해도 버그를 유발하지 않고 그 즉시 실패하게 된다. 변수를 선언할 때는 가장 구체적인 타입을 사용하자.

파이썬, 소르베를 활용하는 루비, 자바스크립트 등 동적 언어에서도 견고한 **타입 힌트type hint**와 **정적 타입 검사기**의 지원이 늘어나고 있다. 타입 힌트를 활용하면 원래는 동적 타입이던 변수에 타입을 지정할 수 있다.

<br>

#### 입력값을 검사하자

코드로 전달되는 입력값은 절대로 신뢰하지 말자. 개발자, 결함이 생긴 하드웨어, 사람의 실수 등으로 입력 데이터가 훼손될 수 있기 때문이다. 제대로 된 입력값이 전달됐는지 확인해서 코드를 보호하자. 사전 조건, 체크섬 _(: 중복 검사의 한 형태)_ 및 데이터 유효성 검사 등을 활용하자.

사전 조건 및 사후 조건을 이용해서 메소드에 전달되는 입력 변수의 유효성을 검사해야 한다. 최대한 많이 검사하자. 입력 문자열이 여러분이 원하는 형식인지 확인하고, 문자열 앞뒤의 공백도 처리해야 한다는 점을 기억하자. 숫자는 모두 적절한 범위 내에 있는지 확인하자.

컴퓨터 하드웨어와 보안도 간과하지 말자. 항상 입력값을 검사해서 SQL 주입 공격을 예방하자. 보안 지식을 갖추자.

<br>

#### 예외를 활용하자

(null, 0, -1 같은) 특정한 리턴값으로 에러를 표현하는 것은 금물이다. 모든 최신 개발 언어는 예외나 표준 예외 처리 패턴을 제공한다. 특정한 리턴값은 메소드 시그너처에 명확하게 드러나지 않는다. 따라서 개발자는 리턴값이 에러를 의미한다는 점을 모를 수 있다. 또한 어떤 리턴값이 어떤 에러 상태를 의미하는지 기억하는 것도 어렵다. 예외Exception은 이름도 있고 스택 추적 정보, 줄 정보, 메시지 등 훨씬 더 많은 정보를 담고 있다.

<br>

#### 예외는 구체적으로 사용하자

예외를 구체적으로 정의하면 코드를 더 쉽게 사용할 수 있다. 가능하면 언어에 내장된 예외를 사용하고 포괄적인 의미를 담는 예외는 만들지 않게 하자. 예외는 애플리케이션 로직을 제어하는 용도가 아니라 실패를 처리할 때만 사용해야 한다.

예외를 직접 정의할 때는 너무 포괄적인 의미가 담기지 않게 하자. 예외의 이름이 너무 포괄적이면 어떤 문제가 발생했는지 파악할 수 없어 예외를 처리하기가 어려워진다.

또한 예외를 애플리케이션 로직에 사용해서는 안 된다. 예외를 이용해 메소드를 분기하면 이해도 어려울 뿐더러 디버깅도 어려워진다.

<br>

#### 예외는 일찍 던지고 최대한 나중에 처리하자

'일찍 던지고 늦게 잡는' 원칙을 따르자. **일찍 던진다throw early**는 말은 개발자가 관련 코드를 신속하게 찾을 수 있도록 에러가 발생한 지점으로부터 최대한 가까운 지점에서 예외를 던진다는 뜻이다. 실제 에러가 발생한 지점으로부터 너무 먼 위치에서 예외를 던지면 어디서 문제가 생겼는지 찾기가 어려워진다. 에러가 발생했는데 예외를 던지기 전에 다른 코드를 실행하면 또 다른 에러가 발생할 위험이 있다. 만일 두 번째 에러가 발생해서 예외가 던져지면 첫 번째 에러는 발생했는지도 모르고 넘어가게 된다.

**예외를 늦게 잡는다catch exception late**는 말은 예외를 처리할 적절한 위치에 도착할 때까지 계속 호출 스택을 통해 전파시킨다는 뜻이다. 어설프게 에러를 처리하기보다는 예외를 상위 계층으로 전파하는 방식이 맞다. 예외를 무시하는 경우는 최악의 결과를 야기할 수 있다.

<br>

#### 재시도는 현명하게

에러를 적절하게 처리하는 방법 중 하나는 단순히 다시 시도하는 것이다. 여러 차례 재시도하려는 시도는 주로 원격 시스템을 호출할 경우에 나타난다. 쉬워보이지만 현실에서 재시도의 시기와 빈도를 파악하려면 약간의 노하우가 필요하다.

가장 손쉬운 재시도 방식은 단순히 예외를 잡아서 그 즉시 작업을 다시 시도하는 것이다. (비선형으로 대기 시간을 늘리는 백오프backoff 전략을 사용하는 것도 좋다.) 실패한 요청을 무턱대고 재시도하지는 말자. 특히 데이터를 기록하는 작업이나 비즈니스 절차를 시작하는 요청은 더욱 주의해야 한다.

<br>

#### 시스템에 멱등성을 부여하자

장애가 발생한 후의 시스템 상태를 항상 명확하게 파악할 수 있는 것은 아니다. 재시도를 처리하는 가장 좋은 방법은 멱등성idempotent 있는 시스템을 구현하는 것이다. 멱등성이란 동일한 작업을 여러 번 실행해도 항상 같은 결과가 출력됨을 말한다. 모든 작업을 멱등 작업으로 구현하면 시스템의 상호작용이 훨씬 간단해지며 발생 가능한 에러도 현저히 줄어든다.

<br>

#### 리소스를 해제하자

장애가 발생하면 모든 리소스를 해제해야 한다. (네트워크 소켓이 누수되면(사용한 뒤 해제에 실패하면) 불필요한 연결이 계속 남아있어 연결 풀pool이 가득차게 된다.)

현대 개발 언어드르이 상당수는 자동 리소스 해제 기능을 지원한다.

<br>

### 문제 원인을 찾기 위한 로깅 방안

로그 메시지를 출력하는 것은 코드의 실행을 이해하거나 작은 프로그램을 디버깅할 수 있는 쉽고 편리한 방법이다. 개발 언어는 복잡한 애플리케이션을 위해 언제 어떤 것을 로그에 기록할지 제어하는 연산자를 제공하는 정교한 로깅 라이브러리를 갖추고 있다.

코드를 쉽게 운영하고 디버그할 수 있도록 로깅 프레임워크를 활용하자. 로그 레벨을 설정해서 운영자가 애플리케이션의 로그 양을 조정할 수 있게 하자. 로그는 원자적이고 빠르며 안전하게 다뤄야 한다.

<br>

#### 로그 레벨을 사용하자

로깅 프레임워크는 운영자가 중요도에 따라 메시지를 필터링할 수 있도록 로그 레벨log level을 지원한다. 운영자가 로그 레벨을 설정하면 설정한 레벨보다 상위 레벨의 로그는 모두 기록되는 반면 그보다 낮은 레벨의 로그는 기록되지 않는다.

로그 레벨을 제대로 활용하려면 각 로그 메시지에 적절한 중요도를 지정해야 한다. 로그 레벨은 완전히 표준화되지는 않았지만 대체로 다음과 같다.

- TRACE => DEBUG => INFO => WARN => ERROR => FATAL(가장 위험한 수준)

<br>

#### 로그는 원자적으로 작성하자

만일 데이터와 결합했을 때만 정보가 유용하다면 한 메시지에 모든 정보를 원자적으로 저장하자. 로그 수집기는 관련 정보를 한 줄에 모두 표현하는 로그를 더 잘 처리한다. 다만 로그가 특정 순서대로 보일 것이라는 기대는 하지 말자. 운영 도구 중 상당수가 로그를 재정렬하거나 심지어 메시지를 놓칠 수 있다. 로그를 정렬할 때는 시스템 시간에 의존하지 말자. 시스템 시간은 리셋되거나 호스트마다 조금씩 다를 수 있다. 로그 메시지에 줄바꿈 문자 사용도 피하자. 대체로 로그 수집기는 줄바꿈 문자를 별도의 메시지로 취급한다. 특히 스택 추척 문자열은 줄바꿈 문자 때문에 여러 행으로 분리되는 경우가 많으므로 이 정보가 하나의 메시지로 기록되는지 반드시 확인하자.

만일 로그 메시지를 한 줄에 출력할 수 없다면 고유한 ID를 포함시켜서 나중에 연결할 수 있게 하자.

<br>

#### 로그는 신속하게 기록하자

로그를 너무 많이 기록하면 성능에 영향을 미친다. 로그는 디스크나 콘솔, 원격 시스템 등 어딘가에 반드시 기록돼야 하며, 기록하기 전에 올바른 형태의 한 문자열로 결합해야 한다. 로그를 신속하게 기록하려면 파라미터화 로깅과 비동기 어펜더를 활용하자.

로그의 상세함 정도와 설정을 변경하면 애플리케이션이 느려지므로 경합 상태와 버그가 숨어버릴 수 있다. 만일 디버깅을 위해 로그를 상세히 출력하도록 설정을 바꿨는데 버그가 갑자기 사라진다면 로깅 설정을 바꿨기 때문일 수도 있다.

<br>

#### 민감한 데이터는 로그에 기록하지 말자

로그 메시지에는 비밀번호, 보안 토큰, 신용카드 번호, 이메일 주소 같은 개인정보가 포함돼서는 안 된다. 당연한 말 같겠지만 흔히 실수하기 쉬운 부분이다. 대부분의 프레임워크는 규칙 기반으로 문자열을 교체하거나 교정하는 기능을 제공한다. 이런 기능을 적극 활용하되 너무 의존하지는 말자. 보안에 한에서는 과해도 된다.

<br>

### 애플리케이션 동작 측정을 위한 지표 활용 방안

지표metrics를 이용해 애플리케이션이 어떤 동작을 하는지 살펴보자. 지표는 숫자로 표현한 로그와도 같아서 애플리케이션의 동작을 측정한다. 쿼리 실행 시간은 얼마나 걸리는지, 큐에 저장된 값은 몇 개인지, 디스크에 얼마나 많은 데이터가 기록되고 있는지 등 애플리케이션의 동작을 측정하면 문제를 인지하는 데 도움이 되며 디버깅에도 유용하다.

지표는 크게 카운터, 게이지, 히스토그램 등 세 가지 유형으로 나누는 것이 보편적이다.

- 카운터 counter
   - 특정 이벤트가 발생한 횟수를 측정한다
   - 캐시 히트cache hit 카운터와 요청 카운터를 이용하면 캐시를 활용하는 비율을 계산할 수 있다.
- 게이지 gauge
   - 특정 시점을 기준으로 측정하므로 값이 올라가거나 내려갈 수 있다. 자동차의 속도계나 연료계라고 생각하면 된다.
- 히스토그램 histogram
   - 규모에 따라 이벤트를 특정 범위로 구분한다. 각 범위에는 해당 범위 내의 이벤트 값이 발생하면 값이 증가하는 카운터가 있다.
   - 주로 요청 처리에 걸린 시간이나 데이터 페이로드payload 크기 같은 지표를 측정한다.

<br>

#### 표준 지표 라이브러리를 사용하자

카운터, 게이지, 히스토그램을 쉽게 계산할 수 있다고 해서 지표 라이브러리를 직접 구현할 생각은 금물이다. 표준 라이브러리는 애초에 모든 것과 통합할 수 있도록 만들어져 있다. 각자 회사에서 선호하는 지표 라이브러리가 있을 수도 있다. 만약 정해진 라이브러리가 없다면 동료들과 어떤 라이브러리를 도입할지 논의하자.

<br>

#### 모든 것을 측정하자

측정은 비용이 적게 드는 작업이므로 가급적 많은 지표를 수집해야 한다. 다음과 같은 데이터 구조, 작업, 동작은 모두 측정하자.

- 리소스 풀, 캐시, 데이터 구조, CPU 집약적 작업, IO 집약적 작업, 데이터 크기, 예외와 에러, 원격 요청 및 응답

<br>

### 오늘날 분산 환경에서 더욱 중요해진 추적

개발자라면 누구나 스택 추적에 대해 알고 있지만, 잘 알려지지 않은 **분산 호출 추적**이라는 유형의 추적도 있다. 분산 추적은 에러의 디버깅, 성능 측정, 의존성 관계, 시스템 비용 분석을 파악하는 데 유용하다.

<br>

### 설정으로 런타임 동작을 손쉽게 조정하려면

애플리케이션과 서비스는 개발자나 사이트 신뢰성 엔지니어가 런타임 동작을 조정할 수 있는 설정을 제공해야 한다. 설정 권장 기법을 적용하면 코드를 더 쉽게 실행할 수 있다. 이때 창의성을 지나치게 발휘하지는 말자. 표준 설정 형식을 사용하고, 적절한 기본값을 제공하며, 설정 입력값을 검증하고, 가능하다면 동적 설정은 피하자.

설정은 다양한 방법으로 표현할 수 있다.

- INJ, JSON, YAML처럼 일반 텍스트이면서 사람이 읽을 수 있는 형식의 파일
- 환경 변수
- 명령줄 플래그flag
- 커스텀 도메인 전용 언어
- 애플리케이션 구현에 사용된 언어

<br>

#### 지나치게 창의적인 설정은 금물이다

설정 시스템은 단순해야 한다.

누군가 설정 시스템을 개선하자고 하면 솔깃할 것이다. 설정은 누구에게나 익숙하며 단순한 설정 시스템에는 변수 교체나 if문 같은 유용한 기능이 누락된 것처럼 보이기도 하기 때문이다. 하지만 화려한 설정 시스템을 구현하기 위해 엄청난 시간을 쏟아부을수록 더 괴상한 버그가 나타날 수 있다. 원하는 동작을 할 수 있는 가장 간단한 방법을 채택하자. 단일 표준 형식을 채택한 정적 설정 파일이 가장 이상적이다.

대부분의 애플리케이션은 정적 설정 파일을 이용해 설정을 적용한다. 애플리케이션이 실행 중인 동안에 이 파일을 변경해도 애플리케이션의 동작은 바뀌지 않는다. 이 변경사항을 적용하려면 애플리케이션을 재시작해야 한다. 애플리케이션을 재시작하지 않고도 설정을 적용해야 할 때는 동적 설정 시스템을 사용한다.

동적설정은 그 복잡성 때문에 대부분의 경우에는 권장하지 않는다. 하지만 동적 설정이 필요한 경우도 몇 가지 있다. 로그의 상세함 정도는 대체로 동적 설정이다.

<br>

#### 모든 설정을 로그에 기록하고 검증하자

애플리케이션이 어떤 설정값을 사용하는지 알 수 있도록 시작 시점에 즉시 설정값을 로그에 기록하자. 설정값을 로그에 기록하면 애플리케이션이 적절한 설정값을 로드했는지 여부를 확인할 수 있다.

설정값을 로드할 때는 항상 검증해야 한다. 유효한 enum 값을 가졌는지 등 설정값의 논리도 확인하자.

<br>

#### 기본값을 제공하자

대부분의 사용자가 시스템을 곧바로 사용할 수 있도록 적절한 기본값을 제공하자.

<br>

#### 관련된 설정을 그룹화하자

애플리케이션 설정은 특히 중첩된 설정을 지원하지 않는 키-값 형식인 경우 금세 크기가 커져서 관리가 불가능해진다. 중첩을 지원하는 YAML 같은 표준 형식을 사용하자. 관련된 속성을 그룹화하면 쉽게 정리하고 관리할 수 있다.

<br>

#### 설정도 코드처럼 테스트하자

**코드로서의 설정(CAC)**은 설정도 코드처럼 취급해야 한다는 철학이다. 설정에 실수가 있으면 큰 문제가 될 수 있다. 정수값 하나를 잘못 설정하거나 파라미터를 빼먹으면 애플리케이션에 문제가 생긴다.

설정을 안전하게 변경하려면 설정도 버전 제어 시스템으로 관리하고 리뷰하고 테스트하고 빌드하고 배포해야 한다.

<br>

#### 설정 파일은 깔끔하게 유지하자

설정 파일이 깔끔하면 다른 사람이 이해하고 변경하기가 쉽다. 사용하지 않는 설정은 지우고 표준 형식과 공백을 사용해야 하며, 잘 모르면서 다른 파일에서 설정을 복사해 붙여넣는 일은 금하자.

<br>

#### 배포된 설정은 변경하지 말자

특정 머신의 설정을 수작업으로 수정하는 일은 금하자. 이렇게 일시적으로 변경한 설정은 다음 배포 과정에서 다시 원래 값으로 덮어써진다. 누가 변경을 만들었는지도 분명하지 않으며 비슷한 설정을 가진 머신이 늘어날 수 있다.

<br>

### 때로는 도구가 운영의 성패를 결정짓기도 한다

시스템은 운영자가 공통적인 운영 작업을 할 수 있는 도구를 제공해야 한다.

(도구 작성에는 협업이 필요하다. 경우에 따라서는 여러분이 운영 도구를 작성해서 제공해야 할 수도 있다. 어떤 경우든 운영 팀과의 협업을 통해 수요를 파악해야 한다.)

<br>

### 개발자의 필수 체크리스트

![image](https://github.com/BRIDGE-DEV/BRIDGE_BookClub/assets/80298207/608c0131-5dca-4e61-abf9-72bf1246338d)

<br>

### 레벨업을 위한 읽을거리

운영 가능한 코드를 작성하는 방법에 대해서만 집중해 다루는 책은 거의 없지만 이 주제를 몇 개 장에 걸쳐 다루는 서적은 몇 권 있다.
- 스티브 맥코넬의 \<Code Complete\>
- 로버트 C. 마틴 \<Clean Code\>

<br>

### 생각

몇가지 참고하면 좋은 내용들도 있었지만 게임 프로그래머로서 해당이 안되거나 잘 모르는 내용이 꽤 많아서 적당히 넘기면서 읽었다.
