# 필독! 개발자 온보딩 가이드

## 5장. 피할 수 없는 코드 의존성의 관리

> 복잡한 프로그램을 짜봐야 비로소 깨닫는 의존성의 진실

코드에 의존성을 추가하는 것은 그다지 어려운 결정이 아니다. '같은 일을 반복하지 말라(DRY)'는 매우 보편적인 원칙이다. 애플리케이션 프레임워크, 머신러닝 패키지 등 우리가 손수 구현할 필요가 없는 라이브러리의 예시는 얼마든지 널려 있다. 하지만 의존성에는 호환성 없는 변경, 순환 의존성, 버전 충돌, 통제 불가능 등 다양한 위험성이 내포돼 있다. 따라서 의존성을 추가할 때는 이런 위험을 인지하고 사전에 완화할 수 있는 방법을 반드시 고려해야 한다.

이번 장에서는 의존성 관리에 대한 기본 내용을 설명하고 모든 엔지니어에게 악몽과도 같은 의존성 지옥dependency hell에 대해 알아보려고 한다.

<br>

### 의존성 관리를 이해하기 위한 필수 개념

먼저 의존성과 버저닝versioning의 기본적인 개념을 알아보자.

의존성dependeny이란 여러분의 코드가 의존하는 코드를 말한다. 또한 그 의존성이 필요한 시점, 즉 컴파일 시점, 테스트, 런타임 등을 의존성 범위scope라고 부른다. 의존성은 패키지 관리 파일 또는 빌드 파일에 선언한다.

패키지의 버전은 의존성을 변경하고 동일 패키지의 다른 버전이 등장할 경우 충돌을 해결하는 데 주로 사용된다. 버저닝 스키마versioning scheme를 잘 따르는 버전은 다음과 같은 특징을 갖는다.

- 고유성: 버전은 재사용되지 않아야 한다. 변경된 코드를 이미 존재하는 버전으로 재배포해서는 안 된다.
- 비교성: 버전은 사람과 도구가 버전의 우선권을 이해하는 데 도움이 된다. 우선권은 동일한 산출물의 여러 버전에 빌드가 의존하는 경우 충돌을 해결하는 데 사용된다.
- 정보성: 버전은 사전 릴리즈한 코드와 정식 릴리즈한 코드를 구분하고 산출물에 빌드 번호를 매기며 안정성과 호환성을 설명해준다.

<br>

#### 시맨틱 비저닝

시맨틱 버저닝semantic versioning(SemVer)은 가장 보편적으로 사용하는 버저닝 스키마 중 하나이다. 이 명세에는 주major, 보조minor, 패치patch(or micro) 버전 등 세 가지 숫자로 버전을 정의한다. 버전 번호는 MAJOR.MINOR.PATCH 형식으로 조합한다.

시맨틱 버전은 고유성과 비교성, 정보성을 모두 갖추고 있다. 각 버전 번호는 한 번만 사용하며 왼쪽에서 오른쪽 방향으로 읽어 비교할 수 있다. 시맨틱 버전은 서로 다른 버전 사이의 호환성에 대한 정보가 제공되며, 릴리즈 후보나 버전 번호 정보 같은 추가 정보를 덧붙일 수도 있다.

주 버전이 0인 버전은 '사전 릴리즈'이다.

주 버전이 1이 되면 프로젝트는 다음 요건들을 보장해야 한다.

- 패치 버전은 하위 호환성을 갖는 버그 수정이 일어날 때마다 증가한다.
- 보조 버전은 하위 호환성을 갖는 기능을 추가할 때마다 증가한다.
- 주 버전은 하위 호환성을 갖지 못하는 변경을 추가할 때마다 증가한다.

SemVer는 패치 버전 뒤에 - 문자를 붙여서 사전 릴리즈 버전을 정의하기도 한다.

<br>

#### 이행적 의존성

패키지 관리나 빌드 파일은 프로젝트의 직접 의존성을 보여주지만 직접 의존성은 빌드나 패키징 시스템이 실제로 사용하는 의존성의 일부에 불과하다. 의존성은 다른 라이브러리에 주로 의존하며, 이를 일컬어 **이행적 의존성transive dependency**이라고 한다.

이행적 의존성을 이해하는 것은 의존성 관리에서 매우 중요한 부분이다. 의존성 하나를 추가하는 일은 작은 변경인 듯하지만, 만일 그 라이브러리가 100개의 의존성을 가지고 있다면 여러분의 코드는 이제 101개의 라이브러리에 의존하게 되는 셈이다. 이 의존성 중 어느 하나라도 변경되면 여러분의 프로그램은 영향을 받게 된다.

<br>

### 현업이면 누구나 한 번은 겪는 의존성 지옥

동일 라이브러리의 버전 충돌이나 라이브러리 업그레이드 후의 비호환성 문제는 빌드를 깨뜨리고 런타임 장애를 유발하기도 한다. 의존성 지옥을 일으키는 가장 보편적인 주범은 순환 의존성, 다이아몬드 의존성, 버전 충돌이다.

라이브러리가 자기 자신을 이행적 의존성으로 갖게 되는 순환 의존성은 가장 심각한 경우다. (A가 B에 의존하며 B는 C에 의존하는데 C가 다시 A에 의존하는 형태)

순환 의존성 문제는 닭과 달걀 문제를 야기한다. 한 라이브러리를 업그레이드하면 다른 라이브러리가 깨지는 것이다. 유틸리티나 헬퍼 프로젝트에서 이런 순환 의존성 문제가 빈번하게 발생한다.

<br>

#### 의존성 지옥에서 탈출하자

여러분도 분명히 의존성 지옥에 떨어질 때가 올 것이다. 의존성은 피할 수 없지만 뭐가 됐든 새로운 의존성이 추가될 때마다 비용이 따른다. 의존성의 가치가 그 비용보다 큰지 여러분 스스로 꼭 자문해보기 바란다.

<br>

#### 의존성을 격리하자

코드를 프로젝트로 복사해넣는 것은 더 높은 격리 수준(안정성)을 위해 의존성 관리 자동화를 포기하는 것이다. 딱 필요한 코드만 선택해 사용할 수 있지만, 그 대신 복사해넣은 코드는 직접 관리해야 한다.

코드 복사를 권장하지 않는 DRY 철학을 따르는 개발자가 대체로 많다. 하지만 실용적으로 생각하자. 더 큰 의존성 문제나 불안정한 의존성 문제를 피하는 데 도움이 된다면 (소프트웨어 라이선스가 허용하는 한) 코드를 복사하는 것에 지나친 죄의식을 갖진 말자.

코드 복사는 작고 안정적인 코드가 필요할 때만 선택할 수 있는 옵션이다. 라이브러리의 코드 전체를 복사하는 방식에는 몇 가지 단점이 있다. 버전 기록도 유지할 수 없으며 업데이트가 필요할 때마다 매번 코드를 다시 복사해야 한다. (이를 돕는 벤더 코드라는 도구도 있다.)

**의존성 가리기**도 의존성을 격리하는 방법 중 하나다. 의존성 가리기란 충돌을 피하기 위해 의존성을 다른 네임스페이스로 자동 이전하는 기법을 말한다. 이 방법은 라이브러리가 자신의 의존성을 애플리케이션에 강제하지 않게하는 괜찮은 방법이다. (의존성 가리기는 자바 생태계에서 처음 시작됐지만 그 개념이 광범위하게 적용되어 현재는 러스트 등의 언어도 유사한 기법을 채택하고 있다.)

의존성 가리기는 고급 기법으로, 반드시 필요한 경우에만 활용해야 한다. 충돌이 발생할 가능성이 높은 의존성을 광범위하게 사용하는 라이브러리를 만들고 있을 때만 의존성 가리기 기법을 적용하도록 권장한다.

<br>

#### 의존성은 신중하게 추가하자

여러분이 사용하는 모든 라이브러리는 명시적으로 의존성을 선언하자. 이행적 의존성 라이브러리가 제공하는 메소드와 클래스는 혹여 괜찮아 보일지라도 사용하지 말아야 한다. 라이브러리는 패치 버전을 올리면서도 의존성을 자유롭게 변경할 수 있다. 따라서 업그레이드된 라이브러리의 이행적 의존성이 사라지면 여러분의 코드는 더 이상 동작하지 않게 된다.

IDE에만 의존해 의존성을 관리해서는 안 된다. 의존성은 명시적으로 빌드 파일에 추가하자. IDE는 자체 프로젝트 설정에 의존성을 보관하는 경우가 많은데 빌드 머신은 IDE 자체 설정을 참조하지 않는다. IDE와 빌드 파일 간에 일관성이 없으면, 코드가 IDE에서 동작은 하는데 실제로 빌드는 되지 않는다거나 그 반대의 경우가 벌어진다.

<br>

#### 버전을 고정하자

모든 의존성의 버전 번호를 명시하자. 이 방법을 버전 고정version pinning이라고 부른다. 버전을 고정해두지 않으면 빌드나 패키지 관리 시스템이 버전을 결정하게 된다. 여러분의 운명을 빌드 시스템에게 맡기는 것은 결코 좋은 생각이 아니다. 빌드를 할 때마다 의존성 버전이 바뀐다면 여러분의 코드는 불안정해진다.

버전 범위의 경계를 지정하는 것은 경계 범위를 지정하지 않는 방법과 완전히 버전을 고정하는 방법 사이의 절충안이라 할 수 있다. 이 방법을 이용하면 의존성 해석 시스템이 자유롭게 충돌을 해결하고 의존성을 업데이트할 수 있으면서도 브레이킹 체인지에 노출될 가능성이 줄어든다. 반면, 버전을 고정하지 않으면 최신 버그 수정 외에도 더 많은 변경사항이 유입된다. 최신 버그 수정뿐만 아니라 새로운 버그, 동작의 변경, 심지어 호환되지 않는 변경까지 가져올 수 있따.

<br>

#### 의존성의 범위를 좁히자

앞서 설명했듯이 의존성의 '범위'는 의존성이 빌드 수명주기 내에서 언제 사용되는 것인지를 결정한다. 범위는 계층 구조를 갖는다. 컴파일타임 의존성은 런타임에도 사용되지만, 런타임 의존성은 코드 컴파일에 사용되지 않으며 단지 실행될 때만 사용된다. 테스트 의존성은 테스트를 실행할 때만 사용되며 코드를 배포해서 정상적으로 실행할 때는 사용되지 않는다.

의존성은 최대한 범위를 좁혀서 사용해야 한다. 모든 의존성을 컴파일 타임 범위에 추가하는 것은 좋은 방법이 아니다. 범위를 좁히면 충돌과 런타임 바이너리의 크기를 줄일 수 있다.

<br>

#### 순환 의존성에 주의하자

절대로 순환 의존성이 발생해서는 안 된다. 순환 의존성은 시스템의 오동작과 배포 순서 문제를 유발한다. 빌드가 잘되는 것 같다가 갑자기 실패하기도 하며, 애플리케이션은 찾아내기 힘든 우발성 버그에 시달릴 것이다.

빌드 도구를 이용해 여러분 스스로를 보호하자. 빌드 시스템은 대부분 순환 의존성을 탐지하고 발견시 경고를 보여주는 내장 기능을 제공한다. 빌드 시스템에 순환 의존성 보호 장치가 없다면 대부분의 경우 플러그인으로 해결 가능하다.

<br>

### 개발자의 필수 체크리스트

![image](https://github.com/BRIDGE-DEV/BRIDGE_BookClub/assets/80298207/819fa9fe-4a17-4809-b8e8-fdb14e9b187f)

<br>

### 생각

저번 장이 현재 내가 참고할 부분이 15퍼였다면 이번 장은 25퍼 정도..?
이번 장은 내가 자주 고민하는 코드 의존성보다는 패키지 단위의 의존성에 대해 다룬다.
회사에 다니게 되면 다시 읽어보면 좋지 않을까..

### 논의사항

- 버전 변경으로 인해 불편함을 겪은 적이 있다면 이야기해주세요.