# 4장 운영 환경을 고려한 코드 작성

> 개발 환경과 프로덕션 환경은 엄연히 다르다

이번 4장에서는 프로덕션 환경에서 코드를 쉽게 운영할 수 있는 권장 기법 몇 가지를 설명한다.

### 장애에 대비하기 위한 방어적 프로그래밍 방안

방어적 코드는 장애가 발생하는 빈도가 낮으며, 장애가 발생하더라도 대부분 복구된다. 안전한 코드는 컴파일 타임의 유효성 검사를 통해 런타임 장애를 최소화한다.

불변 변수를 사용하고, 접근 제어자를 통해 범위를 제한하며, 정적 타입 검사기를 활용해 버그를 줄이자. 런타임에 예상치 못한 일이 벌어지지 않도록 입력값을 검사하자.

**null 값 사용은 피하자**

변수가 널 값을 갖진 않았는지 검사하거나, 널 객체 패턴이나 옵션 타입 등을 사용해서 널 포인터 예외를 방지하자.

**널 객체 패턴**은 널 값 대신에 객체를 사용하는 패턴이다. 원하는 것을 찾지 못했을 때 null 값을 반환하는 대신 빈 객체를 반환하는 방법으로 활용된다.

**불변 변수를 활용하자**

불변 변수는 값이 한 번 대입되고 나면 그 값을 바꿀 수 없다. 불변 변수는 의도치 않게 변수의 값이 바뀌는 상황을 미연에 방지해준다. 또한 불변 변수를 사용하면 병렬 프로그래밍은 더 간단해지며, 변수 값이 바뀌지 않을 것임을 인지하는 컴파일러나 런타임은 더 효율적으로 동작할 수 있다.

**타입 힌트와 정적 타입 검사를 사용하자**

변수가 보관할 수 있는 값을 제한하자. 예를 들어 여러 문자열 값 중 하나만 가질 수 있는 변수는 String 타입보다는 Enum 타입으로 선언할 수 있다.

**입력값을 검사하자**

코드로 전달되는 입력값은 절대로 신뢰하지 말자. 개발자, 결함이 발생한 하드웨어, 사람의 실수 등으로 입력 데이터는 훼손될 수 있다.

제대로 된 입력값이 전달됐는지 확인해서 코드를 보호하자. 여러분이 쓰는 타입이 유효한 변수값을 완전히 다룰 수 없는 경우라면 사전 조건을 이용해 유효성을 검사하는 라이브러리와 프레임워크를 사용하자.

컴퓨터 하드웨어가 항상 믿을 만한 존재는 아니다. 네트워크와 디스크는 데이터를 훼손할 수 있다. 보안도 간과해서는 안된다. 외부로부터의 입력은 위험하다.

**예외를 활용하자**

null, 0, -1 같은 특정한 리턴값으로 에러를 표현하는 것은 금물이다. 모든 최신 개발 언어는 예외나 표준 예외 처리 패턴을 제공한다. 예를 들어 파이썬의 ZeroDivisionError는 None 리턴값이 제공하는 범위를 넘어서 훨씬 더 풍부한 정보를 리턴한다.

**예외는 구체적으로 사용하자**

예외를 구체적으로 정의하면 코드를 더 쉽게 사용할 수 있다. 가능하면 언어에 내장된 예외를 사용하고 포괄적인 의미를 담는 예외는 만들지 않게 하자.

언어에 내장된 예외 타입이 문제를 구체적으로 표현할 수 있다면 임의로 예외를 정의하지 말자. 다른 개발자들은 이미 내장 예외 타입을 다뤄본 경험이 있을 것이다.

예외를 직접 정의할 때는 너무 포괄적인 의미가 담기지 않게 하자. 예외의 이름이 너무 포괄적이면 어떤 문제가 발생했는지 파악할 수 없어 예외를 처리하기가 어려워진다. 예외는 최대한 구체적으로 정해두자.

또한 예외를 애플리케이션 로직에 사용해서는 안 된다.

**예외는 일찍 던지고 최대한 나중에 처리하자**

**일찍 던지고 늦게 잡는** 원칙을 따르자.

**일찍 던진다**는 말은 개발자가 관련 코드를 신속하게 찾을 수 있도록 에러가 발생한 지점으로부터 최대한 가까운 지점에서 예외를 던진다는 뜻이다. 실제 에러가 발생한 지점으로부터 너무 멀리서 예외를 던지면 어디서 문제가 생겼는지 찾기가 어려워진다.

**예외를 늦게 잡는다**는 말은 예외를 처리할 적절한 위치에 도착할 때까지 계속 호출 스택을 통해 전파시킨다는 뜻이다.

어설픈 에러 처리 중 최악의 경우는 처리할 수 없는 예외를 catch 블록 내에서 무시하고 그냥 ‘삼켜버리는’ 것이다. 이러면 장애가 발생해도 아무도 알 수가 없으며 최악의 결과를 야기할 가능성도 있다. 호출하는 코드가 예외를 던지면 예외를 완전히 처리하거나 상위 스택으로 전파하자.

**재시도는 현명하게**

에러를 적절하게 처리하는 방법 중 하나는 단순히 다시 시도하는 것이다.

가장 손쉬운 재시도 방식은 단순히 예외를 잡아서 그 즉시 작업을 다시 시도하는 것이다. 그런데 재시도한 작업이 또 실패하면 어떻게 해야 할까?

**백오프**라는 전략을 사용하는 것이 좋다. 백오프는 비선형으로 대기 시간을 늘리는 방법이다. 백오프의 시간을 정해서 대기 시간이 너무 길어지지 않게 하자.

실패한 요청을 무턱대고 재시도하지는 말자. 설계 시점에서 처리를 염두에 두지 않은 에러가 발생하면 차라리 애플리케이션이 크래시하도록 놔두는 편이 낫다. 이런 방법을 **빨리 실패하기**라고 한다.

**시스템에 멱등성을 부여하자**

장애가 발생한 후의 시스템 상태를 항상 명확하게 파악할 수 있는 것은 아니다. 재시도를 처리하는 가장 좋은 방법은 멱등성 있는 시스템을 구현하는 것이다.

멱등성이란 동일한 작업을 여러 번 실행해도 항상 같은 결과가 출력됨을 말한다. 예를 들어 어떤 값을 해시셋에 추가하는 것은 멱등 작업이다. 몇 개의 값을 집어넣든 하나만 존재하기 때문이다.

모든 작업을 멱등 작업으로 구현하면 시스템의 상호작용이 훨씬 간단해지며 발생 가능한 에러도 현저히 줄어든다.

**리소스를 해제하자**

장애가 발생하면 모든 리소스를 해제해야 한다. 더 이상 필요하지 않는 메모리, 데이터 구조, 네트워크 소켓 등을 모두 해제하자.

현대 개발 언어들의 상당수는 자동 리소스 해제 기능을 지원한다.

### 문제 원인을 찾기 위한 로깅 방안

로그 메시지를 출력하는 것은 코드의 실행을 이해하거나 작은 프로그램을 디버깅할 수 있는 쉽고 편리한 방법이다.

코드를 쉽게 운영하고 디버그할 수 있도록 로깅 프레임워크를 활용하자. 로그 레벨을 설정해서 운영자가 애플리케이션의 로그 양을 조정할 수 있게 하자. 로그는 원자적이며 빠르며 안전하게 다뤄야 한다.

**로그 레벨을 사용하자**

로그 레벨을 활용하면 매우 상세한 디버깅 로그부터 정상적인 우영 상황에서 주기적으로 기록되는 로그까지, 주어진 상황에 맞춰서 로그의 양을 조절할 수 있다.

- TRACE: 특정 패키지나 클래스에서만 켜지며 최대한 상세한 내용을 출력하는 레벨
- DEBUG: 프로덕션 상황에서 문제가 발생했을 때 적합한 레벨
- INFO: 애플리케이션 상태에 대해 알아두면 좋을 만한 정보를 위한 레벨 (문제점 파악 X)
- WARN: 잠재적으로 문제가 될 만한 상황에 대한 메시지를 위한 레벨
- ERROR: 살펴봐야 할 에러가 발생했을 때를 위한 레벨
- FATAL: 가장 위험한 수준의 메시지를 출력하기 위한 레벨

**로그는 원자적으로 작성하자**

만일 데이터와 결합했을 때만 정보가 유용하다면 한 메시지에 모든 정보를 **원자적으로** 저장하자. 다만 로그가 특정 순서대로 보일 것이라는 기대는 하지 말자. 운영 도구 중 상당수가 로그를 재정렬하거나 심지어 메시지를 놓칠 수 있다.

**로그는 신속하게 기록하자**

로그를 너무 많이 기록하면 성능에 영향을 미친다. 로그는 디스크나 콘솔, 원격 시스템 등 어딘가에 반드시 기록돼야 하며, 기록하기 전에 올바른 형태의 한 문자열로 결합해야 한다.

문자열 결합 작업은 매우 느리게 진행되며 성능이 중요한 루프에 악영향을 미친다. 로그가 실제로 기록될 때만 해당 호출이 평가되어 문자열 결합이 되도록 하자.

로그의 상세함 정도와 설정을 변경하면 애플리케이션이 느려지므로 경합 상태와 버그가 숨어버릴 수 있다.

**민감한 데이터는 로그에 기록하지 말자**

민감한 데이터를 다룰 때는 주의를 기울여야 한다. 로그에 기록하면 보안 위험이 발생할 수 있고 개인정보 보호 규제를 위반하게 될 수도 있기 때문이다.

### 애플리케이션 동작 측정을 위한 지표 활용 방안

지표를 이용해 애플리케이션이 어떤 동작을 하는지 살펴보자. 지표는 크게 카운터, 게이지, 히스토그램 등 세 가지 유형으로 나누는 것이 보편적이다.

- 카운터: 특정 이벤트가 발생한 횟수를 측정 (캐시 히트 카운터, 요청 카운터)
- 게이지: 특정 시점을 기준으로 측정하므로 값이 올라가거나 내려감 (큐, 스택, 맵의 크기 같은 통곗값)
- 히스토그램: 규모에 따라 이벤트를 특정 범위로 구분 (요청 처리에 걸린 시간, 데이터 크기)

시스템 성능은 99백분위수처럼 임계값 백분위수의 지표값으로 측정한다. 예를 들어서 P99 레이턴시가 2밀리초인 시스템은 수신하는 요청의 99퍼센트에 대해서 2밀리초 내에 응답을 제공한다.

서비스 수준 목표(SLO)는 P99라면 그에 따라 시스템에 대해 설정을 조정해야 한다.

애플리케이션 지표는 중앙식 **관측용이성 시스템**에 수집한다. 관측용이성은 제어 이론에 등장하는 개념으로 시스템의 출력을 통한 현재 상태 파악이 얼마나 용이한지를 정의한다.

**오토스케일링**은 동적 리소스 할당을 지원하는 환경에서는 보편적으로 적용된다. 오토스케일링은 필요한 경우에는 서버의 용량을 늘리고 평소에는 비용 절약을 위해 용량을 줄이기도 한다.

SLO를 준수하려면 관측용이성 시스템을 사용하고 오토스케일링을 활용하자.

**표준 지표 라이브러리를 사용하자**

카운터, 게이지, 히스토그램을 쉽게 계산할 수 있다고 해서 지표 라이브러리를 직접 구현할 생각은 금물이다. 비표준 라이버르리의 유지보수는 악몽에 가깝다. 만약 정해진 라이브러리가 없다면 동료들과 어떤 라이브러리를 도입할지 논의하자.

**모든 것을 측정하자**

측정은 비용이 적게 드는 작업이므로 가급적 많은 지표를 수집해야 한다. 다음과 같은 데이터 구조, 작업, 동작은 모두 측정하자.

- 리소스 풀
- 캐시
- 데이터 구조
- CPU 집약적 작업
- IO 집약적 작업
- 데이터 크기
- 예외와 에러
- 원격 요청 및 응답

### 오늘날 분산 환경에서 더욱 중요해진 추적

**분산 호출 추적**이라는 유형의 추적도 있다. 분산 호출 추적은 다운스트림 호출을 한데 모아 하나의 그래프로 만들어준다.

### 설정으로 런타임 동작을 손쉽게 조정하려면

애플리케이션과 서비스는 런타임 동작을 조정할 수 있는 설정을 제공해야 한다. 설정 권장 기법을 적용하면 코드를 쉽게 실행할 수 있다.

설정은 다양한 방법으로 표현할 수 있다. 가장 보편적인 방법은 사람이 읽기 편한 설정 파일, 환경 변수, 명령줄 플래그를 사용하는 방법이다.

**지나치게 창의적인 설정은 금물이다**

설정 시스템은 단순해야 한다. 지나치게 창의적인 설정은 금물이다. 원하는 동작을 할 수 있는 가장 간단한 방법을 채택하자. 단일한 표준 형식을 채택한 정적 설정 파일이 가장 이상적이다.

대부분의 애플리케이션은 정적 설정 파일을 이용해 설정을 적용한다. 애플리케이션을 재시작하지 않고도 설정을 적용해야 할 때는 동적 설정 시스템을 사용한다.

동적 설정은 그 복잡성 때문에 대부분의 경우에는 권장하지 않는다. 중간에 여러 가지 설정이 바뀔 수 있다는 가능성을 철저히 생각해야 하기 때문이다. 대부분의 경우에는 새로운 설정을 적용하기 위해 프로세스를 재시작하는 것이 운영 면이나 아키텍처 면에서 가장 좋은 방법이다.

동적 설정이 필요한 경우도 몇 가지 있다.

**모든 설정을 로그에 기록하고 검증하자**

애플리케이션이 어떤 설정값을 사용하는지 알 수 있도록 시작 시점에 즉시 설정값을 로그에 기록하자. 설정값을 로그에 기록하면 애플리케이션이 적절한 설정값을 로드했는지 여부를 확인할 수 있다.

**기본값을 제공하자**

대부분의 사용자가 시스템을 곧바로 사용할 수 있도록 적절한 기본값을 제공하자.

**관련된 설정을 그룹화하자**

애플리케이션 설정은 특히 중첩된 설정을 지원하지 않는 키-값 형식인 경우 금세 크기가 커져서 관리가 불가능해진다.

강하게 결합된 파라미터를 하나의 구조로 묶으면 둘 사이의 관계가 명확해지며 운영자는 해당 값을 한 번에 선언할 수 있다.

> timeout_duration=10, timeout_units=second → “timeout: {”duration”:10, “units”:”second”}”

**설정도 코드처럼 테스트하자**

**코드로서의 설정(CAC)**은 설정도 코드처럼 취급해야 한다는 철학이다. 설정을 안전하게 변경하려면 설정도 버전 제어 시스템으로 관리하고 리뷰하고 테스트하고 빌드하고 배포해야 한다.

**설정 파일을 깔끔하게 유지하자**

설정 파일이 깔끔하면 다른 사람이 이해하고 변경하기가 쉽다. 사용하지 않는 설정은 지우고 표준 형식과 공백을 사용해야 하며, 잘 모르면서 다른 파일에서 설정을 붙여넣는 일은 금하자.

**배포된 설정은 변경하지 말자**

특정 머신의 설정을 수작업으로 수정하는 일은 금하자.

설정 파일을 깔끔하게 관리하는 것과 마찬가지로, 프로덕션 환경의 설정 파일을 손수 고치고 싶은 욕구를 억제하는 것은 어렵다. 수작업으로 설정을 수정해야 한다면 나중에라도 변경된 설정을 버전 제어 시스템에 커밋해두자.

### 때로는 도구가 운영의 성패를 결정짓기도 한다

운영 가능한 시스템은 운영자가 애플리케이션을 실행하는 데 도움이 되는 도구들을 제공한다.

도구 작성에는 협업이 필요하다. 경우에 따라서는 여러분이 운영 도구를 작성해서 제공해야 할 수도 있다.

여러분이 작성하는 도구를 표준 프레임워크와 통합해서 **통합 관리 콘솔**에서 사용할 수 있게 하자. 모든 사람이 기존 도구의 UI에 익숙할 것이므로, 기존 도구와 통합하면 더 손쉬운 사용이 가능할 것이다.

### 필수 체크리스트

| O 이것만은 지키자 | X 이것만은 피하자 |
| --- | --- |
| 런타임 에러보다는 컴파일 타임에 에러를 검출하자 | 예외를 이용해 애플리케이션 로직을 결정해서는 안 된다 |
| 가능하면 불변 변수를 사용하자 | 리턴 코드로 예외를 처리해서는 안 된다 |
| 입력과 출력을 검증하자 | 처리할 수 없는 예외는 잡지 말자 |
| 버그 확인 도구는 물론 타입 또는 타입 힌트도 사용하자 | 로그를 여러 줄로 나누지 말자 |
| 예외 발생 시에는 리소스를 해제하자 | 보안 정보나 민감한 데이터를 로그에 기록하지 말자 |
| 코드에 지표를 추가하자 | 머신의 설정을 직접 수정하지 말자 |
| 애플리케이션에 설정에 추가해두자 | 보안 정보를 설정 파일에 기록하지 말자 |
| 모든 설정을 검증하고 로그에 기록하자 | 불필요한 동적 설정은 사용하지 말자 |

### 레벨업을 위한 읽을거리

- 스티브 맥코넬 <코드 컴플리트> 8장: 방어적 프로그래밍
- 로버트 C. 마틴 <클린 코드> 7장, 8장: 에러 처리와 경계
- 구글 SRE 그룹 <SRE를 위한 시스템 설계와 구축>: 보안 관점의 조언들
- 제이펍 <사이트 신뢰성 엔지니어링>: 사이트 신뢰성과 관련된 모든 것

---

## 느낀 점

관련 예시들은 많이 나왔는데, 그 내용들이 전부 웹과 관련된 개념같아 보였다. 나에게는 전부 생소한 개념들이라 눈에 잘 들어오지 않았다.. 과연 저 개념들이 게임 개발에도 적용이 되고 있을까? 하는 궁금증이 생겼다.

사실 로그 남기는 건 게임에도 분명 있긴 할텐데.. 보통 통신 관련된 기록이 남는 걸 많이 봐서 그런가, 아직 내가 직접 해봐야겠다는 생각은 못해본 것 같다. 아직도 모르는 개념 투성이라 조금 더 알아봐야겠다.

---

## 논의사항

- 여러분들은 개발할 때 예외 처리를 이용하시나요?

C#에도 당연히 throw와 try~catch문이 있는 걸로 아는데, 사실 게임 프로젝트를 진행할 때는 한번도 사용해본 적이 없는 것 같습니다. 이용해본 적이 있으신지, 없으면 왜 게임 개발할 때는 안쓰게 되는지도 얘기해보면 재밌을 것 같아요.