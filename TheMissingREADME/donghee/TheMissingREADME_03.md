# 3장 코드와 함께 춤을

## 정리

> 레거시 코드에 임하는 우리의 자세

이번 3장에서는 기존 코드를 활용해 작업하는 방법을 보여준다.

### 소프트웨어 엔트로피는 늘어나게 마련이다

코드의 단점을 발견해 여기저기 바꾸다보면 지저분해지는 것은 자연스러운 일이다. 이렇게 코드가 지저분해지는 것을 **소프트웨어 엔트로피**라고 부른다.

소프트웨어 엔트로피는 다양한 이유로 생겨난다. 다른 사람이 쓴 코드를 이해하지 못하거나, 서로 코딩 스타일이 달라서 발생하기도 한다. 요구사항을 개선하다 보면 혼란이 가중된다. 또한 버그 수정과 최적화도 복잡도를 증가시킨다.

소프트웨어 엔트로피는 관리가 가능하다.

- 코딩 스타일과 버그 탐지 도구: 코드를 깔끔하게 유지하는데 도움을 준다.
- 코드리뷰: 지식을 전파하고 일관성이 떨어지는 것을 방지하는 데 도움을 준다.
- 지속적인 리팩터링: 엔트로피를 낮출 수 있다.

### 결코 피할 수 없는 기술 부채

**기술 부채**란 기존 코드의 단점을 수정하면서 나중으로 미뤄둔 작업을 말한다.

기술 부채에도 원금과 이자가 있다. 원금은 수정해야 할 원래의 단점을 의미한다. 이자는 본질적인 단점을 수정하지 않고 코드를 개선할 때 발생하는 비용을 뜻한다.

어떤 문제를 기술 부채로 정의하려면 팀이 ‘이자를 지불해야 하는’ 것이거나 심각한 문제를 유발할 수 있는 위험 요인이어야 한다.

부채는 두려운 것이지만 그렇다고 모든 부채가 나쁜 것만은 아니다.

|  | 신중하지 못한 선택 | 신중한 선택 |
| --- | --- | --- |
| 의도한 선택 | 출시일 압박(’일단’) | 트레이드오프의 산물 |
| 의도치 않은 선택 | 알려지지 않는 미지 | 성장 과정에서 나타남 |

**신중히 고민하고 의도적으로 만들어진 부채**는 보편적으로 발생하는 기술 부채 유형이다. 코드의 단점과 출시 속도 사이에서 고민하다 결정한 실용적 트레이드오프이다. 나중에라도 팀이 해결 가능하도록 훈련된 부채라면 이는 좋은 부채이다.

**신중하지 못했지만 의도적으로 만들어진 부채**는 팀이 출시일 압박을 받는 상황에서 만들어진다. 어떤 결정이 신중하지 못한 부채임을 의미하는 단어는 ‘일단’이다.

> ‘일단’ 나중에 추가합시다.

**신중하지도 못하고 의도치도 않았던 부채**는 알려지지 않은 미지, 즉 몰라서 모르는 것들 때문에 발생한다. 사전에 구현 계획을 작성하고 코드 리뷰를 수행하는 것으로 완화할 수 있다.

**신중했지만 의도치 않게 발생되는 부채**는 성장 과정에서 자연스럽게 나타나는 결과다. 신중히 고민하고 의도적으로 만들어진 부채와 달리, 팀은 이런 결정이 향후 부채를 유발하리라는 점을 전혀 알 수 없을 것이다. 건전한 팀은 프로젝트 회고 같은 절차를 활용해 의도치 않았던 부채를 찾아내고 부채의 해결 여부와 적절한 해결 시점을 논의한다.

부채는 성공의 표시일 수도 있다. 프로젝트가 지저분해질 정도로 오래 살아남았다는 뜻이기도 하니까.

**기술 부채를 상환하는 방법**

문제를 해결할 수 있도록 한달 동안 온세상이 멈춰주지는 않는다. 업무를 진행하면서 필요한 부분은 정리하고 **리팩터링**을 하자.

조금씩 꾸준히 하는 리팩터링이 효율적이고 오히려 한 번에 크게 변경해야 할 때도 있다. 대규모 리팩터링은 꽤 중요한 결정이다. 대규모 리팩터링이나 재작성을 제안하려 한다면 팀과 먼저 의논해보자.

제안 내용은 문서로 작성하자. 여러분 각자가 판단한 가치를 기준으로 삼아서는 안 된다. 부채를 해결하는 데 드는 비용과 그럼으로써 얻을 수 있는 장점에만 집중하자.

### 코드 변경으로 인한 고통을 조금이라도 줄이려면

코드 변경은 새로운 리포지토리에 코드를 작성하는 것과는 다른 차원의 문제다. 다른 개발자의 사고 방식을 이해하고 기존 스타일과 패턴을 유지해야 한다.

**레거시 코드 변경 알고리즘을 활용하자**

마이클 C. 페더스의 저서 <레거시 코드 활용 전략>에서 기존 코드를 안전하게 수정할 수 있는 과정을 다음과 같이 소개했다.

1. 변경 지점을 확인한다.
    
    코드를 읽고 이것저것 실험해보며 변경해야 할 코드(변경 지점)를 알아내자.
    
2. 테스트할 지점을 확인한다.
    
    변경할 코드를 확인하고 난 뒤에는 테스트해야 할 부분을 알아내야 한다. **테스트 지점**은 수정하고자 하는 코드의 진입점, 즉 테스트가 직접 호출하고 값을 넣어보는 부분이다.
    
3. 의존성을 나눈다.
    
    의존성을 나눈다는 말은 테스트가 용이하지 않은 코드의 구조를 바꾼다는 말이다. 이 변경으로 인해 코드의 동작이 바뀌어서는 안된다.
    
    의존성을 나누는 방법은 여러가지다.
    
    - 메소드를 더 작은 크기의 메소드로 나눠서 각기 분리된 기능이 독립적으로 테스트될 수 있게 한다.
    - 인터페이스를 이용해, 복잡한 객체를 완전하지는 않아도 테스트하기에는 충분한 단순 구현체로 대체할 수 있는 방법을 마련하다.
    - 제어하기 어려운 실행 환경을 시뮬레이션할 수 있는 명시적 제어 지점을 주입한다.
4. 테스트를 작성한다.
    
    조금 더 쉽게 테스트하려는 목적으로 접근제어자를 변경해서는 안된다.
    
    의존성을 나누고 리팩터링을 하면서 기존 동작을 확인할 수 있는 새로운 테스트를 추가하게 된다.
    
5. 변경을 적용하고 리팩터링한다.
    
    의존성을 나누고 제대로 된 테스트가 준비됐다면 이제는 ‘정말로’ 코드를 변경할 때다. 코드가 안전하다는 사실을 알면 더 견고한 변경을 만들 수 있다.
    

처음 4개 과정은 밭에 씨를 뿌리는 5번째 과정 전에 주변을 정리하고 울타리를 치는 과정이라고 생각하자.

**코드는 처음보다 더 깔끔하게 유지하자**

버그를 수정하거나 새로운 기능을 추가할 때는 주변 코드를 정리하자. 그렇다고 지저분한 코드를 일부러 찾을 필요는 없다. 그저 기회가 생길 때 정리하면 된다.

코드를 정리하는 커밋은 동작을 변경하는 커밋과 구분하자. 커밋을 구분해두면, 코드를 정리하는 커밋을 유지하면서도 변경된 코드를 되돌릴 수 있다.

어떤 코드에서는 냄새가 난다. **코드 악취**란 버그는 아니지만 문제를 유발할 수 있는 패턴을 사용하는 코드를 말한다. 생략된 중괄호, 이름이 너무 긴 메서드나 클래스, 중복 코드, 너무 많은 분기나 루프, 너무 많은 매개변수 등이 해당된다.

**점진적으로 변경하자**

리팩터링은 대부분 둘 중 한 가지 유형을 띤다. 첫 번째는 수십 개의 파일을 한 번에 수정하는 ‘모조리 바꿔’ 식의 변경이다. 두 번째는 리팩터링과 새로운 기능이 뒤섞인 PR이다. 이 두 가지 변경은 리뷰하기가 훨씬 어렵다.

리팩터링 커밋은 작게 유지해야 한다. 변경사항을 추적하기가 어렵다면 더 작은 커밋을 사용하자. 마지막으로, 리팩터링을 마구잡이로 수행하기에 앞서 우선 팀의 동의를 얻어야 한다.

**리팩터링은 실용적으로 진행하자**

리팩터링이 항상 현명한 결정은 아니다. 리팩터링에는 시간이 필요하다. 리팩터링으로 얻을 수 있는 가치보다 리팩터링에 드는 비용이 더 클 수도 있다.

**IDE를 활용하자**

가능하다면 도구의 장점을 활용하자. 여러분이 사용하는 언어를 지원하는 좋은 IDE가 있다면 잘 활용하면 된다.

IDE는 특히 리팩터링을 할 때 특히 도움이 된다. 그렇다고 IDE가 변경한 코드를 그냥 지나쳐서는 안 된다. IDE를 이용하면 리팩터링이 너무 쉬워서 간단한 수정만으로 엄청난 양의 코드를 변경할 수 있다. 그렇기에 IDE가 자동으로 변경한 내용은 **반드시** 사람이 리뷰해야 한다.

**버전 제어 시스템의 권장 기법을 활용하자**

코드를 개발하는 동안 변경사항은 일찍 그리고 자주 커밋해야 한다. 하지만 커밋이 너무 잦으면 의미 없는 메시지로 도배되는 경우도 있다.

리뷰를 요청하기 전에는 브랜치를 리베이스하거나 커밋을 스쿼시해서 커밋 메시지를 명료하게 정리하자.

- 브랜치 리베이스:  한 브랜치의 베이스를 베이스 브랜치의 최신 커밋으로 이동하는 작업
- 커밋 스쿼시: 여러 커밋을 하나의 커밋으로 합치는 작업

### 소프트웨어 개발에서 빠지기 쉬운 함정을 최대한 피하려면

코드를 새로 작성하거나 표준 외의 방법을 도입하고자 한다면 여러분이 개선한 코드는 기존 코드보다 몇 배는 더 좋아야 한다. 비용이 너무 높으므로 그만큼 장점도 커야 한다.

대부분의 엔지니어는 규칙의 가치에 대해서는 과소평가하고 규칙을 무시하는 행위의 가치는 과대평가하는 경향이 있다.

고부가가치를 낼 수 있는 상황에서만 코드를 재작성하자. 가능하다면 평범한 기술을 사용하자.

**되도록 검증된 기술을 사용하자**

소프트웨어는 빠르게 변하는 분야다. 하지만 성공적인 기업이 오래된 라이브러리와 오래된 패턴으로 견고한 코드를 유지할 수 있는 데는 이유가 있다. 성공을 거두는 데는 시간이 걸리며, 기술을 갈아타는 것은 집중을 방해하는 요소가 되기 때문이다.

> 평범한 기술은 어디서 문제가 발생하는지가 잘 알려져 있다는 장점이 있다.
> 

새로운 기술은 의외의 방법으로 문제를 유발한다. 또한 기술의 성숙도가 낮다는 것은 커뮤니티 규모가 작으며, 안정성도 낮고, 문서화도 미흡하며, 호환성도 낮다는 사실을 의미한다.

새로운 기술을 언제 사용할지 알아내는 데는 훈련과 경험이 필요하다. 그리고 새로운 기술을 도입했을 때의 장점이 도입 비용보다 커야 한다. 물론 신기술이 회사의 경쟁력을 높여줄 수 있다면 그 기술을 도입할 만한 가치가 있다.

프로젝트에 새로운 프로그래밍 언어를 도입하는 것은 결과에 지대한 영향을 미친다. 새로운 언어를 선택하는 것은 회사의 생태계에 기술 스택 전체를 때려넣는 것이다. 새 빌드 시스템, 테스트 프레임워크, IDE, 라이브러리 등을 반드시 지원해야 하기 때문이다. 새로운 프레임워크를 도입하는 것과 비교해 새 언어를 도입하는 데는 3배의 비용이 더 든다.

매출 1조 원이 넘는 규모의 회사도 평범한 언어를 사용한다. 언어가 사장되지 않는 한, 단지 오래됐다거나 관심이 줄었다는 사실이 그 언어를 사용하지 않을 이유는 되지 못한다.

**제발 악동은 되지 말자**

단지 마음에 들지 않았다는 이유로 회사의 표준을 무시해서는 안 된다.

어쩌면 여러분이 수행하려는 방식이 정말로 더 나은 방법일 수도 있다. 그렇다고 해서 악동처럼 구는 것은 좋은 생각이 아니다. 단기적으로는 다른 사람이 하는 대로 따르자. 그 방법이 표준으로 채택된 이유를 되도록 이해해야 한다.

적절한 이유를 모르겠다면 주변에 물어보자.

**업스트림 없이 포크만 하는 것은 금물이다**

포크란 다른 소스 코드 리포지토리에 대한 완전하며 독립적인 복사본으로서 자체적인 트렁크, 브랜치, 태그 등을 갖는다. 깃허브같은 코드 공유 플랫폼에서는 업스트림 리포지토리에 PR을 보내기 전에 해당 리포지토리를 포크한다.

하지만 코드에 기여할 생각이 없으면서 해당 리포지토리를 포크하는 것은 권장되지 않는다. 소소한 변경은 시간이 지나도 업스트림 리포지토리에 적용되지 않는다. 그러다 보면 결국 완전히 다른 소프트웨어를 운영하게 되고, 업스트림 리포지토리에 기능을 추가하거나 버그를 수정하는 것이 엄청나게 어려워진다.

**코드 재작성에 대한 욕구를 견디자**

리팩터링을 하다 보면 기존 코드를 완전히 버리고 새로 작성하게 되는 경우가 있다. 코드를 새로 작성하는 것을 최후의 수단이라고 생각해야 한다.

코드 재작성이 나은 경우도 있지만 대부분은 그렇지 않다. 코드 재작성은 그에 들어가는 비용보다 장점이 클 때만 시도해야 한다. 코드 재작성은 위험할 뿐더러 소요 비용도 높기 때문이다.

### 필수 체크리스트

| O 이것만은 지키자 | X 이것만은 피하자 |
| --- | --- |
| 점진적으로 리팩터링하자 | ‘기술 부채’ 단어를 남용하지 말자 |
| 리팩터링과 기능 커밋은 구분하자 | 테스트를 목적으로 메소드나 변수의 캡슐화를 손상시켜선 안된다 |
| 변경사항을 작게 유지하자 | 특정 언어에 연연하지 말자 |
| 처음 상태보다 코드를 깔끔하게 유지하자 | 회사의 표준과 도구를 무시하지 말자 |
| 평범한 기술을 사용하자 | 업스트림 커밋 없이 포크는 안된다 |

### 레벨업을 위한 읽을거리

- 마이클 C. 페더스 <레거시 코드 활용 전략>: 대규모 복잡한 코드베이스를 다룰 때
- 마틴 파울러 <리팩터링 2판>: 리팩터링을 중점적으로
- 프레드 브룩스 <맨먼스 미신>: 소프트웨어 프로젝트가 실제로 어떻게 운영되는지

---

## 느낀 점

제일 다가왔던 부분은 커밋에 관한 부분.. 아직 짧게 커밋을 나누는 습관이 잘 되어 있지 않다보니 결국 하루동안 작업만 모든 부분을 하나의 커밋에 몰아넣기도 하고 분리가 쉽지 않은 것 같다. 특히나 리팩터링을 진행했을 때 만줄 넘게 한번에 바뀌었던 기억도.. 점진적으로 바꾸는 것, 쉽지 않아보이지만 항상 의식해야겠다.

---

## 논의사항

- 여러분들은 커밋을 할때 어떤 기준으로 나누시는 편인가요?

> 리팩터링은 대부분 둘 중 한 가지 유형을 띤다. 첫 번째는 수십 개의 파일을 한 번에 수정하는 ‘모조리 바꿔’ 식의 변경이다. 두 번째는 리팩터링과 새로운 기능이 뒤섞인 PR이다. 이 두 가지 변경은 리뷰하기가 훨씬 어렵다.

저는 위의 안 좋은 두가지 유형을 모두 했던 경험이 있어서 굉장히 뜨끔했습니다. 작게 커밋을 나누는 습관을 들이려고 해도 생각처럼 되지 않네요.. 여러분들의 생각이 궁금합니다!