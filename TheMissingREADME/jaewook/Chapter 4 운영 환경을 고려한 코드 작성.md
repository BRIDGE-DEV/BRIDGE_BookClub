


**운영 가능한 코드(operable code)란** 보호 장치, 분석 장치, 제어 장치가 내장된 코드를 말한다.

회복성 있는(resilent) 코딩 기법을 이용해 방어적(defensive)으로 프로그래밍해서 시스템을 보호해야 한다.

#### 장애에 대비하기 위한 방어적 프로그래밍 방안

**안전한 코드** : 컴파일 타임의 유효성 검사를 통해 런타임 장애를 최소화한다. 불변 변수를 사용하고, 접근 제어자를 이용해 범위를제한하며, 정적 타입 검사기를 활용해 버그를 줄이자.

**회복성 있는 코드** : 권장되는 예외 처리 기법을 활용하며 장애를 적절하게 처리한다.

#### null값 사용은 피하자

널 포인터 예외는 보편적으로 발생한다. 이에 방지하기 위해 변수가 널 값을 갖진 않았는지 검사하거나 널 객체 패턴이나 옵션 타입 등을 사용하자.

널 검사는 메소드의 시작지점에서! 
- NotNull 애노테이션과 같은 언어기능을 활용
- 변수의 값이 널이 아님을 사전에 확인하면 그 변수를 실젯값을 가진 안전한 변수로 활용할 수 있다.

**널 객체 패턴** : 널 값 대신 객체를 사용하는 패턴, 원하는 객체를 찾지 못했을 때 null이 아니라 빈 배열을 리턴하는 검색 메소드를 예시로 들 수 있다.

- 빈 배열을 리턴하면 호출자는 리턴된 값을 확인하는 특별한 코드가 없더라도 검색 결과를 확인할 수 있다.
- 옵션타입(Optional 이나 Maybe 같은)을 활용하는 것도 방법이다.

#### 불변 변수 사용

불변 변수는 의도치 않게 변수의 값이 바뀌는 상황을 미연에 방지해준다. 불변 변수를 사용하면 병렬 프로그래밍은 더 간단해지며, 변수 값이 바뀌지 않을 것임을 인지하는 컴파일러나 런타임은 더 효율적으로 동작한다.

#### 타입 힌트와 정적 타입 검사를 활용하자

변수를 선언할 때 구체적인 타입을 선언해 제한하면 예상치 못한 값을 대입해도 버그를 유발하지 않고 즉시 실패하게 된다. (정해진 문자열이라면 String 타입보다 Enum으로 선언)

파이썬과 같은 동적언어에서도 견고한 *타입 힌트*와 *정적 타입 검사기*의 지원이 늘어나고 있다. 타입힌트를 사용하면 동적 타입이던 변수에 타입을 지정할 수있다.

#### 입력값을 검사하자

코드로 전달되는 입력값은 신뢰하지 말자

다음과 같은 방법으로 입력값으 검사할 수 있다.

- 사전 조건
- 체크섬
- 데이터 유효성 검사
- 보안 관련 권장 기법

checkNotNull과 같은 메소드나 @size(min=0, max=100)과 같은 애노테이션을 활용해 사전 검사를 할 수 있다. 입력 문자열의 공백 처리나 숫자가 적절한 범위 안에 있는지 등을 검사하자.

**크로스 사이트 스크립팅** : 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적 콘텐츠를 삽입하거나, 피싱 공격을 진행하는 것을 말한다.


#### 예외 활용

 null, 0, -1과 같은 특정한 리턴값으로 에러를 표현하는 것은 금물이다. 리턴값은 메소드 시그니처에 명확하게 드러나지 않는다.  또한 어떤 리턴값이 어떤 에러를 의미하는지 기억하기 어렵다.

예외는 이름도 있고 스택 추적 정보, 줄 번호, 메시지 등의 정보를 담고 있어 훨씬 좋다.

#### 예외는 구체적으로 사용하자

대부분의 언어는 예외 타입을 제공한다.(FileNotFoundException, AssertionError, NullPointerException)

언어에 내장된 예외가 현재 문제를 구체적으로 표현할 수 있다면 임의로 예외를 정의하지말자.

- 예외를 직접 정의할 땐 문제에 대한 정확한 정보를 전달하자
- 예외를 애플리케이션 로직에 사용해서는 안된다. 
	- 예외를 이용해 메소드를 분기하면 이해도 어렵고 디버깅도 어려워진다.

#### 예외는 일찍 던지고 최대한 나중에 처리하자

**일찍 던진다 throw early** : 개발자가 에러가 발생한 지점을 빨리 찾기위해 발생한 지점에서 최대한 가까운 지점에 예외를 던진다.

**예외를 늦게 잡는다 catch exception late** : 예외를 처리할 적절한 위치에 도착할 때까지 계속 호출 스택을 통해 전파시킨다.

처리할 수 있는 방법이 많기 때문에 어설프게 중간 단계에서 에러를 처리하기보다 예외를 상위 계층으로 전파하는 방식이 옳다.

최악은 예외를 catch구문에서 삼키는 것이다.

```java
try{
///...
}
catch(exception e){
// 에러를 처리할 방법이 없으므로 무시한다.
}
```

발생한 예외를 처리하지 않고 로그에 기록되지도 않는 등 조치가 취해지지 않는다. 이러면 장애가 발생해도 알 수없는 최악의 상황을 야기할 수 있다.

#### 재시도는 명확하게

에러가 발생하면 재시도하는 것이 현명한 방법일 수 있다. 다만 약간의 노하우가 필요하다.

재시도한 작업이 계속해서 실패함에도 불구하고 계속해서 재시도한다면 시스템을 복구하기가 더 어려워질 것이다.

**백오프 backoff** : 비선형으로 대기 시간을 늘리는 방법, *재시도 횟수*와 같이 지수적(exponential) 백오프를 사용한다.

백오프의 상한선을 정해 대기 시간이 너무 길어지지 않게 한다.

네트워크 서버에  일시적인 문제가 생격 모든 클라이언트가 동시젖ㄱ으로 장애를 겪는 상황에 모든 클라이언트가 동일한 백오프를 사용한다면 동시에 요청을 다시 보내는 **천둥떼 thundering herd problem** 이 발생한다. 동시에 재시도 요청이 서버에 보내지면 복구중이던 서비스가 다운될 수 있다.

이를 해결하기 위해서 백오프 전략에 **지터 jitter**를 추가해야 한다.
지터는 특정 범위에서 임의의 값을 백오프 시간에 더해서 재시도 작업 타이밍을 더 넓은 시간대로 펼쳐 한 순간에 몰릴 가능성을 줄인다.

실패한 요청을 무작정 재시도하지 말고 차라리 애플리케이션이 크래시하도록 놔두는 것도 방법이다. (failing fast) 빨리 실패하는 것이 실패의 피해가 확산하지 않도록 하는 것이다.

#### 시스템에 멱등성을 부여하자

**멱등성 idempotent** : 동일한 작업을 여러 번 실행하더라도 항상 같은 같은 결과가 출력됨. 

ex) 어떤 값을 해시셋에 추가하는 것을 멱등작업이라고 한다. 어떤 값이든 하나만 존재하기 때문이다.

원격 API도 클라이언트가 각 요청마다 유일한 ID를 지정하게 하면 멱등성을 구현할 수 있다.

클라이언트가 재시도할 떄 이미 실패한 요청 ID를 전달하면 서버는 해당 ID의 요청을 이미 수행했기 때문에 작업을 수행할 필요가 없다 -> 시스템의 상호작용이 훨씬 간단해지고 오류를 줄일 수 있다.

#### 리소스를 해제하자

장애가 발생할 때는 모든 리소스를 해제해야 한다.

메모리, 데이터 구조, 네트워크 소켓, 파일 핸들 등을 해제하자.

현대 개발 언어들은 상당수 자동 리소스 해제 기능을 지원한다.

### 문제 원인을 찾기 위한 로깅 방안

코드를 쉽게 운영하고 디버그할 수 있도록 로깅 프레임워크를 활용하자.
로그는 원자적이고 빠르며 안전하게 다뤄야 한다.

#### 로그 레벨을 사용하자

**로그 레벨 log level** : 로깅 프레임워크에서 중요도에 따라 메시지를 필터링할 수 있도록 설정하는 것

- **TRACE** : 특정 패키지나 클래스에서만 켜지며 최대한 상세한 내용을 출력하는 레벨. 줄 단위 로그나 데이터 구조를 확인해야 할 때 필요하다.
- **DEBUG** : 프로덕션 상황에서 문제가 발생했을 때 적합한 레벨
- **INFO** : 애플리케이션 상태에 대해 알아두면 좋을 만한 정보를 위한 레벨 '서비스 시작', '5050번 포트 사용'과 같은 상태 메시지
- **WARN** : 잠재적으로 문제가 생길 만한 상황에 대한 메시지, WARN 로그를 출력할 때는 확인한 사람이 취해야 할 대책이 포함되어야 한다.
- **ERROR** : 살펴봐야할 에러가 발생했을 때를 위한 레벨, 문제를 분석하기에 충분한 정보를 제공해야 한다. 스택 추적, 실행 결과 등등
- **FATAL** : 가장 위험한 수준의 메시지를 출력하기 위한 레벨, 프로그램이 심각한 상황에 맞닥뜨려 즉시 종료시켜야 할 때, 문제를 유발한 원인을 적어놓아야 한다.

#### 로그는 원자적으로 작성

로그는 한 메시지에 모든 정보를 (한 줄에) 저장하자. 웬만하면 한 줄에 저장하고 한 줄에 저장하지 못하면 고유한 ID를 포함시켜 연결 가능하게 하자.

#### 로그는 신속하게 기록하자

- 파라미터화(parameterized) 로깅
- 비동기 어펜더(appender)

*문자열 결합 작업은 매우 느리게 진행되며 성능에 악영향을 미친다.* 결합을 시도하는 문자열이 로그 메소드에 전달되면 로그 레벨과 관계없이 결합이 실행된다.

**appender** : 어펜더는 콘솔이나 파일, 원격 로그 수집기 등 다양한 곳으로 로그를 전달한다.

**비동기 어펜더** : 실행중인 스레드를 블록하지 않고 로그 메시지를 기록한다. 코드가 로그를 기록하는 동안 기다리지 않아도 되어 성능이 향상된다.

**일괄batching 어펜더** : 로그 메시지를 디스크에 기록하기 전에 메모리에 보관해서 쓰기 처리량을 향상

#### 민감한 데이터는 로그에 기록하지 말자

#### 애플리케이션 동작 측정을 위한 지표 활용 방안

**지표(metrics)** : 숫자로 표현된 로그

- **카운터** : 특정 이벤트가 발생한 횟수 (증가나 초기화 밖에 없음)
- **게이지** : 특정 시점을 기준으로 측정하는 값, 증감을 확인할 수 있음. 큐나 스택, 맵의 크기 같은 통곗값을 제시해준다.
- **히스토그램**: 규모에 따라 이벤트를 특정 범위로 구분한다. 각 범위에는 이벤트 값이 발생하면 값이 증가하는 카운터가 있다. 요청 처리에 걸린 시간이나 데이터 페이로드(payload)크기 같은 지표를 측정한다.

**서비스 수준 목표 service level objective (SLO)**

시스템 성능은 99백분위수(P99)처럼 임계값 백분위수의 지표값으로 측정한다. P99 latency가 2밀리초인 시스템은 수신하는 요청의 99퍼센트에 대해서 2밀리초 내에 응답을 제공한다.


**관측용이성 시스템 observability system** : 제어 이론(control theory)에 등장하는 개념으로 시스템의 출력을 통한 현재 상태 파악이 얼마나 용이한지를 정의한다. 수집된 지표를 기반으로 하는 모니터링 도구와 대시보드 등을 제공한다.
- 데이터 독 Data Dog
- 로직모니터 LogicMonitor
- 프로메테우스 Prometheus

**오토스케일링 autoscaling** 

#### 표준 지표 라이브러리를 사용하자

- 비표준 라이브러리의 유지보수는 악몽이다.
- 표준 라이브러리는 모든 것과 통합가능하도록 만들어져 있다.

#### 모든 것을 측정하자

측정은 비용이 적게드므로 가급적 많은 지표를 수집하자.

- 리소스 풀
- 캐시
- 데이터 구조
- CPU 직약적 작업
- IO 집약적 작업
- 데이터 크기
- 예외와 에러
- 원격 요청 및 응답


게이지 
- 리소스 풀
- 스레드 풀
- 연결 풀
- 데이터 구조

카운터
- 캐시히트, 캐시미스
- 에러 응답 코드
- 잘못된 입력

히스토그램
-  원격 프로시저 호출(RPC) 페이로드
- IO 작업으로 생성된 데이터 크기

#### 오늘날 분산 환경에서 더욱 중요해진 추적

**분산 호출 추적** : 프론트엔트 API를 한 번 호출하는 작업이 여러 서비스에 대한 다운스트림 RPC 호출로 이어질 수 있는데, 분산 호출 추첮ㄱ은 이런 다운스트림 호출을 한데 모아 크래프로 만들어 준다.

에러의 디버깅, 성능 측정, 의존성 관계, 시스템 비용 분석을 파악하는 데 유용하다.

RPC 클라이언트는 추적 라이브러리를 이용해 요청마다 호출 추적 ID를 붙인다.
서비스는 ID와 함께 메타데이터 태그, 처리시간 등 호출정보를 보고한다.
시스템은 보고사항을 기록하고 호출 추적 ID를 기준으로 호출 추적 정보를 연결한다.

호출 추적 ID는 보통 RPC 클라이언트 래퍼(wrapper)와 서비스 메시(service mesh)에 자동으로 전달된다.

#### 설정으로 런타임 동작을 손쉽게 조정하려면

애플리케이션과 서비스는 개발자나 사이트 신뢰성 엔지니어 - site reliability engineer (SRE)가 런타임 동작을 조정할 수 있는 설정을 제공해야 한다.

설정은 다양한 방법으로 표현할 수 있다.

- INI, JSON, YAML 처럼 일반 텍스트면서 사람이 읽을 수 있는 형식의 파일
	- 설정할 값이 많거나 버전 제어를 이용해 설정을 관리해야할 때
- 환경 변수 
	- 스크립트로 설정하기가 편하며 확인이나 로깅이 쉬움.
- 명령줄 플래그
	- 설정이 편리하고 ps같이 프로세스 목록을 확인하는 명령으로 쉽게 확인이 가능
- 커스텀 도메인 전용 언어  - domain  specific language(DSL)
	- 설정에 루프나 if 문처럼 프로그래밍 간으한 로직이 필요할 때, 유용
- 애플리케이션 구현에 사용된 언어
	- 스크립팅 언어로 애플리케이션을 작성한 경우 사용됨(ex - python) 코드를 이용한 설정 생서은 강력하나 위험함.

가장 보편적인 방법은 사람이 읽기 편한 설정 파일, 환경 변수, 명령줄 플래그를 사용하는 방법이다.


#### 지나치게 창의적인 설정은 금물

대부분의 애플리케이션은 정적 설정 파일을 이용해 설정을 적용한다.
정적 설정 파일은 실행중인 동안에 파일을 변경해도 애플리케이션 동작이 바뀌지 않으며 변경사항을 적용하려면 애플리케이션을 재시작해야 한다.

애플리케이션을 재시작하지 않고 설정을 적용시키려 한다면 동적 설정 시스템을 사용한다. 동적 설정은 값이 변경될 때 애플리케이션이 변경된 값을 가져가거나 서비스가 애플리케이션으로 값을  넣어준다.

복잡성 때문에 동적 설정은 권장되지 않는다. 누가 언제 값을 바꿨는지 추적하기 어려우며 다른 분산 시스템에 대한 의존성도 더해진다.


#### 모든 설정을 로그에 기록하고 검증하자

- 애플리케이션이 어떤 설정값을 사용하는지 알 수 있게 시작 지점에 설정값을 로그에 기록
- 설정값을 로드할 때는 가능한 한 이른 타이밍에 항상 검증해야 한다.
	- 포트 번호가 정수인지
	- 문자열 길이, 유효한 enum값을 가졌는지
	- 설정값의 논리 


#### 기본값을 제공하자

사용자가 설정 파라미터를 너무 많이 제공해야 한다면 시스템을 운영하기 어려워진다.
네트워크 포트가 설정돼 있지 않다면 1024보다 큰 값을 기본값으로 사용하자

#### 관련된 설정을 그룹화하자

애플리케이션 설정은 중첩되지 않는 키-값 형식을 사용하면 데이터가 금방 거대해져 관리가 힘들다. 
YAML같은 표준 형식을 사용하자. 관련된 속성을 그룹화하면 쉽게 정리하고 관리할 수 있다.

타임아웃 시간과 단위처럼 강하게 결합된 파라미터를 하나의 구조로 묶으면 관계가 명확해지고 운영자가 해당 값을 한 번에 선언할 수 있다.

#### 설정도 코드처럼 테스트하자

설정 또한 코드처럼 취급하는게 좋다.
설정을 안전하게 변경하려면 버전 제어 시스템을 활용해 관리하고 리뷰하고 테스트하고 변경 이력을 확보하는 것이 좋다.

#### 설정 파일은 깔끔하게 유지하자

같은 논리로 설정을 깔끔하게 관리하자 표준 형식 사용, 공백 제거, 필요없는 설정 제거를 통해 잘 정돈된 상태를 유지해야 다른 사람이 이해하고 변경하기 쉽다.

#### 배포된 설정은 변경하지 말자

특정 머신의 설정을 수작업으로 수정하지 말자. 일시적으로 변경한 설정은 다음 배포 과정에서 다시 원래 값으로 덮어 써진다.

#### 때로는 도구가 운영의 성패를 결정짓는다.

...???

#### 개발자의 필수 체크리스트

- **이것만은 지키자**
	- 런타임 에러보다는 컴파일 타임에 에러를 검출하자
	- 가능하면 불변 변수를 사용하자
	- 입력과 출력을 검증하자
	- OWASP가 발표하는 10대 웹 애플리케이션 취약점(OWASP Top 10)은 숙지해두자
	- 버그 확인 도구는 물론 타입 또는 타입 힌트도 사용하자
	- 예외 발생 시에는 리소스(특히 소켓, 파일 포인터, 메모리 등)을 해제하자
	- 코드에 지표를 추가하자.
	- 애플리케이션에 설정을 추가해두자
	- 모든 설정을 검증하고 로그에 기록하자
- **이것만은 피하자**
	- 예외를 이용해 애플리케이션 로직을 결정해서는 안된다.
	- 리턴 코드로 예외를 처리해서는 안된다.
	- 처리할 수 없는 예외는 잡지 말자 (failing fast)
	- 로그를 여러 줄로 나누지 말자.
	- 보안 정보나 민감한 데이터를 로그에 기록하지 말자.
	- 머신의 설정을 직접 수정하지 말자.
	- 비밀번호나 보안 정보를 설정 파일에 기록하지 말자
	- 커스텀 설정 형식은 채택하지 말자
	- 불필요한 동적 설정은 사용하지 말자.



#### 감상

솔직히 쓰여진 내용중에 절반 이상은 완전히 이해를 못했습니다. 이해를 어느정도 한 내용들도 지금 내 상황에서 사용할 수 있는 것이 있는지 고려해보면 밀접하게 와닿는 것도 많지 않았습니다. 다만 생소한 용어들이 많이 나와서 이것들을 공부하는 지표로는 괜찮을 것 같다 생각했습니다.



