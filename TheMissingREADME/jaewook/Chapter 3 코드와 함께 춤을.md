
#### 소프트웨어 엔트로피는 늘어나게 마련

**소프트웨어 엔트로피(software - entropy)** : 코드가 지저분해지는 것

개발자가 다른 사람이 쓴 코드를 이해하지 못하거나 코딩 스타일이 서로 다르거나 기술 스택이나 요구사항을 개선하다가 발생한다.

코드리뷰나 지속적인 리팩터링을 통해 엔트로피를 낮출 수 있다.

#### 결코 피할 수 없는 문제 기술 부채

**기술 부채 technical debt** : 기존 코드의 단점을 수정하면서 나중으로 미뤄둔 작업, 수정해야 할 원래 단점은 원금이고 본질적인 단점을 수정하지 않고 코드를 개선할 때 발생하는 비용을 이자라고 한다.

어떤 것을 기술적 부채라고 부르기 위해서는 '이자를 지불하거나' 심각한 문제를 유발할 수 있는 위험 요인이어야 한다.

신중 X 의도O : "설계할 시간이 없어요"
신중 X 의도 X : "계층화가 뭐에요?"
신중 O 의도 O : "일단 출시 후 결과를 보고 대처합시다."
신중 O 의동 X : "뭘 실수했는지 이젠 알겠네요"

마틴 파울러는 기술 부채를 위와 같이 표현했으며 이를 통해 알 수 있는 것은 실수를 피해갈 수 없으며 필연적으로 발생하는 부채가 존재한다는 사실이다. 도메인에 대해 배우거나 아키텍트가 성장하는 과정에서 발생하는 자연스러운 결과로 부채가 발생할 수 있다.

#### 기술 부채를 상환하는 방법

변경사항을 작고 독립적인 커밋과 PR로 만들어 조금씩 리팩터링을 하자

기술부채는 단기적으로 볼 땐 쌓아두면 출시가 빨라지고 해결하면 출시가 늦어진다.
장기적으로는 쌓아두면 출시가 늦어지고 해결하면 출시가 빨라진다.

출시와 개발 사이의 균형을 잘 잡아야 한다.

기술 부채의 논의사항

1. 상황을 사실 그대로 설명
2. 부채의 위험과 비용을 기술
3. 해결책을 제안
4. (부채를 그대로 두는 방법을 비롯한) 대안에 대해 논의
5. 트레이드 오프 따지기

제안 내용은 문서로 작성하며 부채를 해결하는데 드는 비용과 그럼으로써 얻을 수 있는 장점에 집중하자 

## 코드 변경으로 인한 고통을 조금이라도 줄이려면

코드 변경은 기존의 기능을 유지해야 하기 때문에 코드를 새로 작성하는 것과는 다른 문제다. 다른 개발자의 코드를 이해하고 패턴을 유지해야한다. 

#### 레거시 코드 변경 알고리즘을 활용하자

마이클 C 페더스sms [레거시 코드 활용 전략]에서 기존 코드를 안전하게 수정할 수 있는 과정을 소개했다.

1. 변경 지점을 확인한다.
2. 테스트할 지점을 확인한다.
3. 의존성을 나눈다.
4. 테스트를 작성한다.
5. 변경을 적용하고 리팩터링한다.

변경할 코드를 찾아 테스트할 방법을 알아내자 되도록 테스트가 가능하도록 리팩터링을 하자. 기존의 동작을 확인할 테스트를 추가한다.이렇게 완성된 울타리안에서 변경 지점을 보호하고 그 안에서 코드를 바꾸면 된다.

변경할 코드를 확인하면 테스트 지점을 확인해야 한다.
*테스트 지점*은 수정하고자 하는 코드의 진입점, 즉 테스트가 직접 호출하고 값을 넣어보는 부분이다. 테스트 지점은 변경 전에 코드가 어떻게 동작하는지 보여준다.

테스트 지점을 찾기 위해서는 의존성을 나눠야할 필요가 있다. 테스트가 용이하도록 코드의 구조를 바꾼다는 뜻이다. 의존성을 나누는 리팩터링은 위험한 과정일 수 있으므로 조금씩 작업을 진행하고 새로운 기능을 추가하지 말자

의존성을 나누는 방법   오브젝트의 [[Chapter 8 의존성 관리하기]]

1. 크고 복잡한 메소드는 더 작은 크기의 메소드로 나눠 각기 분리된 기능이 독립적으로 테스트될 수 있게 한다.
2. 인터페이스 (interface)를 이용해 복잡한 객체를 완전하지는 않아도 테스트하기에 충분히 단순한 구현체로 대체할 수 있게 방법을 마련한다.
3. 시간의 흐름같이 제어하기 어려운 실행 환경을 시뮬레이션할 수 있는 명시적 제어 지점을 주입한다.

의존성을 나누고 테스트 준비가 된다면 변경사항을 확인하는 테스트를 추가하고 코드를 리팩터링해서 설계를 고도화하자. 

#### 코드는 처음보다 더 깔끔하게 유지하자

버그를 수정하거나 새로운 기능을 추가할 때 주변 코드를 정리하자 기회가 생길 때 정리하는 것이 포인트다. 코드를 정리하는 커밋과 동작을 변경하는 커밋을 구분해 코드를 정리하는 커밋을 유지하면서 변경된 코드를 되돌릴 수 있다.

**코드악취(code smell)** : 버근느 아니지만 문제를 유발할 수 있는 코드

```java
if(a<b)
a+=1;
	
```

위와 같은 코드는 다음과 같은 실수를 쉽게 유발할 수 있기 때문에 작동에 문제는 없지만 코드 악취가 난다고 할 수 있다.

```java
if(a<b)
a+=1;
a=a*2;
```

추가로 이름이 긴 메서드나 클래스, 중복 코드, 많은 분기와 루프, 많은 매개변수 같은 문제들이 있다.


#### 점진적으로 변경하자

리팩터링 커밋은 작게 유지해야 한다. 코드 변경 알고리즘의 단계별로 PR을 만들자
리팩터링과 기능추가 커밋을 구분하자 리팩터링을 유지하면서 롤백이 가능하다.
팀의 동의를 얻자. 팀도 함께 책임을 져야하는 부분이다.

#### 리팩터링은 실용적으로 진행하자

마감일과 우선순위를 고려하면 리팩터링이 항상 현명한 선택은 아니다. 리팩터링으로 얻을 수 있는 가치가 리팩터링에 드는 비용보다 커야한다. 사용되지 않는 코드나 위험도가 낮은 코드를 고려하지 말자 항상 실용성에 무게를 두고 리팩터링을 진행해야 한다.

#### IDE를 활용하자

*통합개발환경 integrated development environment (IDE)* 리팩터링할 때 도움이 된다.이름을 변경하거나 코드 위치를 변경, 필드를 추출하는 기능, 시그니처 수정 등 변경사항을 쉽게 적용해 수정할 수 있게 해준다. 다만 IDE가 자동으로 변경한 내용은 반드시 사람이 리뷰해야 한다. 리플렉션이나 메타프로그래밍 형태로 참조하는 메소드의 이름을 바꾸면 관련 코드가 수정되지 않을 수 있다.

#### 버전 제어 시스템의 권장 기법을 활용하자

깃과 같은 버전 제어 시스템에 커밋하면 커밋의 주체, 시기 등을 추적할 수 있다.
코드를 개발하는 동안 변경사항은 일찍 자주 커밋해야 한다. 백업도 가능하며 코드의 변화 흐름을 볼 수 있다.

리뷰를 요청하기 전에는 리베이스rebase 나 스쿼시squash를 통해 커밋 메시지를 명료하게 정리하자

깃 커밋 메시지를 작성하는 7가지 요령

- 제목과 본문 사이에 빈 줄을 한 행 삽입한다.
- 제목은 50자 이내로 한다.
- 제목은 대문자로 쓴다.
- 제목 끝에 마침표를 붙이지 않는다.
- 제목은 명령형 문장으로 작성한다.
- 본문의 각 행은 72자를 넘지 않게 한다.
- 본문에는 코드가 '어떻게' 바뀌었는지보다 '무슨' 코드가 '왜'바뀌었는지를 설명한다.


## 소프트웨어 개발에서 빠지기 쉬운 함정을 최대한 피하려면

벤 호로위츠가 집필한 [하드씽]에서는 다음과 같이 말한다.

```
모든 기술 스타트업이 반드시 해야 할 일은 제품을 개발하는 것이다. 현재 가장 지배적인 방식보다 적어도 10배는 뛰어난 제품을 개발해야 한다. 2~3배 좋은 제품만으로는 사용자를 충분히 빠른 속도로 새로운 제품으로 전환시키거나 충분히 많은 사용자를 모을 수 없을 것이다.
```


스타트업 뿐만 아니라 기존 코드에 대해서도 마찬가지다. 코드를 새로 작성하거나 표준 외의 방법을 도입하고자 한다면 기존 코드에 비해 몇 배는 더 좋아야 한다. 

#### 되도록 검증된 기술을 사용하자

견고한 코드는 오래된 라이브러리와 오래된 패턴으로 유지된다.
새로운 기술의 문제점은 성숙하지 못하다는 단점이 있다. 모든 기술은 문제 발생 가능성이 있지만 오래된 기술은 예측이 가능하며 새로운 기술은 커뮤니티 규모가 작고 안정성이 낮다. 문서화도 미흡하며 호환성이 낮다.

새로운 기술을 도입했을 때의 장점이 도입 비용보다 커야 한다. 
**이노베이션 토큰 innovation token** : 새로운 기술을 도입하기 위한 노력을 획기적인 신기능 구현에도 사용할 수 있음을 보여주기 위해 댄이 고안한 개념이다.

회사가 비용과 장점 사이의 균형을 고부가가치 영역을 담당하고 광범위한 사례에 적용 가능한  토큰을 사용해야 한다.
프로젝트에 새로운 프로그래밍 언어를 도입하는 것은 결과에 영향을 미친다. 회사의 생태계에 기술 스택 전체를 때려넣는 것이다.
새로운 프레임워크나 데이터베이스를 도입할 때의 비용이 이노베이션 토큰이 1개라면 새로운 언어는 3개가 된다.

새로운 언어의 도입은 생태계에 얼마나 성숙한 지도 중요한 사안이다. 
- 빌드 및 패키징 시스템은 잘 갖춰져 있는지, 
- IDE 지원 수준은 어떤지
- 주요 라이브러리는 경험이 풍부한 개발자들이 관리하는지
- 테스트 프레임워크는 있는지
- 배우기 쉬운지
- 성능은 어떤지
- 회사의 기존 도구와 통합되는지

언어가 사장되지 않는 이상 오래됐거나 관심이 줄었다는 사실이 그 언어를 쓰지 않아야할 이유가 되지는 않는다.

#### 제발 악동은 되지 말자

비표준 코드를 작성하는 것은 기업 환경에 맞지 않는 코드를 작성한다는 뜻이다. 지속적 통합 검사, IDE 플러그인, 단위 테스트, 코드 린팅, 로그 집계 도구, 지표 대시보드, 데이터 파이프라인 등 이미 모두 통합돼 있다. 표준을 벗어난다는 것은 이에 비용이 발생한다는 것이다.

단기적으로 다른 사람이 하는 대로 따르면서  그 방법이 표준이 된  이유를 이해해야 한다. 이해하지 못하는 문제를 해결하기 위한 방안일 수도 있다.

표준을 바꿀 때는 우선순위, 소유권, 비용, 구현 세부내역 등 다각도로 고려해야 한다. - 실용주의적 사고에 입각

#### 업스트림 커밋 없이 포크만 하는 것은 금물

**포크 fork** : 다른 소스 코드 리포지토리에 대한 완전하며 독립적인 복사본으로서 자체적인 트렁크trunk, 브랜치, 태그 등을 갖는다. 깃

**업스트림 upstream 리포지토리** : 포크의 대상이 되는 원본 리포지토리

업스트림 리포지토리에 PR을 보내기 전에 해당 리포지토리를 포크한다. 업스트림 포크를 해두면 해당 프로젝트의 주 리포지토리에 쓰기 권한이 없는 사람도 코드에 기여할 수 있다. 보편적이고도 건전한 방법이다.

코드에 기여할 생각이 없으면서 리포지토리를 포크하는 것은 권장되지 않는다.
회사 내부에서는 포크한 리포지토리를 관리하기 쉽지 않다. 개발자들은 리포지토리에 기여할 거라고 말하지만 그런 일은 일어나지 않는다. 소소한 변경은 시간이 지나도 업스트림 리포지토리에 적용되지 않다 결국 완전히 다른 소프트웨어를 운영하게 된다.

#### 코드 재작성에 대한 욕구를 견디자

코드를 새로 작성하는 것은 최후의 수단이 되어야 한다. 코드 재작성은 그에 들어가는 비용보다 장점이 클 때만 시도해야 한다. 코드 재작성은 비용보다 장점이 클 때만 시도해야 한다.


#### 개발자의 필수 체크리스트

*이것만은 지키자* : 
- 점진적으로 리팩터링하자.
- 리팩터링 커밋과 기능 관련 커밋은 분리하자.
- 변경사항을 작게 유지하자.
- 처음 상태보다 코드를 더 깔끔하게 유지하자.
- 평범한 기술을 사용하자.
*이것만은 피하자* :
- '기술 부채'라는 단어를 남용하지 말자.
- 테스트를 목적으로 메서드나 변수를 외부에 공개해서는 안 된다.
- 특정 언어에 연연하지 말자
- 회사의 표준 도구를 무시해서는 안된다.
- 업스트림 커밋 없이 코드베이스를 포크해서는 안된다.







