
#### 소프트웨어 전달의 4가지 단계

- 빌드
	- 패키지가 불변의 버전으로 지정되어 
- 릴리스
	- 릴리스 놑와 변경 로그 업데이트
	- 패키지를 중앙식 리포지토리로 발행
- 배포
	- 릴리스 산출물은 테스트 환경이나 프로덕션 환경에 배포되어야 한다.
- 롤아웃
	- 사용자가 소프트웨어를 사용하는 단계

**소스 컨트롤 브랜칭 전략 source control branching strategy**

브랜치 전략을 통해 어디에 코드 변경을 커밋하고 어떻게 릴리스 코드를 유지보수할 지 결정할 수 있다.

## 효과적인 버전 제어를 위한 브랜칭 전략


**트렁크 기반 trunk-based**

트렁크에서 가지 치기한 브랜치는 작은 기능, 버그 수정, 업데이트 등에 사용

- 트렁크 기반 개발은 일 단위로 신속하게 머지하는 환경에 적합
- 지속적 통합 continuous integration - CI
- 개발자 간에 코드베이스가 동기화 되면 버그나 호환성 문제를 빨리 발견할 수 있다.

단점 : 트렁크에 버그가 존재하면 전체적으로 개발 속도가 느려진다.

**기능 브랜치 기반 feature branch-based**

기능 브랜치가 상당히 오래 유지되며 개발자가 동시에 이 브랜치에 작업한다.

리베이스를 자주 수행하며 안정성은 리베이스 타이밍에 제어된다.

릴리스가 준비되면 기능 브랜치를 릴리스 브랜치로 가져온다.
릴리스가 안정화되면 트렁크로 머지한다. 트렁크에는 안정화된 릴리스만 존재해 항상 배포 준비된 상태이다.


#### 빌드 단계

소프트웨어 빌드는
의존성 해석 및 링킹 -> 린터 실행 -> 컴파일 -> 테스트 -> 소프트웨어 패키징의 단계로 구성된다. 

- 패키지는 각 릴리스마다 빌드된다.
- 대부분의 빌드는 운영체제나 CPU 아키텍처, 언어 런타임에 따라 생성된다.
- 패키지에는 다음과 같은 내용물을 포함한다.
	- 바이너리나 소스 코드
	- 의존성
	- 설정
	- 릴리스 노트
	- 문서
	- 미디어
	- 라이선스
	- 체크섬
	- 가상 머신 이미지 등
- 라이브러리는 스펙에 맞는 디렉터리를 압축한 것이다.
- 애플리케이션은 보통 zip파일이나 .tar, .dmg, setup.exe 등으로 생성된다.

#### 패키지에 버전을 명시하자

패키지에는 고유한 식별자를 할당해야 한다.
버전이 없다면 패키지가 어떻게 동작하는지 알 도리가 없다. 버전은 특정 소스코드, 기능, 문서와 엮을 수 있다.

시멘틱 버저닝(semantic versioning)을 활용하자. [[Chapter 5 피할 수 없는 코드 의존성의 관리]]

#### 리소스는 각각 별도로 패키징하자

리소스를 별도로 패키징하면 

- 리소스 종류별로 릴리스 주기를 다르게 가져갈 수 있다.
- 패키지를 재빌드하지 않고 부분 수정할 수 있다.
- 독립적으로 롤아웃 및 롤백이 가능하다.


#### 릴리스 단계

릴리스는 소프트웨어의 종류와 크기 및 숙련도에 따라 다양하게 수행된다.

사용자가 직접 사용하는 기능의 릴리스는 산출물 발행, 문서 업데이트, 릴리스 노트, 사용자와의 소통 등의 절차가 필요하다.

릴리스 관리는 안정적이며 문서화가 잘된 소프트웨어를 예측 가능한 시점에 발행하는 기술이다.

#### 릴리스를 남의 일로 여기지 말자

팀에 릴리스 엔지니어링이나 운영 팀이 갖춰저 있다고 하더라도 소프트웨어가 적절히 배포되어 제대로 동작하는 것은 개발자의 책임이다.

- 테스트 환경에서 코드가 제대로 동작하는지 확인한다.
- 릴리스 일정을 준수하며 애플리케이션에 맞는 방법을 선택하자
- 배포과정에서의 심각한 버그는 원인을 파악하고 재발하지 않도록 노력해야 한다.

#### 패키지를 릴리스 리포지토리로 발행하자

릴리스 패키지는 전용 패키지 리포지토리에 발행하는 편이 좋다.

패키지 리포지토리는 릴리스 산출물을 배포 가능한 상태로 관리한다.
배포 요구사항을 준수하고 수천 명의 사용자가 동시에 새로운 릴리스를 다운로드할 수 있게 만들어준다.

#### 릴리스는 불변성을 갖게 하자

릴리스 패키지를 발행 했다면 덮어쓰거나 변경하지 말자.
릴리스는 동일한 버전을 실행하는 모든 애플리케이션 인스턴스가 완전히 동일한 코드라는 것을 보장해야 한다.

버전이 할당된 패키지를 바꾸는 것은 버전을 할당하지 않은 것과 진배없다.

#### 자주 릴리스하자

릴리스 주기를 짧게 가져간다면 안정적으로 소프트웨어를 구현할 수 있어 버그가 발견됐을 때 쉽게 처리할 수 있다.

매 주기마다 릴리스되는 변경사항의 수가 적어지므로 각 릴리스마다 위험도가 낮아진다.

프로덕션 환경에서 버그가 발생되더라도 디버깅할 때 확인할 변경사항의 수도 적다.

#### 릴리스 일정은 투명하게 공유하자

릴리스 일정은 매 분기, 매년, 특정 기능의 완성, 혹은 자신이 원할 때 등등 다양한 주기가 존재하지만 릴리스 일정은 명확히 정해야 한다.

일정을 공유하고 사용자에게 언제 새로운 릴리스가 발행되는지 알려야 한다.

#### 변경 로그와 릴리스 노트를 발행하자

**변경 로그 changelog**
- 이번 릴리스에서 수정하거나 커밋한 모든 티켓 나열
- 주로 고객지원 팀을 위한 것
**릴리스 노트 release note**
- 릴리스에 포함된 새로운 기능과 버그 수정에 대한 용약 내용
- 주로 사용자를 위한 것

## 배포단계

**배포** : 소프트웨어 패키지를 실행할 곳으로 옮기는 것


#### 배포를 자동화하자

소프트웨어 배포는 스크립트를 이용하자

이미 운영중인 서비스를 변경하는 작업을 하다보면 실수하기 쉽다.

자동화를 고도화하면 지속적 전달 continuous delivery로 이어진다. 즉 배포절차에 사람을 완전히 배제 시키는 것이다.

패키징, 테스팅, 릴리스, 배포, 롤아웃까지 모두 자동화할 수 있다. 

지속적 전달이 가능해지면 신속하게 사용자에게 기능을 전달하고 피드백을 받을 수 있다.

이미 개발된 자동화 도구는 퍼핏Puppet, 솔트 Salt, 앤서블 Ansible, 테라폼 Terraform 등이 있다.

#### 배포는 원자적으로 수행하자

일부만 배포되는 경우를 방지하자 배포 스크립트가 애플리케이션을 완전히 배포하거나 아무것도 배포하지 못하도록 만들어야 한다.

배포를 원자적으로 만드는 가장 쉬운 방법은 설치 경로를 버전마다 다르게 설정하고 단축 아이콘이나 심볼릭 링크를 이용해 교체하는 것이다.

#### 애플리케이션을 독립적으로 배포하자

서로 소통이 많은 애플리케이션이나 서비스로 소프트웨어가 구성된 경우 배포를 순서대로 해야 하는 문제가 발생한다. 순서에 의존하면 처리속도가 느려질 뿐만 아니라 의존성에 의해 충돌하기도 한다. 

애플리케이션은 독립적으로 배포가 가능하도록 구현하자 (하위 호환성을 가지게 만들자)

의존성이 불가피한 상황엔 변경사항을 끈 상태로 배포한 후 특정 순서로 켜는 편이 배포순서에 의존하는 것보다 훨씬 빠르고 간편하다

## 롤아웃 단계

새 코드가 배포되면 한 번에 모조리 새 코드로 전환하지 않고 점진적으로 롤아웃해나가며 시스템 상태 지표를 모니터링해야 한다.
(버그 가능성, 모든 사용자가 동시에 버그가 발생하면 위험)

**롤아웃 전략**

- 기능 플래그 feature flag
	- 각각의 코드 경로를 실행하는 사용자의 비율 제어
- 서킷 브레이커 circuit breaker
	- 문제가 발생할 경우 자동으로 코드 경로를 변경
- 다크 런치 dark lunch
	- 동시에 여러 버전의 소프트웨어를 실행하는 방법
- 카나리 배포 canary deployment
	- 동시에 여러 버전의 소프트웨어를 실행하는 방법
- 블루 - 그린 배포 blue-green deployment
	- 동시에 여러 버전의 소프트웨어를 실행하는 방법



#### 롤아웃을 모니터링하자

새 코드를 활성화할 때는 다음 사항들을 모니터링해야 한다.

- 에러율
- 응답 시간
- 리소스 사용량 등

통계값과 롤아웃과정을 관찰해야 한다. 롤아웃 범위 변경은 로그와 지표를 관찰하는 사람이 담당하게 된다.

사전에 평상시 정상적인 지표를 확인해두자 **서비스 수준 지표 service level indicator SLI**를 통해 서비스 성능 저하 여부를 주시할 수 있다. [[Chapter 9 긴급대응 온콜 업무]]

#### 기능 플래그를 활용하자

**기능 플래그 (feature toggle 혹은 code split이라고도 부른다.)** : 코드가 플래그를 확인해서 특정 코드를 실행할 지 여부를 결정하는 if 문으로 감싸져 있다. 이를 통해 언제 새로운 코드를 사용자에게 릴리스할 지 결정할 수 있다.

- 불리언
	- 모든 사용자를 대상으로 끄거나 켬
- 허용 목록
	- 특정 사용자에게만 해당 기능을 끄거나 켬
- 퍼센트 기반 적용
	- 많은 사용자에게 해당 기능을 서서히 켤 수 있음
- 작은 함수

일반적으로는 테스트 계정에만 해당 기능을 적용 후 특정 고객에게만 적용한 뒤 점진적으로 늘려간다.

데이터베이스는 기능 플래그로 제어하지 않는 경우가 많으니 기능 플래그 데이터를 격리하고 플래그의 상태를 롤백할 때 해당 데이터를 정리하는 스크립트를 추가해야 한다.

완전히 롤아웃된 기능 플래그는 반드시 시간을 들여 정리해야 한다.
기능 플래그때문에 어지럽혀진 코드는 버그도 유발하고 의미를 유추하기도 쉽지 않다.

#### 서킷 브레이커를 이용해 코드를 보호하자

**서킷 브레이커 circuit breaker** : 레이턴시나 예외같은 운영 이벤트에 의해 자동으로 제어되는 기능 플래그. 간단히 토글되며 영구적이고 자동화됐다는 특징이 있다.

- 성능이 저하되는 상황에서 시스템을 보호하기 위해 사용한다.
- 레이턴시가 한계치를 넘어가면 어떤 기능을 비활성화하거나 사용률 제한이 적용된다.
- 예외나 로그의 갑작스런 증가와 같은 비정상적 동작을 포착할 때도 개입된다.
- 영구적 손상으로부터도 시스템을 보호한다.
	- 메일 전송이나 계좌 송금과 같은 되돌릴 수 없는, 처리 여부가 불확실한 동작에도 사용된다.


#### 서비스 버전은 병렬로 올리자

웹 서비스는 기존 버전을 실행하면서 새로운 버전을 배포하는 것이 가능하다.
병렬 배포는 천천히 버전을 올리면서 위험을 완화할 수 있고 신속히 롤백이 가능하다.

대표적인 병렬 배포 전략은 카나리 배포화 블루-그린 배포다.

**카나리 배포** 
- 새로운 버전의 어플리케이션을 제한된 수의 머신에만 배포한다.
	- 약간의 사용자만 카나리 버전을 사용하면 문제가 생길 때 소수의 사용자만 피해가 발생하며 신속히 이전 버전으로 롤백할 수 있다.
	- 석탄 탄광에서 유독가스를 잡던 카나리아가 모티브이다.
- 대규모 트래픽을 처리하며 수많은 인스턴스에 배포되는 서비스에 활용한다.

**블루-그린 배포**
- 애플리케이션을 액티브 active 모드와 패시브 passive 모드로 동시에 실행한다.
- 새로운 버전을 패시브 모드에 두고 준비가 되면 액티브 모드로 전환해 트래픽을 새로운 버전으로 전달한다.
- 패시브 모드에는 구 버전이 들어가고 새로운 버전에 문제가 생길 때 전환하는 것을 대비한다. 
- 트래픽은 원자적으로 전환되며 패시브와 액티브는 최대한 동일한 환경을 유지한다.
- 새로운 버전이 안정적이면 패시브 모드를 제거한다.
- 트래픽의 일부만 그룹화할 수 없거나 여러 버전을 병렬로 실행할 수 없는 경우에 유용하다.
#### 다크 모드로 런칭하자

**다크 런치** : 트래픽 쉐도잉 traffic shadowing 이라고도 부르며 최종 사용자는 볼 수 없는 상태에서 새로운 코드를 실제 트래픽에 노출하는 방법이다. 보통 실제 트래픽과 애플리케이션 사이의 애플리케이션 프록시가 요청을 다크 시스템으로 복제한다. 동일한 요청에 대해 두 시스템으로부터 받은 응답을 비교한 후 차이점을 기록한다.

- 다크 코드가 잘못 동작해도 사용자에게는 별다른 영향이 없다.
- 다크런치가 적용된 소프트웨어는 코드가 여전히 실행되지만 저장되지 않는다.
	- 때문에 사용자에게 피해는 없고 개발자와 운영자는 프로덕션 환경에서 어떻게 실행되는지 파악할 수 있다.
- 다크 읽기 모드로 동작하는 경우 읽기용 트래픽만 전달되며
- 다크 쓰기 모드로 동작하는 경우 완전히 독립적인 데이터 스토어를 사용한다.

주의
- 총 두 번의 처리가 발생하는 셈이므로 중복 관련 에러를 피해야 한다.
- 다크 시스템의 트래픽은 사용자 분석에서 제외해야 한다.
- 이중 과금같은 side effect도 처리해야 한다.
	- 이스티오 Isto같은 일부 서비스 메시 sevice mesh와 글루 Gloo 같은 API 게이트웨이는 헤더를 수정해 다크 시스템으로부터 복제된 트래픽 표시를 제외하는 동작을 자체적으로 지원한다.

오픈 소스 도구인 디피 Diffy는 다크 트래픽을 3개의 백엔드 서비스 인스턴스로 보낸다. 이 중 둘은 프로덕션 버전의 코드를 실행하며 나머지 하나는 새 릴리스 후보 버전을 실행해 둘의 응답을 비교하고 차이점을 찾아낸 뒤 비결정적 요소를 찾아내 거짓양성을 제거한다.

---

**이것만은 지키자**

- 가능하다면 트렁크 기반 개발과 지속적 통합을 적용하자
- 버전 제어 시스템 도구를 이용해 브랜치를 관리하자
- 릴리스 및 운영 팀과 협업을 통해 애플리케이션에 적합한 절차를 구현하자.
- 릴리스 변경 로그와 릴리스 노트를 발행하자
- 릴리스가 발행되면 사용자에게 알려주자
- 배포 자동화는 상용 도구를 이용하자
- 기능 플래그를 이용해 변경을 점진적으로 롤아웃하자
- 서킷 브레이커를 이용해 애플리케이션이 심각한 피해를 입지 않도록 하자
- 주요 변경사항은 트래픽 섀도잉과 다크론치를 활용해 검증하자

**이것만은 피하자**
- 버전을 적용하지 않은 패키지를 발행하지 말자
- 설정, 스키마, 이미지, 언어 팩을 패키지에 함께 넣지말자
- 아무것도 모른 채 릴리스 관리자와 운영팀에만 의존하지 말자.
- 버전 제어 시스템을 이용해 소프트웨어를 배포해서는 안 된다.
- 일단 발행한 릴리스 패키지는 변경하지 말자
- 결과를 모니터링하지 않으면서 롤아웃을 수행해서는 안 된다.
- 배포 순서에 의존하지 말자


#### 감상

소프트웨어가 사용자에게 전달되는 대략적인 과정을 알 수 있었던게 좋았고,
라이브 서비스에서 생각보다 다양한 안전장치가 생전 처음보는 방식으로 설계되어 있다는 것이 흥미로웠습니다. 저걸 다 다룰 줄 알아야 하는 것일까요...ㄷㄷㄷ

실제 게임 패치노트를 읽어보면 릴리스 노트와 크게 다를 게 없다는 것을 느낀 것도 좋았습니다.
#### 논의 사항

조금 논외일 수 있는 사항입니다만 여러분들은 현재 프로젝트에서 빌드 파일을 얼마나 많이 만드나요?