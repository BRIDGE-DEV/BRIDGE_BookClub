
DRY(Don't repeat yourself)는 아주 보편적인 원칙이다. 이미 존재하는 라이브러리를 일일이 구현할 필요는 없다. 다만 의존성에는 호환성 없는 변경, 순환 의존성, 버전 충돌, 통제 불가능 등 다양한 위헝이 내포되어 있어 의존성을 추가할 때는 이런 위험을 인지하고 사전에 완화할 수 있어야 한다.

#### 의존성 관리를 이해하기 위한 필수 개념

**의존성 dependency** : 어떠한 코드가 의존하는 코드 즉, 부분적인 코드가 다른 코드의 정보를 알고 있는 정도. 그 의존성이 필요한 시점, 즉 컴파일 시점, 테스트, 런타임 등은 의존성 범위(scope)라고 부른다.

의존성은 패키지 관리 파일이나 빌드 파일에 선언한다. (자바 - Gradle 혹은 Maven  파이썬 - setup.py 혹은 requrements.txt)

**버저닝 스키마(versioning scheme)** 를 잘 따르는 버전은 다음의 특징을 갖는다.

- **고유성** : 버전은 재사용되지 않아야 한다. 산출물은 자동화된 워크플로를 통해 배포되고 캐시되며 사용된다.
- **비교성** : 버전은 사람과 도구가 버전의 우선권을 이해하는 데 도움이 되야한다. 우선권은 동일한 산출물의 여러 버전에 빌드가 의존하는 경우 충돌을 해결하는 데 사용된다.
- **정보성** : 버전은 사전 릴리스한 코드와 정식 릴리스한 코드를 구분하고 산출물에 번호를 매겨 안정성과 호환성을 설명해준다.
#### 시멘틱 버저닝

**시멘틱 버저닝 semantic versioning (Sem Ver)** : major, minor, patch 세 가지 숫자로 버전을 정의한다. (1.12.6이나 4.3.6과 같이)

시멘틱 버저닝은 고유성, 정보성, 비교성을 모두 갖추고 있다. 각 버전의 번호를 한 번만 사용하고 왼쪽에서 오른쪽으로 읽어 버전을 비교할 수 있다.

- 패치 버전은 하위 호환성을 갖는 버그 수정이 일어날 때마다 증가한다.
- 보조 버전은 하위 호환성을 갖는 기능을 추가할 때마다 증가한다.
- 주 버전은 하위 호환성을 갖지 못하는 변경을 추가할 때마다 증가한다.

사전 릴리스는  Sem Ver 뒤에 -를 붙이고 마침표로 구분한 영문자와 숫자(ex : 2.13.7 - alpha.2)를 이용해 표현한다.

#### 이행적 의존성

**이행적 의존성 transitive dependency** : 프로젝트에 직접 의존하는 의존성은 보통 다른 라이브러리에 주로 의존하며 이러한 간접적인 의존성을 말한다.

의존성은 계층이 깊어져 의존성이 다른 의존성을 갖고 그 의존성이 또 다른 의존성을 가질  수 있다. 

의존성을 하나 추가하는 것은 작은 일처럼 보이지만 여러 복잡한 의존성 계층에 추가하므로 프로그램에 영향을 주게 된다. 의존성 충돌을 디버깅하려면 의존성 트리를 확인하는 방법을 익혀야 한다.

#### 현업이라면 누구나 한 번은 겪는 의존성 지옥

**의존성 지옥 dependency hell** : 순환 의존성, 다이아몬드 의존성, 버전 충돌 등에 의해 업그레이드 후 비호환성 문제로 빌드를 깨뜨리고 런타임 에러를 유발하는 현상

**순환 의존성** : 라이브러리가 자기 자신을 이행적 의존성으로 갖게 되는 현상. 한 라이브러리를 업그레이드하면 다른 라이브러리가 깨지게 된다.

#### 의존성 지옥에서 탈출하자

의존성을 추가할 때 의존성의 가치와 비용을 비교해서 판단하자

- 이 기능은 정말 필요한가?
- 의존성은 얼마나 잘 관리되고 있는가?
- 뭔가 잘못됐을 때 의존성을 수정하는 것은 얼마나 쉬운가?
- 의존성은 얼마나 성숙해 있는가?
- 의존성에서 하위 호환되지 않는 변경이 얼마나 자주 일어나는가?
- 나 자신과 우리 팀, 우리 조직은 의존성에 대해 얼마나 이해하고 있는가?
- 코드를 직접 작성한다면 구현 난이도는 어느 정도인가?
- 어떤 유형의 코드 라이선스가 적용돼 있는가?
- 의존성 내에서 내가 사용하는 코드와 사용하지 않는 코드의 비율은 어느 정도인가?


#### 의존성을 격리하자

빌드와 패키지 시스템을 위해 의존성 관리를 그만둘 필요는 없다.

의존하는 코드를 복사해도 되고 벤더 도구로 관리되거나 가릴 수도 있다.

코드를 프로젝트에 복사해 넣는 것은 격리성을 위해 의존성 관리 자동화를 포기하는 것이다. 작고 안정적인 코드가 필요할 때 선택하는 옵션이며 버전 기록을 유지하지 못하는 것과 업데이트가 필요할 때마다 매번 코드를 다시 복사해야 한다는 단점이 있다.

**의존성 가리기** : 충돌을 피하기 위해 의존성을 다른 네임스페이스로 자동 이전하는 기법

고급 기법으로 가려진 의존성 객체는 절대로 공개 API에 노출해서는 안된다. 의존성 가리기의 목적은 라이브러리 사용자로부터 의존성의 존재를 숨기는 것이다.

충돌이 발생할 가능성이 높은 의존성을 광범위하게 사용하는 라이브러리를 만들고 싶을 때 사용하는 것이 권장된다.

#### 의존성은 신중하게 추가하자

사용하는 라이브러리는 명시적으로 의존성을 선언하자 이행적 의존성 라이브러리가 제공하는 메소드나 클래스는 사용하지 않아야 한다.

IDE에만 의존해 의존성을 관리해서는 안 된다. 의존성은 명시적으로 빌드 파일에 추가하자. IDE는 자체 프로젝트 설정에 의존성을 보관하는 경우가 많은데 빌드 머신은 IDE 자체 설정을 참조하지 않는다. IDE와 빌드 파일 사이에 일관성이 없으면 빌드가 동작하는데 IDE는 동작하지 않거나  그 반대의 상황이 발생할 수 있다.

#### 버전을 고정하자

- 모든 의존성의 버전 번호를 명시하자 
	- 버전을 고정하지 않으면 빌드나 패키지 관리 시스템이 버전을 결정하게 된다.
- 버전 범위의 경계를 지정하는 방법도 있다. 이는 의존성 해석 시스템이 자유롭게 충돌을 해결하고 의존성을 업데이트할 수 있다.
- 직접적 의존성의 버전은 고정하더라도 이행적 의존성의 버전은 의존성을 해석하고 버전을 결정하는 manifest를 생성해 고정하는 방법이 있다.

#### 의존성의 범위를 좁히자

의존성의 범위는 의존성이 빌드 생명주기에서 언제 사용되는 것인지를 결정한다.

- 범위는 계층구조를 갖는다.
	- 컴파일 타임 의존성 > 런타임 의존성
	- 테스트 의존성 != 빌드 실행할 때

의존성은 최대한 범위를 좁혀서 사용해야 한다. 

#### 순환 의존성에 주의하자

절대로 순환 의존성이 발생해서는 안된다. 빌드 중 갑작스런 실패나 우발성 버그들이 순환 의존성에 의해 발생한다.

빌드 도구나 플러그인을 통해 순환 의존성을 탐지하고  프로그램을 보호하자.

---

- **이것만은 지키자**
	- 시맨틱 버저닝을 사용하자.
	- 의존성 버저은 특정 범위로 고정하자.
	- 의존성 보고서를 이용해 이행적 의존성을 파악하자
	- 새 의존성 추가는 가급적 피하자
	- 의존성은 적당한 범위 내에 선언하자
- **이것만은 피하자**
	- 깃 해시를 버전 번호로 사용하지 말자
	- 비용 대비 효과가 낮다면 의존성을 추가하지 말자
	- 이행적 의존성을 직접 사용해서는 안 된다.
	- 순환 의존성을 주의하자


#### 감상

이전에 졸업 프로젝트를 할 때 안드로이드 스튜디오를 사용했었는데, 카메라 권한 의존성이나 gpt api 의존성 등을 추가해본 기억이 나서 비교적 쉽게 읽혔습니다. Gradle이나 manifest 등의 낯설지만은 않은 단어들이 나온 것도 한 몫했습니다.

 다만 아직은 이행적 의존성이나 순환 의존성을 주의할 만큼 큰 규모의 프로그램을 만들지 않아서 그런지, (즉 경험 부족) 공감할 만한 내용들이 많지는 않았던 것 같습니다.

