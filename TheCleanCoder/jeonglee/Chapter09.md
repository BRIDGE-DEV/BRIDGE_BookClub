## 9장 시간 관리

> 8시간은 정말 짧은 시간이다. 480분 혹은 28,800초밖에 되지 않는다.

프로라면 시간을 효율적으로 써야하고, 아까운 시간을 낭비하지 않아야 한다.

자신이 스스로 하루에 대해 스케줄링 하고 그것을 잘 지키는 지 확인해보자.

나의 경우 아래와 같은 스케줄을 짜고 있다.

githun action을 통해 하루 Todo를 생성하고, 해당 Todo에 미리 생각해놓은 일정을 집어 넣어 하루에 대한 스케줄을 짜고 있다.

이 글을 작성중인 23년 11월 14일의 Todo는 다음과 같다.

![image](https://github.com/fkdl0048/ToDo/assets/84510455/b0b0e7cf-78d3-44b7-84fb-4cddf4da813e)

나도 매일 잘 지킨다고 말하긴 어렵지만 최대한 지키려고 노력하고 있다.

점점 좋아진다는 느낌도 받고 있어서 자신만의 일정을 관리하는 것은 중요하다.

좀 더 이야기 한다면 Project로 일정 전체를 관리하기에 효율적이다. 미리 2주정도의 계획을 잡아두고 불확실성이 강한 일정의 경우 해당 이슈의 코멘트로 관리하기 때문에 편리하다.

최근에는 여기에 옵시디언까지 활용하여 메모또한 분리했다.

![image](https://github.com/fkdl0048/ToDo/assets/84510455/a231fc77-838f-4a77-af54-cef5511ef8fc)

### 회의

회의는 참석자마다 시간당 약 20만원의 비용이 든다.

회의에 대한 두 가지 진실은 다음과 같다.

- 회의는 필요하다.
- 회의는 **엄청난 시간 낭비**다.

*매우 동의한다.*

### 거부하기

요청을 받았다는 이유로 모든 회의에 참석할 필요는 없다.(프로의 경우다 프로, 신입의 경우는 다르다.)

개발자는 시간을 영리하게 사용해야 한다.

그러므로 신중하게 참석할 회의와 거절할 회의를 골라야 한다.

### 빠져 나오기

회의는 계획대로 흘러가지 않을 때가 많다.

저자의 규칙의 경우 회의가 지루하다고 느낄 땐 바로 빠져나오는 것이다.(한국에서 가능?)

하지만 내가 운영하는 팀에서 이렇게 정신을 차릴 수 있는 찬물을 부워주면 좋겠다..

회의 자체가 길어지는 경우가 종종 있는데, 이럴 땐 회의를 그냥 중단하고 환기하는 것이 더 좋다고 생각하긴 한다.

### 의제와 목표를 정하라

**비용이 비싼 회의를 감내하는 이유는 특정 목표 달성을 서로 도우려면 정말로 참석자들이 한 방에 모여야 하기 때문이다.**

참석자들의 시간을 현명하게 사용하려면, 회의에는 명확한 의제가 필요하며 주제별로 시간과 목표를 명확히 정해야 한다.

*개인적으로 참석자도 어느정도는 회의에 대해 생각하고 와야겠지만, 가장 중요한건 회의를 만든이가 의제를 명확하게 하고, 회의에 대한 전반적인 생각을 하고 참석하는 것이라고 생각한다.*

### 일일 회의

일일 회의는 애자일 개발의 규범 중 하나다.

일일 회의의 또다른 말은 **스탠드 업 미팅**이다.

각 참석자들이 매일 자기 차례에 다음과 같은 질문에 대답한다.

- 어제는 뭘 했는지?
- 오늘은 뭘 할 건지?
- 방해요소는 없나?

이게 전부며 모든 답변은 20초를 넘지 않아야 한다.

즉 10명이 모여도 10분이 채 걸리지 않는다.

### 반복 계획 회의

반복 계획 회의는 애자일 개발의 규범 중에서 가장 잘 해내기 어려운 일이다.

이 것도 또한 스크럼 회의라고도 한다.

반복 주기를 설정하고 미리 다음 일정에 대한 추정이 끝나야 함..

실제 진행중인 프로젝트에서도 적용중인데 아직까지도 잘 안되고 있다.

### 반복 회고와 시연

반복 회고와 시연은 각 반복 주기가 끝날 때마다 시행한다.

팀원들은 무엇이 잘 됐고 무엇이 잘못됐는지 토론한다.

이해관계자들은 새로 작업한 기능의 시연을 본다.

이 회의는 아주 나쁘게 흘러가거나 엄청난 시간을 소모하기 쉬우므로, 반복 주기의 마지막 날 업무 종료시간으로 잡는다.

내가 운용하는 팀은 이를 정기 회의시간에 같이 진행한다.

회고는 2주에 한번 진행하고 시연은 완성된 결과물을 1주에 한번씩 직접 빌드하여 시연한다.

### 논쟁/의견 차이

> 어떤 논쟁이든 5분 안에 해결되지 않으면 논쟁으로는 해결할 수 없다.  
> : 켄트 벡

논쟁이 길어지는 이유는 양쪽 모두 근거가 되는 **명백한 증거**가 없기 때문이다.

기술적인 면에서 나타나는 의견 차이는 보통 대기권을 돌파하는 경우가 많다.

양측은 자기 입장을 끝없이 정당화하지만 실제 데이터를 가진 경우는 드물다.

성깔로 논쟁을 이기려는 부류도 있다.

하지만 성깔로는 논쟁을 마무리짓지 못한다.

**데이터가 꼭 필요하다.**

어디 잘 되나 보자는 심보인 **수동적 공격성**을 가진 부류도 있다.

논쟁을 끝내기 위해 동의를 하긴 하지만 해결안에 참여하기를 거부하는 식으로 결과에 찬물을 끼얹는다.

이런 부류는 "이 방식은 다른 사람들이 원한 방식이야. 어디 한번 원하는 대로 해보라지."라고 스스로에게 말한다.

이런 행동은 프로답지 못한 행동중에도 프로답지 못한 행동이다.

일단 동의했다면, 반드시 참여해야 한다.

*이런 수동적 공격성을 지닌 인물과 작업을 해본적이 있다. 처음엔 답답했지만 뒤에 가선 불쌍했다. 회피할 생각만 하고 자신의 의견을 쉽게 꺼내지도 못하는..*

*자신이 있다면 말했을 것 스스로도 부족한 걸 알아서 그랬다고 생각한다.*  

의견 차이를 해소하기 위한 데이터는 일단 해보는 것이다. 동전을 던지든 하나를 선택하든 결과에 같이 책임을 지고 해보는 것이다.

만약 일이 잘 돌아간다면 쓸 만한 길을 선택했다는 것

### 집중력 마나

프로그래밍은 지적인 행위로 긴 시간 정신을 모아 집중해야 한다.

집중력은 소중한 자원으로 마나와 비슷하다. (다 쓰면 집중을 통해 회복해야 한다.)

프로 개발자는 이를 인지하고 자신의 집중력을 잘 관리해야 한다.

### 수면

수면은 아무리 강조해도 지나치지 않다.

다른 책에서 읽은 말로 평생 1인개발을 할 것이 아니라면 저녁에 자고 아침에 작업해야 한다.

자신은 저녁에 집중이 잘 되기 때문에 새벽 작업을 한다?

그렇다면 아침 작업이 가능하도록 다시 몸을 세팅해야 한다.

나도 최근에는 잠을 자는 시간을 오전 3시를 절대 넘기지 않으려고 한다.

*오전 3시도 많이 늦어서 1시까지 당길 예정..*

### 카페인

카페인을 섭취하면 집중력 마나를 더 효율적으로 쓸 수 있다는 사실은 당연하다.

하지만 카페인은 내성이 생길 수 있다.

자신의 몸을 객관적으로 다시 한번 바라볼 필요가 있다.

### 재충전

집중을 풀면 마나가 일부 회복되기도 한다.

기분좋은 산책, 친구와 대화, 잠시 창 밖을 바라보기 등 스스로 안정감을 느끼고 풍요로움을 느끼는 순간을 찾아라.

*나는 개인적으로 드라마 한편 보기..*

### 근육 집중

근육또한 코딩에 필요한 집중과는 다르지만 집중력을 향상시키는데 도움이 된다.

나는 아침에 정말 간단한 운동을 하고 있다.

최소한의 양심으로..

### 입력 vs 출력

집중에 필요한 다른 한 가지는 적절한 입력과 출력의 균형을 맞추는 것이다.

창의적인 생각을 하기 위해선 창의적인 입력이 필요하다.

그 사람의 모든 생활 출력은 그 사람이 살아온 환경을 알 수 있듯이, 자신이 원하고 끌어당기는 것은 스스로 많이 접하는 것과 관련이 있을 것이다.

나는 드라마나 영화, 책을 많이 보기 때문에 이런쪽에 영향을 많이 받은 듯 하다.

### 타임박스와 토마토

시간관리와 집중을 관리하기 위해 뽀모도로라는 매우 효율적이고 유명한 기법이 있다.

소프트 스킬, 개발자 마인드셋 관련 책을 많이 읽다보니 항상 이런 비슷한 이야기들이 나온다.

그중에서 뽀모도로도 포함이 되는데 나도 항상 사용중이다.

책에선 25분 집중 5분 휴식을 한 싸이클로 4번 이후에 30분정도 길게 휴식한다.

나는 조금 익숙해져서 50분 집중 10분 휴식 4번 이후 30분 휴식을 한다.

아직 나는 숙련자는 아니지만 많이 사용한 사람과 대화했을 때 놀란 점은 모든 자신의 업무를 `뽀모`라는 단위로 관리한다는 것이다.

예를 들어 이번 주 Feature A에 대해 3뽀모정도로 예측하고 실제로 그렇게 행동하는 것이다.

개인적으로 느낀 가장 좋은 점은 자기가 집중한 시간에 대해 객관화가 가능하다는 것이다.

하루를 끝낼 때 내가 정확하게 집중만 한 시간에 대해 메타인지가 가능해지면서 스스로를 과대 평가하지 않고 일정을 적절하게 배분한다는 점이다.

*대부분, 아니 거의 사람들은 자신을 과대평가하는 경향이 있다. 그래서 항상 계획이 실패한다.*

### 피하기

어떤 때는 그저 일이 손에 잡히지 않기도 한다.

해야할 일이 무섭거나 불편하거나 지루해서 그럴지도 모른다.

아마 빠져나올 수 없는 구멍으로 끌려들어가는 느낌일 것이다.

**아니면 단순히 하기 싫어서 그럴지도 모른다.**

### 우선순위 뒤집기

이유가 뭐든 간에 눈 앞의 업무를 피하는 길을 찾아볼 때가 있다.

일보다 다른 일이 더 급하다고 스스로를 설득하기도 한다.

이런 이를 우선순위 뒤집기라고 부른다.

다른 업무의 우선순위를 높여 정말 중요한 일을 뒤로 미룬다.

**우선순위 뒤집기는 스스로에게 하는 거짓말이다.**

정말 끝나야 하는 업무를 마주할 수 없어서, 다른 업무가 더 중요하다고 자신을 설득한다.

아니라는 사실을 알면서 스스로에게 거짓말을 한다.

정확히 말하면 거짓말이 아니다. 실은 다른 사람이 뭘 하는지 왜 그 일을 하는지 물을 때를 대비해 거짓말을 준비하는 것이다.

*사람은 정말 이중적인 존재다.*

당연히 프로답지 못한 행동이고.

프로는 개인적인 두려움과 바람은 제쳐두고 각 업무의 우선순위를 검토하고 우선순위에 따라 순서대로 업무를 진행한다.

우선순위관련해서 다른 책에서 읽은 좋은 방법이 있어서 적어본다.

자신의 일정의 중요도를 우선순위 큐 형태로 관리하여 항상 우선순위를 먼저 처리하는 형태로 진행하는 방법이다.

### 막다른 길

막다른 길은 모든 소프트웨어 장인들이 피할 수 없는 삶의 현실이다.

가끔은 의사결정 후 기술의 오솔길을 따라 이리저리 돌아다녀 보지만 아무 곳에도 도착하지 못한다.

결정이 확고할수록 황무지에서 헤매는 시간이 길어진다.

프로로서의 명성이 걸린 일이라면 영원히 헤매게 된다.

신중함과 경험으로 특정 막다른 길은 피할 수 있지만, 전부 피할 순 없다.

따라서 정말 필요한 기술은 막다른 길에 도달했을 때 재빨리 알아채고 뒤로 물러날 용기를 가지는 일이다. 이를 구덩이의 법칙이라 부르기도 한다.

**막다른 길이면 그만 파라**

내용이 조금 추상적일 수 있어도 막다른 길은 다들 한 번씩 만났을 꺼라 생각한다.

### 진흙탕, 늪, 수렁, 기타 엉망진창

진흙탕은 막다른 길보다 더 나쁘다.

진흙탕은 굼뜨게 만들지만 길을 막지는 않는다. 하지만 오히려 더 나쁘다.

차라리 털고 나와서 다른 평탄한 길을 찾는 것이 더 좋다.

그렇다고 진흙탕에 안빠지는 것이 아닌 개발과정에서 항상 마주하게 되는 함정이다.

진흙탕에 빠지는 일은 자신도 모르게 일어난다.

처음에는 간단한 문제에 대한 해결책을 만들고, 코드를 주의깊게 관리해 단순하고 깔끔하게 만든다.

문제의 범위와 복잡도가 커지면서 기반 코드를 확장하고 최선을 다해 깔끔하게 만든다.

하지만 어느 순간 처음부터 설계가 잘못됐고 코드가 요구사항이 움직이는 방향으로 뻗어나가지 못한다는 사실을 깨닫게 된다.

**이때가 변곡점이다.**

뒤로 물러나서 설계를 고칠 수 있다. (리팩터링이 필요한 이유다.)

반대로 계속 앞으로 나아갈 수도 있다.

되돌아가는 것은 기존 코드를 재작업해야 하기 때문에 비용이 비싸 보이지만, 이때야말로 되돌아가기 가장 쉬운 지점이다.

앞으로 나아가면 시스템을 늪으로 끌고 들어가 절대 빠져 나오지 못하게 된다.

**멀리 갈수록 가장 빠른 길이다. 그리고 급하면 넘어진다.**

### 결론

프로 소프트웨어 개발자는 부지런히 시간과 집중력을 관리한다.

우선순위를 뒤집고 싶은 유혹을 이해하고, 이 유혹에 명예를 걸고 저항한다.

다른 여러 해결책에 마음을 열어 선택지를 넓힌다.

하나의 해결책을 포기하지 못할 정도로 너무 깊이 빠져들지 않는다.

진흙탕이 점점 커지는 것을 언제나 경계하고, 눈치채는 즉시 최대한 빨리 깨끗이 정리한다.

### 느낀점

이번 장은 다른 책에서 읽은 내용의 합성이라 느꼈다.

애자일 방법론과 자기 개발(소프트 스킬)부분이고 시간관리에 있어서 가장 강조하고 싶은 부분은 (경험상..) 자신을 과대 평가하지 말라는 것

나 자신에게도 항상 해주고 싶은 말이라 절대로 과신하지 말것!

과거에 읽고 정리한 글이 있는데 박종천개발자님의 GPAM이라는 방법이다.

[글 첨부](https://fkdl0048.github.io/daily/GPAM/)

#### 논의사항

진흙탕 부분이 제일 재밌다고 생각되서 질문입니다..

- 진흙탕에 빠져보신 경험이 있나요? 그 때의 경험을 알려주세요

저는 첫 프로젝트에서 진흙탕에 빠졌지만 계속 전진했던 경험이 있습니다..

(약 1년전..?)

당시에 객체지향의 `ㄱ`자도 모르던 시절이라 구조적 프로그래밍만 반복하다.

프로그래밍 패턴을 알게 되고 FSM모델을 억지로 적용했다가 힘들게 작업했던 기억이...

지금은 좋은 반면교사로 남아서 좋긴 합니다.

만약 진흙탕에서 이미 많이 들어가버렸다면.. 그게 라이브 서비스, 개발 막바지가 아니라면 무조건 돌아가는게 좋다고 생각합니다.
