## 7장 인수 테스트

개발은 물론이고 의사소통 또한 프로 개발자의 업무이다.

> 입력이 형편없으면 출력도 형편없다.

*GPT에게는 해당되지 않는 말.. 입력 맨날 똥으로 주는데 출력이 엄청나다;;*

### 요구사항 관련 의사소통

프로그래머로서 단순 코딩만 하고 싶다면 당장 1인개발을 하는게 좋다.

내 기준 프로그래머로써 가장 중요하다고 생각되는 역량이 커뮤니케이션이다.

프로그래머와 사업부 사이에 가장 흔한 의사소통 쟁점은 요구사항이다.

사업부는 자신들이 필요하다고 생각했던 바를 나름대로 표현하면, 프로그래머들은 사업부에서 이런 식으로 서술했다고 믿는 바를 나름대로 구현한다.

그러나 현실에서는 요구사항 관련 의사소통은 엄청나게 어렵고, 그 과정에는 오류가 가득하다.

### 시기상조의 정밀도

사업부와 프로그래머는 모두 시기상조의 정밀도라는 함정에 빠지기 쉽다.

사업부는 프로젝트를 승인하기 전에 일이 어떻게 진행될지 정확히 알고 싶어한다.

개발자들이 프로젝트를 추정하기 전에 어떤 제품을 만들어야 할지 정확히 알고 싶어한다.

한마디로 말해 양쪽이 원하는 정밀도는 불가능하고, 그런 정밀도를 얻기 위해 예산을 낭비하는 일도 많다.

### 불확실성의 원칙

리뷰하며 많이 다룬 말이지만, `불확실성`은 정말 중요하다.

불확실성은 매번 등장하고 유연하게 대처하는 것이 중요하다.

이는 개발에 관한 영역에서 동 떨어져 있어서 쉽게 패닉이 오곤 하는데, 이때 지쳐서 번 아웃이 오기도 한다.

### 불안한 추정

개발자 또한 정밀도 함정에 빠진다.

개발자는 시스템 구현을 추정해야 한다.

그리고 시스템 추정에 정밀도가 필요하다고 생각하지만, 그렇지 않다.

첫째로 완벽한 정보로 추정을 한다 해도 추정에는 큰 편차가 생기고야 만다.

둘째로 **불확실성 원칙이 초기 정밀도를 엉망으로 만든다.**

요구사항은 **반드시 바뀌기 때문에 초기 정밀도는 고려할 가치가 없다.**

프로개발자는 정밀도가 낮은 요구사항을 바탕으로 추정해야할 때가 많고, 그런 추정이 말 그대로 추정이라는 사실을 잘 안다.

프로 개발자는 이를 보강하려고 항상 추정에 오차범위를 추가해 사업부에서 불확실성을 이해하게 만든다.

### 때늦은 모호함

시기상조의 정밀도를 해결하려면 가능한 정밀도를 늦추면 된다.

프로 개발자들은 개발 직전까지도 요구사항에 살을 붙이지 않는다.

하지만 이러다 보면 또 다른 병폐인 때늦은 모호함으로 이어지게 된다.

이해당사자들은 의견이 어긋나는 경우가 잦다.

그런 경우 의견 불일치를 해결하기보다는 매끄러운 말 쏨시로 우회하는 게 더 쉽다는 것을 알게 된다.

실제로 분쟁을 해결하지 않고, 모두가 동의하도록 요구사항의 표현을 바꾸는 방법을 찾아낸다.

> 요구사항 문서의 모호함은 이해당사자들 간의 논쟁을 대변한다.  

반대로 이해당사자가 보기엔 완벽하게 분명한 일도 그걸 판독하는 프로그래머에게는 뭔가 완전히 다른 의미가 되기도 한다.

### 인수 테스트

꼭 인수 테스트가 아니더라도 같은 작업자 끼리의 용어는 통일하는 것이 좋다.

### '완료'에 대한 정의

앞 장에서 나온 이야기지만 완료라는 정의를 작업자끼리 통일하는 것이 좋다.

프로개발자에게 완료에 대한 정의는 하나 뿐이다.

완료란 다 됐다는 뜻이다.

모든 코드를 다 작성했고, 모든 테스트를 통과했고, QA와 이해당사자들에게 이를 인수했다는 것

### 의사소통

인수 테스트의 목적은 소통, 명확성 및 정밀성이다.

개발자, 이해당사자 및 테스트 모두 동의함으로써 시스템 행동을 위한 계획을 이해한다.

### 자동화

인수 테스트는 언제나 자동화해야 한다.

소프트웨어 생명주기에 수작업 테스트과정이 있지만, 인수 테스트는 결코 수작업이 되어서는 안된다.

그 이유는 단순하다. **비용** 때문이다.

### 추가 작업

테스트 자체를 추가 작업으로 보지 말고 많은 시간과 비용에 대한 절약으로 볼 수 있다.

이를 한번 더 자동화를 한다면 작업자가 한명 줄어든 셈..

### 누가, 언제 인수 테스트를 작성하는가?

테스트를 작성하는 개발자들은 테스트를 거친 기능을 실행하는 개발자들과는 같지 않다는 점을 유의해야 한다.

인수 테스트는 '늦은 정밀성'의 원칙에 따라 보통 기능 구현 며칠 전에 가능한 늦게 작성해야 한다.

애자일 프로젝트에서 테스트는 다음 반복 주기나 전력질주에서 구현할 기능을 선정한 후에 작성한다.

최초의 몇몇 인수 테스트는 반복 주기의 첫째 날에 준비가 되어야 한다.

매일 더 많은 인수 테스트를 완성해서 반복 주기의 중간 지점에는 모든 인수 테스트가 준비돼야 한다.

### 개발자의 역할

기능 구현 작업은 그 기능의 인수 테스트가 준비되면 시작한다.

개발자는 새 기능에 대한 인수 테스트를 실행해서 오류 과정을 살핀다.

그런 다음 인수 테스트를 시스템에 연결하는 작업을 하고 원하는 기능을 실행해 테스트 통과 과정을 시작한다.

요점은 시스템에 인수 테스트를 연결한 다음 테스트를 통과시키는 것은 개발자의 몫이라는 점이다.

### 테스트 협상과 수동적 공격성

테스트를 만든 사람도 인간이므로 실수를 한다.

때때로 작성된 테스트를 실행 시켰을 때 너무 복잡하고 서툴러서 제대로 되지 않는 경우가 있다.

잘못된 가정을 했거나 그냥 틀린 경우도 있다.

이것은 테스트를 통과시키려는 개발자에게 매우 당혹스러운 일이다.

명심해야 할 일은 가능한 최상의 소프트웨어를 만드는 데 도움을 주는 것이 프로의 일이라는 것이다.

이는 모든 이가 오류와 실수를 살펴서 그것들을 함께 바로 잡는 것이 필요하다는 뜻이다.

### 인수 테스트와 단위 테스트

인수 테스트는 단위 테스트가 아니다.

단위 테스트는 프로그래머가 프로그래머를 위해 만든다.

**단위 테스트는 코드의 최하위 구조와 행동을 설명하는 공식 디자인 문서이다.**

단위 테스트를 읽는 사람은 사업부가 아니라 프로그래머다.

인수 테스트는 사업부를 위해 사업부가 작성한다.

테스트를 두 가지나 만드는 일은 불필요하다고 가정함으로써 '추가 작업'을 없애는 일이 달콤해 보일지도 모른다.

단위 및 인수 테스트가 똑같은 사항을 테스트하는 것이 사실이지만, 불필요한 일과는 거리가 멀다.

같은 내용을 테스트할지라도, 다른 메커니즘과 경로를 통해서 테스트한다.

### GUI 및 다른 문제점

GUI는 제대로 명세하기 어렵다.

할 수는 있지만 잘 하기가 쉽지 않다.

그 이유는 미학이라는 게 주관적이어서 논란의 여지가 있기 때문이다.

그래서 GUI에 대한 인수 테스트 작성이 어렵다.

묘안은 GUI가 일련의 버튼, 슬라이더, 그리드 및 메뉴라기보다는 API인 것처럼 GUI를 만들도록 시스템을 설계하는 것이다.

단일 책임 원칙(SRP)이라는 디자인 원칙이 있듯이 이 원칙이 다른 이유로 바뀌는 것들은 분리하고 같은 이유로 바뀌는 것들은 함께 모아야 한다는 내용을 나타낸다. GUI도 같다.

### 올바른 인터페이스를 통한 테스트

더 나은 방법은 GUI를 통하는 것보다 실제 API를 통해서 기본 시스템의 기능을 불러오는 테스트를 작성하는 것이다.

이 API는 GUI가 사용하는 API와 같아야 한다.

새로운 내용이 아니다.

설계 전문가들은 수십 년 동안 업무 규칙과 GUI를 분리하라고 말해왔다.

GUI 테스트를 최소한으로 유지하라.

테스트들은 GUI의 취약성으로 깨지기 쉽다.

### 지속적 통합

CI/CD는 개발자 한명을 덜 쓰는 것과 같다.

### 출시를 멈춰라

테스트가 통과되지 않는다면 출시를 멈춰라.

### 결론

세부사항에 대한 의사소통은 어렵다.

특히 애플리케이션의 세부사항에 대해 의사소통 해야 하는 프로그래머와 이해당사자에게 들어맞는 말이다.

서로에게 말없이 손만 흔든 다음 상대방이 이해했을 거라 가정해 버리면 일은 너무 쉬워진다.

### 느끼점

의사소통은 매번 말하지면 솔직해야 하는 것 같다..

인수테스트와 단위 테스트에 대한 구별이 확실하게 되는 내용이라 따로 검색해보면서 더 알아봤다.

#### 논의사항

- 테스트 코드에 대한 이해도가 가장 높아진 제목이 뭔가요?

다들 알고리즘을 풀 때 푼 내용이 해당 알고리즘의 테스트 코드를 통과한다 라는 느낌을 아실까요?
대학생레벨에서 테스트 코드를 짜고 공부하기는 쉽지 않아서 실제로 회사에서 많이 배운다고 하더라구요 (안짜는 회사도 많다고 합니다.)
