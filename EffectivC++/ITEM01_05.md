# Effective C++ 3판 1~5 노트 요약

## 1장 C++에 왔으면 C++의 법을 따릅시다
### 항목 1: C++를 언어들의 연합체로 바라보는 안목은 필수
C++는 다중 패러다임 프로그래밍 언어이다.
-> 이전까지 자신있게 객체지향 언어이다라고 한 자신이 부끄러워진다!!
C++는 여러 하위 언어의 연합체로 이해한다.
C, 객체 지향 개념의 C++, 템플릿 C++, STL을 각각 다른 접근 방식으로 다룬다.
-> 템플릿의 비교적 개념이 낯설다 추가 학습이 필요하다.

### 항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자

#define 매크로는 컴파일 전에 전처리기에 의해 처리된다. -> #define으로 정의된 상수는 디버깅 시 원래 이름을 볼 수 없어 문제가 될 수 있다.
따라서, const를 사용하여 상수를 정의하는 것이 더 안전하다.
클래스 멤버로 상수를 정의할 때, 어떤 상수의 유효범위를 클래스로 한정하고자 한다면 static const 멤버를 사용한다.
정수형 클래스 상수의 경우, 클래스 내부에서 초기화된 static const 멤버는 선언과 정의를 동시에 수행한다.
컴파일 순서에 클래스 상수 값이 필요한 경우 '나열자 둔갑술(enum hack)' 방식을 통해 정의할 수 있다.

### 항목 3: 낌새만 보이면 const를 들이대 보자!

const 키워드를 사용하여 객체의 외부 변경이 불가능하다는 의미적인 제약을 소스코드에 붙일 수 있다.
const char * const authorName = "Scott Meyers";와 같은 C 스타일 문자열 상수 선언은 포인터와 포인터가 가리키는 데이터 모두를 상수로 만든다.
std::string을 사용하면 const std::string authorName("Scott Meyers");와 같이 더 간단하게 상수를 선언할 수 있다.
std::string 객체는 그 자체로 변수이며, const로 선언하면 내용 변경과 재할당이 모두 방지된다.
포인터와 객체의 근본적인 차이는 주소 변동성에 있다. 포인터는 가리키는 주소를 변경할 수 있지만, 객체 변수는 할당된 메모리 위치가 고정되어 있다.

### <추가정리>
1. 비트 수준 상수성 vs 논리적 상수성

- 비트 수준 상수성: 객체의 어떤 비트도 변경할 수 없는 상태
- 논리적 상수성: 외부에서 관찰할 수 없는 변경은 허용하는 개념
- mutable 키워드 : const 멤버 함수 내에서도 수정 가능한 멤버를 선언할 때 사용한다.

2. const 멤버 함수의 오버로딩

- const와 non-const 버전의 멤버 함수를 동시에 제공할 수 있다.
- 코드 중복을 피하기 위해 한 버전이 다른 버전을 호출하도록 구현할 수 있다.

3. const의 위치와 의미

- const T*: T 타입 객체를 가리키는 포인터, 객체의 내용을 변경할 수 없음
- T* const: T 타입 객체를 가리키는 상수 포인터, 포인터 자체를 변경할 수 없음
- const T* const: T 타입 객체를 가리키는 상수 포인터, 객체의 내용과 포인터 모두 변경 불가

### 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

초기화되지 않은 변수를 사용하면 '미정의 동작'이 발생할 수 있다.
모든 객체를 사용하기 전에 반드시 초기화한다.
초기화 리스트가 더 효율적이며, const 멤버와 참조 멤버는 초기화 리스트에서 초기화해야 한다.

비지역 정적 객체의 초기화 순서 문제
- 서로 다른 번역 단위에 정의된 비지역 정적 객체들의 초기화 순서는 정해져 있지 않다.
- 이로 인해 한 정적 객체가 초기화되지 않은 다른 정적 객체를 사용하는 문제가 발생할 수 있다.
-> 비지역 정적 객체를 지역 정적 객체로 바꾸어 초기화 순서 문제를 해결한다.

## 2장 생성자, 소멸자 및 대입 연산자
### 항목 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자
C++는 은근슬쩍 생성자와 관련하여 저절로 추가되는 것들이 존재한다.
C++ 컴파일러가 암묵적으로 생성하는 멤버 함수들: 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자 (이들 함수는 클래스에 명시적으로 선언되어 있지 않을 때 생성)
추가되는 함수는 public 멤버이며 inline 함수이다.

