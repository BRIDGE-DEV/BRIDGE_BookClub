# Effective C++ 3판 1~5 노트 요약

## 1장 C++에 왔으면 C++의 법을 따릅시다
### 항목 1: C++를 언어들의 연합체로 바라보는 안목은 필수
C++는 다중 패러다임 프로그래밍 언어이다.
-> 이전까지 자신있게 객체지향 언어이다라고 한 자신이 부끄러워진다!!
C++는 여러 하위 언어의 연합체로 이해한다.
C, 객체 지향 개념의 C++, 템플릿 C++, STL을 각각 다른 접근 방식으로 다룬다.
-> 템플릿의 비교적 개념이 낯설다 추가 학습이 필요하다.

### 항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자

#define 매크로는 컴파일 전에 전처리기에 의해 처리된다. -> #define으로 정의된 상수는 디버깅 시 원래 이름을 볼 수 없어 문제가 될 수 있다.
따라서, const를 사용하여 상수를 정의하는 것이 더 안전하다.
클래스 멤버로 상수를 정의할 때, 어떤 상수의 유효범위를 클래스로 한정하고자 한다면 static const 멤버를 사용한다.
정수형 클래스 상수의 경우, 클래스 내부에서 초기화된 static const 멤버는 선언과 정의를 동시에 수행한다.
컴파일 순서에 클래스 상수 값이 필요한 경우 '나열자 둔갑술(enum hack)' 방식을 통해 정의할 수 있다.

### 항목 3: 낌새만 보이면 const를 들이대 보자!

const 키워드를 사용하여 객체의 외부 변경이 불가능하다는 의미적인 제약을 소스코드에 붙일 수 있다.
const char * const authorName = "Scott Meyers";와 같은 C 스타일 문자열 상수 선언은 포인터와 포인터가 가리키는 데이터 모두를 상수로 만든다.
std::string을 사용하면 const std::string authorName("Scott Meyers");와 같이 더 간단하게 상수를 선언할 수 있다.
std::string 객체는 그 자체로 변수이며, const로 선언하면 내용 변경과 재할당이 모두 방지된다.
포인터와 객체의 근본적인 차이는 주소 변동성에 있다. 포인터는 가리키는 주소를 변경할 수 있지만, 객체 변수는 할당된 메모리 위치가 고정되어 있다.

### <추가정리>
1. 비트 수준 상수성 vs 논리적 상수성

- 비트 수준 상수성: 객체의 어떤 비트도 변경할 수 없는 상태
- 논리적 상수성: 외부에서 관찰할 수 없는 변경은 허용하는 개념
C++은 비트 수준 상수성을 체크한다.
그러나 본문에 나온 바와 같이 객체 내부 데이터에 대한 참조자를 반환하는 경우, 상수성을 해치는 결과가 나온다.
이를 보완하기 위해 논리적 상수성 개념이 나왔다. -> 가장 쉬운 해결법은 mutuable 키워드를 사용하는 것이다.

2. const 멤버 함수의 오버로딩

- const와 non-const 버전의 멤버 함수를 동시에 제공할 수 있다.
- 코드 중복을 피하기 위해 한 버전이 다른 버전을 호출하도록 구현할 수 있다.

3. const의 위치와 의미

- const T*: T 타입 객체를 가리키는 포인터, 객체의 내용을 변경할 수 없음
- T* const: T 타입 객체를 가리키는 상수 포인터, 포인터 자체를 변경할 수 없음
- const T* const: T 타입 객체를 가리키는 상수 포인터, 객체의 내용과 포인터 모두 변경 불가

### 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

초기화되지 않은 변수를 사용하면 '미정의 동작'이 발생할 수 있다.
모든 객체를 사용하기 전에 반드시 초기화한다.
초기화를 위해 대입을 하려고하면, 생성자에 진입하기도 전에 각 데이터 멤버의 기본 생성자가 호출된다. -> 기본 제공 타입의 경우 대입 되기 전에 초기화된다는 보장이 없다
따라서 생성자에서 초기화를 하고 대입을 수행하기에 앞에서 행한 초기화는 헛짓이 된다.
초기화 리스트 사용 : 데이터 멤버에 대한 생성자의 인자로 초기화 리스트의 인자가 바로 사용되기 때문에 훨씬 더 효율적이다.

비지역 정적 객체의 초기화 순서 문제
- 서로 다른 번역 단위에 정의된 비지역 정적 객체들의 초기화 순서는 정해져 있지 않다.
- 이로 인해 한 정적 객체가 초기화되지 않은 다른 정적 객체를 사용하는 문제가 발생할 수 있다.
-> 비지역 정적 객체를 지역 정적 객체로 바꾸어 초기화 순서 문제를 해결한다.

## 2장 생성자, 소멸자 및 대입 연산자
### 항목 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자
C++는 은근슬쩍 생성자와 관련하여 저절로 추가되는 것들이 존재한다.
C++ 컴파일러가 암묵적으로 생성하는 멤버 함수들: 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자 (이들 함수는 클래스에 명시적으로 선언되어 있지 않을 때 생성)
추가되는 함수는 public 멤버이며 inline 함수이다.
이때, 상속한 클래스의 가상성을 물려받도록 되어 있다.

