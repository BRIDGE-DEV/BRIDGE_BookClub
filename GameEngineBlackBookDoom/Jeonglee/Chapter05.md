## Chapter 05: 소프트웨어 idTech 1

- 프로젝트를 이식하기 위한 플랫폼 결정에 지금까지 개발중인 리눅스를 선택한 것 자체가 현명하다.
- 아키텍처부분에서 말하는 개발과 빌드의 분리는 현대에도 많이 사용하는데, 나는 데스크탑으로 개발하고 노트북으로 자동 빌드를 돌린다. *명령어를 만들거나 CI/CD자체를 사용하는 전략도 좋을 것 같다.*
- 엔디언의 문제는 살짝 컴구시간에 배웠던 것 같은..
- API를 해결하기 위해 자체적인 운영체제와 비슷한 설계를 했다는 점과 미해결 심벌을 해결하는 과정이 인상적이다.
- 네임스페이스가 없기에 접두사를 함수 이름에 사용했다는 점 다른 분들은 자주 사용하는 접두사나 접미어가 있는지?
- 메인 함수를 기점으로 엔트리 포인트로 모든 코드를 탐색하는 방식에서 객체지향 코드가 아니기에 엔트리 포인트에서 시작하는 코드라는 구조
- 둠의 main코드는 현대의 게임 코드와 크게 다르지 않을 것 같다. 초기화하고 루프를 돌리는 코드 *아마 앞으로도..*
- 둠이 유저가 게임 모드를 제작할 수 있도록 오픈한 최초인가? total conversion TC
- 프레임버퍼 5개 4개는 비디오 1개는 sufff에 사용
- 화면지우기와 같은 기능을 실제 랜더 버퍼를 조합하여 사용한다면 현대에는 쉐이더를 사용할 것이다 비용이 어느정도 일까?
  - 무작위 숫자 수열을 사용하여 물결 효과를 내는 부분과 요즘 개발의 노이즈 활용 방법과 유사하다.
- **Doom BSP관련 도움이 된 영상**
  - https://www.youtube.com/watch?v=hYMZsMMlubg&t=480s
- 원근법, 선형보간 등 유용한 내용
- paint algorithm -> warnock algorithm -> BSP
  - 워녹은 4분할 알고리즘으로 쿼드트리 알고리즘과 비슷하지만 목적이 다름
- visplane_t 시계면은 프레임 버퍼를 지워서 흰색으로 처리하는 대신 마지막 프레임 내용을 활용
- 조명효과를 제한된 환경내에서 구현하기 위한 방법으로 라이트맵
- 클리핑 drawseg_t, 주인공을 기준으로 거리로 정렬되며 뒤에서 부터 앞으로 그려진다. (배경과는 반대로) 일종의 스프라이트를 뿌리는 것으로, 움직이는 적군을 그리기 때문에 위치가 변경되기에 이중 연결 리스트로 구현
- 주인공은 맨위 레이어에 그려짐
- 오디오 관련 이슈는 이해하기 어려웠음 구동 방식 자체를 잘 모르다 보니..
- C로 객체지향을 위조하는 방법 -> 함수 포인터
- 최적화 기능은 직관적이면서도 효율적이다.
- 게임 틱 아키텍처를 보면서 생각이 드는 것은 선형적인 update를 가지기에 함수 호출 순서에 대한 신경이 많이 들어가는 것 같다.
- 서버 없이 독자적으로 틱을 돌린다. -> P2P방식의 시도와 혁신