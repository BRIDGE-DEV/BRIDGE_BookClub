# REFACTORING_CHAPTER02

# 리팩터링 원칙

## 내용 정리

---

### 리팩터링 정의

- 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
(함수 추출하기, 조건부 로직을 다형성으로 바꾸기)
- **특정한 방식**에 따라 코드를 정리하는 것만이 리팩터링
- 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.
- 코드베이스를 정리하거나 구조를 바꾸는 모든 작업 ⇒ 재구성, 리팩터링은 재구성 중 특수한 한 형태

### 두 개의 모자

- 소프트웨어를 개발할 때 목적 '기능 추가' or '리팩터링' 명확히 구분해 작업
- 두 개를 동시에 하면 비효율적

### 리팩터링하는 이유

1. 리팩터링하면 소프트웨어 설계가 좋아진다
    - 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다 → 악효과 누적
    - 중복 코드 제거 → 모든 코드가 언제나 고유한 일을 수행함 보장, 바람직한 설계의 핵심
2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다
    - 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다.
    - **단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다.**
3. 리팩터링하면 버그를 쉽게 찾을 수 있다
4. 리팩터링하면 프로그래밍 속도를 높일 수 있다
    - 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램의 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다. 처음부터 좋은 설계를 만들기엔 어렵고 시간도 많이 소모 → 일단 만들고 리팩터링하자

### 언제 리팩터링해야 할까?

> “**3의 법칙”**
> 
> 
> 1. 그냥한다
> 
> 2. 비슷한 일을 두번째로 하게되면, 일단 계속 진행한다.
> 
> **3. 비슷한 일을 세번째 하게 되면 리팩터링한다.**
> 
1. 준비를 위한 리팩터링: 기능을 쉽게 추가하기 만들기
    - 다들 "직진!"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다.
2. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
    - 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다. 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.
3. 쓰레기 줍기 리팩터링
4. 계획된 리팩터링과 수시로 하는 리팩터링
    - 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
    - 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
5. 오래 걸리는 리팩터링
    - 예컨대 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다. (추상화로 갈아타기 전략)
6. 코드 리뷰에 리팩터링 활용하기
7. 관리자에게는 뭐라고 말해야 할까?
    - 말하지 않는다. 구체적인 방법은 개발자가 판단하는 것. 가장 빠르게 구현하는 방법은 리팩터링
8. 리팩터링하지 말아야 할때
    - 내부 동작을 이해 해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
    - **리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.**

### 리팩터링 시 고려할 문제

1. 새 기능 개발 속도 저하
2. 코드 소유권
3. 브랜치
4. 테스팅
5. 래거시코드
6. 데이터베이스

### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 코딩 전에 아키텍처를 확정지으려 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다. 하지만 막상 해보면 실현할 수 없는 목표일 때가 많다.
- 리팩터링을 활용하면, 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.
- **YAGNI: you aren't going to need it** (필요 없을 거다)

### 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드 + 리팩터링 ⇒ 테스트 주도 개발(TDD)

## 느낀 점

---

“재구성과 리팩터링은 다르다” 라는 문장이 기억에 남는다. 

리팩터링에 대해서 알지 못했을 때, 정리만 한다면 그게 리팩터링이다라고 단순하게 생각해왔다.

지금까지 리팩터링은 코드를 수정하는 행위 대부분을 포함한 대주제 라고 생각해왔었다. 하지만 이 챕터를 읽고 깨달았다.

마치 리팩터링의 메뉴얼을 설명해주는 느낌이다.

> 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야한다. 
리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야한다.
전체 변경 과정을 작고 독립된 단계들로 쪼개라.
> 

이 내용도 머리에 새겨야겠따..

## 논의 내용

---

리팩터링을 포기하고 새로 작성하게 된 경험이 있으신가요?