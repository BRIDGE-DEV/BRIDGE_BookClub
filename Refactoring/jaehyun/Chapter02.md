2장 리팩터링 원칙
=============
### 리팩터링의 정의
[명사]소프트웨어의 겉보기 동작은 그래도 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.

[동사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 기법을 적용해서 소프트웨어를 재구성하다.

코드를 정리하는 작업이 모조리 '리팩터링'이 아니다. 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.
 
 리팩터링은 동작을 보존하는 작은 단계를 거쳐 코드를 수정한다. 따라서 리팩터링 하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다. 

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

저자는 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성(restructuring)'이란 용어로 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 본다.

앞선 '겉보기 동작(observable behavior)'이란 표현은 리팩터링 전 후 코드가 똑같이 작동해야 한다는 뜻이다.  콜스택이 달라져 성능이 변하더라도 사용자 관점에서는 달라지는 점이 없어야 한다.

기능을 유지한채 코드를 변경한다는 점에서 성능 최적화와 비슷하지만 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램의 성능은 좋아질 수도, 나빠질 수도 있다. 성능 최적화는 속도 개선에만 신경쓴다. 그래서 목표 도달을 위해 코드는 다루기 더 어렵게 바뀔 수도 있음을 각오해야 한다.

### 두 개의 모자
저자는 소프트웨어를 개발할때 '기능 추가'와 '리팩터링'을 명확히 구분해서 작업한다. '기능 추가'를 할때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. '리팩터링'할때는 기능 추가는 절대 하지 않기로 하고 코드 재구성에만 전념한다.

새 기능을 추가하다 보면 코드 구조를 바꿔야 훨씬 쉽겠다는 생각이 들면 리팩터링하고, 구조가 개선되면 다시 기능 추가를 이어간다. 추가한 기능이 제대로 작동하는지 확인하면 작성한 코드를 살펴보고 이해하기 어렵게 짜였다면 다시 리팩터링한다.

두 작업을 계속 오가지만 지금 하는 작업에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

### 리팩터링하는 이유
리팩터링이 모든 문제를 해결하는 만병통치약은 아니다. 하지만 코드의 건강하게 유지하는데 도움을 주는 약임은 분명하다.

- **리팩터링하면 소프트웨어 설계가 좋아진다.**
	아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 코드만으로 설계 파악이 어려워지고 그러면 설계를 유지하기 어려워진다. 반복적인 리팩터링은 코드의 구조를 지탱해 준다.
	
	설계가 나쁘면 코드가 길어진다. 코드가 중복될 수 있기 때문이다. 그래서 중복 제거는 설계 개선 작업의 중요한 한 축이다. 코드량, 프로그램 용량이 속도에 영향을 주는 경우는 별로 없다. 하지만 코드량이 줄면 이해 해야할 코드량이 줄고 수정하기 쉬워진다. 

- **리팩터링하면 소프트웨어를 이해하기 쉬워진다.**
	프로그래밍은 내가 원하는 바를 정확히 표현하는 일이다. 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다. 그리고 그 개발자는 나 자신일 때가 많다. 
	잘 작동하지만 이상적인 구조는 아닌 코드가 있다면 시간을 내서 리팩터링해보자. 그러면 코드의 목적, 내 의도를 더 명확하게 전달하도록 개선할 수 있다. 

- **리팩터링하면 버그를 쉽게 찾을 수 있다.**
	코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링하면 코드가 하는 일을 깊이 파악하게 되고 구조를 명확하게 다듬으면 어렴풋이 가정하던 것들이 분명히 드러난다.

- **리팩터링하면 프로그래밍 속도를 높일 수 있다**
	리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수도 있다. 하지만 설계가 나쁘면 결국 새로운 기능을 추가하기 점점 어려워지고 개발 속도가 떨어진다. 저자는 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다고한다. 
	
	처음부터 좋을 설계를 마련하기란 매우 어렵다. 하지만 리팩터링은 기존 코드의 설계를 얼마든지 개선할 수 있다. 그래서 빠른 개발이라는 목표를 달성하려면 리팩터링이 반드시 필요하다.

### 언제 리팩터링해야 할까?
저자는 거의 한 시간 간격으로 리팩터링한다. 작업 흐름에 리팩터링을 녹이는 방법에 여러가지가 있다.

> **3의 법칙** 
> 1. 처음에는 그냥한다.
> 2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

- **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
	리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다. 예를 들어 리터럴 값을 포함한 함수의 경우 복제해서 사용하면 코드의 중복과 버그 수정에 어려움이 생긴다. 이럴 때 함수 매개변수화하기를 적용한다.
	버그를 잡을 때도 오류를 일으키는 코드가 여러 곳에 복제되어 있으면 일단 한 곳으로 합치는 편이 작업하기에 편하다.

- **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
	코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 저자는 코드를 파악할 때마다 코드의 의도를 더 명확하게 드러나도록 리팩토링할 여지가 없는지 찾아본다. 조건부 로직의 구조가 이상하지 않은지, 함수 이름이 실제 하는 일을 파악하기 용이한지도 살핀다.
	
	리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그 다음 수정한 코드를 테스트해보면 내가 이해한게 맞는지 확인도 할 수 있다. 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나눈다. 이런 초기 단계의 리팩터링은 밖을 잘 내다보기 위한 창문 닦기에 비유된다.
	
	코드를 분석할때 리팩터링 해보면, 그러지 않았으면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

- **쓰레기 줍기 리팩터링**
	코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 이때 약간 절충을 해야 한다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다. 그렇다고 나중에 일을 방해하도록 내버려 두는 것도 좋지 않다. 저자는 간단하게 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.
> 보이스카웃 규칙 - "왔을때 보다 더 깨끗하게 만들고 떠나라"

- **계획된 리팩터링과 수시로 하는 리팩터링**
	저자는 앞서 말한 종류의 리팩터링은 모두 기회가 될 때만 진행한다. 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.
	
  > 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

  리팩터링은 실수나 보기 싫은 코드를 정리하는 작업이 아니다. 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다. 어제 적합했던 기준이 오늘 작업에는 맞지 않을 수 있다. 이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링 하기가 더 쉽다.

  > 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.

  사람들은 소프트웨어 개발을 뭔가 '추가'하는 과정이라고 여기지만 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길이다. 소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다. 새 기능을 추가 할 때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많다.
  
  계획된 리팩터링이 무조건 나쁜건 아니다. 그 동안 리팩터링에 소홀했다면, 따로 시간을 내어 코드베이스를 개선할 필요가 있다. 정기적으로 리팩터링하더라도 어떤 문제는 여럿이 달려들어야 할 정도로 곪아갈 수도 있다. 하지만 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
  
  버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리할 때 큰 장점은 두 가지 활동을 구분해서 별개로 검토하고 승인할 수 있다. 하지만 리팩터링은 기능 추가와 밀접한 경우가 많기 때문에 굳이 나누는 것은 시간 낭비일 수도 있다. 해당 리팩터링은 하게된 맥락 정보가 사라져서 왜 수정했는지 이해하기 어려워진다. 각 커밋을 분리하는게 무조건 좋은 것은 아님을 명심하고, 팀에 적합한 방식을 실험해서 찾아내야 한다.

- **오래 걸리는 리팩터링**
	리팩터링은 대부분 수분에서 몇 시간 정도로 끝나지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다. 저자는 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.
	
- **코드 리뷰에 리팩터링 활용하기**
	코드 리뷰는 시니어가 주니어에게 노하우를 전수할 수 있어 개발팀 전체에 지식을 전파하기 좋다. 깔끔한 코드를 작성하는 데에도 중요하다. 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다. 또한 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다. 이처럼 서로의 기여가 일을 더욱 편하게 만들어주므로 저자는 기회가 닿는 대로 코드 리뷰를 한다.
	
	리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다. 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다. 그러다 보면 리팩터링해보지 않고는 떠올릴 수 없던 아이디어가 떠오르기도 한다. 또한 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문에 코드 리뷰를 진행하며 훨씬 큰 성취감을 맛볼 수 있다.
	
	코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다. 코드 작성자가 없는 풀 리퀘스트 모델에서는 그리 효과적이지 않다. 가장 좋은건 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다.

- **관리자에게는 뭐라고 말해야 할까?**
	기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에 있는 이들에게 저자는 "리팩터링한다고 말하지 말라"고 조언한다. 소프트웨어 개발자는 프로이며 그 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 그 구체적인 방법은 개발자가 판단해야 한다. 새 기능을 만드는 가장 빠른 방법은 리팩터링이다.

- **리팩터링하지 말아야 할 때**
리팩터링하면 안 되는 상황도 있다. 저자는 지저분한 코드를 발견해도 외부 API 다루듯 호출해서 쓰는 등의 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

  리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다. 이런 결정을 내리기는 쉽지 않다. 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많기 때문이다. 이런 결정은 뛰어난 판단력과 경험이 뒷받침돼야 한다. 따라서 이 판단에 대해 한 마디 조언으로 표현하기 어렵다.

#### 리팩터링 시 고려할 문제
리팩터링에 딸려오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다.

- **새 기능 개발 속도 저하**
	앞선 내용과 마찬가지로 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다. 하지만 리팩터링으로 인해 진행이 느려진다는 생각이 실전에서 리팩터링을 적용하는 데 가장 큰 걸림돌인 것 같다.
	> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

	저자는 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다. 그래서 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다. 하지만 불필요하다고 생각되거나 결정을 미루기도 한다. (앞서 말한 경험전인 판단인 듯하다)
	
	하지만 리팩터링을 과하게 하는 경우보다 거의 하지 않는 경우가 훨씬 많고 관리자가 아닌 개발자 스스로 리팩터링에 회의적인 경우도 있다. 코드베이스의 건강이 생산성에 어떤 차이를 미치는지 경험해 보지 않고는 체감하기 어려울 수 있다.
	
	사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. 리팩터링은 보기 좋은 코드를 만들기 위한 것이 아닌 개발 기간을 단축하기 위한 경제적인 이유로 하는 것임을 인식해야 한다. 리팩터링 하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다.

- **코드 소유권**
	코드의 소유자가 다른 팀이라서 나에게 쓰기 권한이 없거나 함수가 고객에게 API로 제공된 경우처럼 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 물론 제약이 있지만 개선할 수는 있다. 기존 함수를 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정하면 인터페이스는 복잡해지지만 클라이언트에게 영향은 주지 않는다.
	
	이처럼 복잡해지기 때문에 저자는 코드 소유권은 작은 단위로 나눠 관리하는 데 반대하며 코드의 소유권을 팀에 두는 것을 선호한다. 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다. 프로그래머마다 각자가 책임지는 영역이 있을 수는 있다. 이 말은 자신이 맡은 영역의 변경 사항을 관리하라는 뜻이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아니다.

- **브랜치**
	

느낀점
=============
모자를 바꿔쓴다는 표현은 그만큼 간단한 작업이라도 코드를 추가하는 순간과 구조를 수정하는 순간을 분명하게 인지하며 작업한다는 의미라고 생각된다. 간단한 기능 추가를 하며 구조를 살짝 손본다고 그걸 각각의 사안으로 생각하며 작업하진 않았는데 그래서 가끔 원래 목적과 벗어나서 이곳저곳 만지고 있던게 아닌가 하는 생각이 들었다.



논의 사항
=============
저자는 코드를 팀이 소유하고 다른 사람이 작성한 코드도 자유롭게 수정할 수 있는 방식을 선호한다고 했는데 저는 다른 사람이 작성한 코드를 직접 수정하는게 조심스럽습니다.
코드 수정권한에 대한 생각이나 경험이 궁금합니다.
