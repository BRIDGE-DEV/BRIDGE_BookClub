#03. 코드에서 나는 악취

>냄새나면 당장 갈아라.

근래에 가장 깊은 공감이 되는 부분이 아닐까싶다.
과거 1년, 2년 전의 코드를 보고 있자하면 이미 깊은 진한 냄새가 피어오른다. 내 것이 아니라고 하고 싶을 정도로 부끄럽고 창피한데 이것은 뒷 전의 이야기이다.
여기서 저자는 각 문제에 맞게 정리를 해두었다. 

저자는 어떠한 방법으로 문제를 해결해 나아갈 것인가에 대해 설명을 해주었는데, 사실 문제에 대한 부제목들만 읽더라도 어찌 고쳐야하는지는 감이 온다. 그렇다면 우리가 해야할 가장 좋은 방법은 알았으니 반복되지 않도록 초장에 잘 만드는 것이라 생각한다.


1. 기이한 이름: 어렵다. 문맥의 흐름을 이해하고 다시 네이밍을 찾아보자.
2. 중복 코드: 함수로 묶어내고 이름을 잘 지어두자. 중복되는 곳은 눈에 띄기 마련이다.
3. 긴 함수: 다른 곳에서 쓰려면 긴 함수는 의미가 없다. 쪼개고 또 쪼개자.
4. 긴 매개변수 목록: 가장 기본이 되는 것은 클래스로 묶는 것이다.
5. 전역 데이터: 쓰지 않는 방향 + 캡슐화 필수.
6. 가변 데이터: 데이터가 변경된다면 복사본을 만들고 반환하자.
7. 뒤엉킨 변경: 하나의 무언가를 변경할 때, 모든 것이 뒤바뀔 수 있다. 맥락을 잘 파악하여 나누는 것이 기본.
8. 산탄총 수술: 변경할 부분이 전반에 퍼져있다면, 어설프게 로직을 짠 것이다. 되돌아보자.
9. 기능 편애: 자신이 위치해야하는 곳에서 쓰이는 것보다 외적인 곳에서 더 많이 쓰인다면 7, 8번과 같이 처음으로 되돌아가보자.
10. 데이터 뭉치: 해당 데이터가 꼭 필요한지 확인하자. 중복은 아닌지. 이것 역시 객체지향적이지 않아서 발생했을 수 있다.
11. 기본형 집착: 문명 사회를 위해 기본 타입들을 객체로 바꿔주자. 귀찮은 출력에 도움이 된다.
12. 반복되는 switch문: 하나의 함수에 switch가 두 번 이상이라면 다시 확인하자. 그럴 필요 없을 것이다. 중간에 조건절 추가되면 머리 터진다.
13. 반복문: 특별한 경우가 아니라면 linq나 파이프라인 연산으로 사용하자.
14. 성의 없는 요소: 구조를 너무 크게 잡았다면 필요 없는 부분은 과감하게 제거하자.
15. 추측성 일반화: 나중에 필요하겠지 이전에 결정짓자. 제거하자.
16. 임시 필드: 필요 없는 값이 많다면, 서브 클래스로 크기를 줄여두자.
17. 메시지 체인: 종속되는 것이 많을수록 구조는 복잡해진다. 서로 끊어내거나 존재를 감춰버리자.
18. 중개자: 위의 존재를 감추기 위해서 캡슐화가 필요하다. 이러한 중개자는 자주쓰면 문제가 된다.
19. 내부자 거래: 상속이나 결합도가 높다면, 중개자를 만들자.
20. 거대한 클래스: 각자의 역할에 맞게 쪼개주자. partial가 적당하다.
21. 서로 다른 인터페이스의 대안 클래스들: 인터페이스를 동일하게하여 동작까지 맞추고 다른 클래스 안으로 밀어넣는다...?
22. 데이터 클래스: 불변의 데이터는 세터를 제거하자. 
23. 상속 포기: 계층 구조를 잘못 설계했다면, 물려받지 않을 코드를 모조리 새로운 클래스로 나눠버리자.
24. 주석: 주석을 남기고 해당 목적이 맞는지 돌아보자. 그리고 분리하자.


+이 부분은 당장에 해결할 수 없고, 이해할 수 있는 부분이 아니라고 본다.
	+아마 나와 같이 스스로가 더 잘 알고 있을 것이다. 부끄러운 부분은 리팩터링이 필요하단 것이고 그만큼 성장했다는 것일테니.
	+다만 이 과정에 있어서 혼자서 성장할 수는 없다. 남의 코드를 읽어야하고 본인의 코드도 끊임없이 되돌아봐야한다.
	+리팩터링의 문제와 해결책에 대해서 '왜 그런 식인지'에 대해서만 궁금해진다면 이해를 돕기에는 충분하지 않을까.