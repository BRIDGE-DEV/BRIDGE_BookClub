#06. 기본적인 리팩터링
>추출은 곧 이름짓기.

##함수 추출하기
코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 이름을 붙인다.

1. 대여섯 줄을 넘어가면 추출 대상
2. 이름 짓기에 특별히 신경 쓸 것 (가장 어려움...)
3. 같은 주소를 참조하고 있을 수도 있다. 새 값을 반환하도록 처리하자.

>값을 반환할 변수가 여러 개라면?
Tuple이나 각 각의 out T로 반환하는 것도 방법이지 않을까.


## 함수 인라인하기
거슬리는 이름을 짤막한 함수로.

1. 간접 호출이 과하다면 인라인 대상
2. 예시: InTopRating => player.rank > const.ranker(100);
3. 직관적이므로 아주 유용할 듯 하다.


##변수 추출하기
지역 변수를 활용하여 표현식을 쪼개보자.

1. 문맥의 이해를 돕기 위한 과정
2. 덩치가 큰 클래스가 있다면 별도의 함수로 뽑아내어 추상화하면 좋음


##변수 인라인하기
변수가 너무 많다면 줄여보자. (변수 추출하기의 반대)

var basePrice = anOrder.basePrice; 
	return (basePrice > 1000);
return anOrder.basePrice > 1000;
1. 함수 인라인과 매우 비슷


## 함수 선언 바꾸기
함수 이름 바꾸기.

1. 코드를 볼 때 무슨 일을 하는지 단 번에 이해할 수 있게.
2. 주석을 이용해 함수의 목적을 설명해보자. (이건 필수인 듯)
3. 마이그레이션을 진행 할 때에는 모두에게 공유하는 것이 좋다.


##변수 캡슐화하기
접근에 대한 범위 체크. 로우 데이터를 다루어야할 때. 

1. private로 가시 범위를 제한한다.
2. 객체 지향에 대한 기본을 유지할 것.
3. Clone으로 복제를 이용하여 변경을 막는 것도 방법. (특별할 때만)


##변수 이름 바꾸기
이름 짓기가 가장 어렵다.

1. 어렵다. 어려워. 다른 사람의 코드도 많이 보고 배워볼 것.
2. 이름을 의미 없이 줄이는 것은 비추천 (아무도 이해 못함)


##매개변수 객체 만들기
데이터 항목이 묶음으로 몰려다닌다면 모아보자.

1. 데이터 구조를 새로 만드는 것
2. 예시: 최대 최소의 쌍을 발견한다면 범위 객체로 바꿔보자.


##여러 함수를 클래스로 묶기
함수들이 공유하는 공통 환경을 더 명확하게 표현해보자.

1. 예시: MathHelper, TimeService, EnumerableService 등등


##여러 함수를 변환 함수로 묶기
같은 로직이 보인다면 하나로 모아보자.

1. 변환 함수를 이용하여 중복의 위험을 피해두자
2. 가장 위험한 것은 전부 묶게 되면 사용처가 다를 때 문제가 발생할 수 있다는 점.


##단계 쪼개기
서로 다른 두 대상을 한꺼번에 다룬다면 쪼개보자

1. 지저분한 동작들을 발견하면 하나에만 집중 할 수 있도록 쪼개보자
2. 동작에 흐름을 부여하는 것이기에, 순차적인 단계에 따라 리팩터링이 필요
3. 관계에 대해서는 이해할 필요 없고, 목적만 존재하면 된다.
4. 예시: 타일 맵 게임에서 캐릭터가 이동한다면 ?
이동 가능 여부를 하나로 쪼개고, 좌표에 따른 이동을 하나로 쪼개고, 특정 오브젝트에 대한 만남을 하나로 쪼개고...




?각 리팩터링에 대한 기법을 볼 때마다 드는 생각은 

리팩터링에 대상은 대부분 목적과 흐름에 대한 중요성을 보여주고
객체지향을 얼마나 지키지 않았는지에 대한 물음으로 보인다.

지금 내가 짜고 있는 코드에서도 대상이 꽤나 많다.
그것을 쪼개고 다시 합치고 하는 작업에 위의 예시를 적용하면 훨씬 더 나은 코드로 자리할 수 있어보인다.
Snapshot, LogicHolder 이런 것들이 리팩터링 이후 생겨난 아이들이라는 것을 보면 이해가 굉장히 쉬웠다.