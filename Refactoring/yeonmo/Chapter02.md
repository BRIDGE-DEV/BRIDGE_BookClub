# 리팩터링 02

### 두 개의 모자

항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

저자는 소프트웨어를 개발할 때 목적이 ‘기능 추가’냐, 아니면 ‘리팩터링’이냐를 명확히 구분해 작업한다.

본인이 하고자 하는 일의 방향성을 확실하게 하고, 그에 적합한 작업만 하라는 뜻이다.

### 리팩터링하는 이유

1. 소프트웨어 설계가 좋아진다.
2. 소프트웨어를 이해하기 쉬워진다.
3. 버그를 쉽게 찾을 수 있다.
4. 프로그래밍 속도를 높일 수 있다.

### 언제 리팩터링해야 할까?

3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)

리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

원하는 방향으로 조금씩 개선하는 식이다.

### 리팩터링하지 말아야 할 때

내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 하지 않는다.

리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다.

### 코드 소유권

저자가 선호하는 방식은 코드의 소유권을 팀에 두는 것이다.

그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다.

오픈 소스 모델

: 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는, 흡사 오픈소스 개발 모델.

변경 사항 커밋을 클라이언트를 관리하는 쪽에서 승인하면 기존 함수를 삭제할 수 있다.

### 브랜치

기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다.

### 레거시 코드

프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다.

### 데이터베이스

병렬 수정으로 필드 이름을 바꾸는 예시

1. 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않는다.
2. 기존 필드와 새 필드를 동시에 업데이트하도록 설정
3. 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체
4. 더는 필요가 없어진 예전 필드를 삭제

### 애그니(YAGNI)

앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.

호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다.

### 리팩터링과 성능

성능을 개선하기 위한 최적화가 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다.

시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다.

프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 그리고 성능에 큰 영향을 주는 부분만 집중해서 최적화한다.

## 논의사항

짝 프로그래밍을 해 본 경험이 있나요? 저는 개인적으로 짝 프로그래밍 좋아해서 같이 이야기해 보고 싶어요.

코드 소유권과도 연관해서 생각해 보면 좋을 것 같아요.