## 2. 리팩터링 원칙

### 2.1 리팩터링 정의

수 많은 다른 소프트웨어 개발용어와 같이 리팩터링(Refactioring)이라는 단어도 다소 두루뭉실하게 사용된다.

*ex) 인터페이스, 도메인 등등*

저자는 이 용어을 더 구체적으로 사용해야 한다고 주장하며, 명사와 동사로도 사용 가능하다고 한다.

* 명사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
* 동사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 `리팩터링`이라고 표현하고 있는데, 앞에서 제시한 정의에 따르면 **특정한 방식**에 따라 코드를 정리하는 것만이 리팩터링이다.

리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했어"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 재구성이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 한 형태이다.

한 번에 바꿀 수 있는 작업을 수 많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하게 되면 리팩터링하는 것이 오히려 더 비효율적이라고 생각할 수 있는데, 잘게 나눌 수록 오히려 작업을 더 빨리 처리할 수 있다.

*작업은 사람이 하기에*

앞에서 리팩터링을 정의할 때 겉보기 동작이라는 표현을 사용했는데, 이는 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻이다.

그렇다고 완전하게 똑같다는 말은 아니고 콜스택이나 동작 방식, 세부 사항이 변경되어도 목적하는 동작은 똑같이 수행되어야 한다는 뜻이다.

리팩터링은 성능 최적화와 비슷하게 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다.

단지 목적이 다를 뿐으로 리팩터링은 성능이 좋아질 수도 있고 나빠질 수도 있다.

### 2.2 두 개의 모자

소프트웨어 개발을 할 때 목적이 기능 추가냐 아니면 리팩터링이냐를 명확하게 구분해야 한다.

이를 `켄트 벡`은 **두 개의 모자**에 비유 했다.  

기능을 추가할 때는 기능 추가 모자를 쓴 다음 기존 코드는 건드리지 않고 새 기능을 추가하기만 한다.

반면, 리팩터링 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

*테스트도 새로 만들지 않는다.*

두 모자 모두 테스트는 필수적이다..!

소프트웨어개발을 하는동안 대부분의 프로그래머는 두 모자를 동시에 쓰고 있다.

두 모자는 한번에 존재할 수 없으니 잠깐 내려놓고 한 가지 모자만 선택해야 한다.

### 2.3 리팩터링하는 이유

리팩터링은 소프트웨어의 모든 문제점을 해결하는 만병통치약이 아니다.

하지만 코드를 건강하게 유지하도록 도와주는 약임은 분명하다.

#### 리팩터링하면 소프트웨어 설계가 좋아진다

리팩터링을 무시할 경우 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다.

아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.

*과거에 말한 역 피라미드 구조*

정말 극단적인 경우지만 게임의 경우에는 설계부터가 잘못된 경우는 다시 만드는 게 더 빠를 정도로 엉키고 망가져 있다면.. 악순환이 반복되는 것

반면, 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. (예로 1챕터에서 다룬 분기문을 메서드내에서 처리할 경우 조건이 많아질 수록 코드 수정이 어려워짐)

그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다.

코드량을 줄인다고 시스템이 빨라지는 것은 아니다.. 하지만 코드를 수정하는데 드는 노력은 크게 달라진다.

비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 동작하지 않을 수 있다.

반면, 중복 코드를 제거하면 **모든 코드가 언제나 고유한 일을 수행함을 보장**할 수 있으며, 이는 바람직한 설계의 핵심이다.

#### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

컴퓨터는 거짓말을 하지 않는다.

그래서 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다.

프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.

좋은 코드, 나쁜 코드의 책에서 코드는 다른 사람이 봐도 한번에 이해가 되도록 작성해야 한다.

여기서 다른 사람은 1달 뒤, 1년 뒤 자신도 포함하는 말이다.

스스로 1달동안 건들지 않은 유물코드를 보게 되면 왜 이렇게 짰는지도 못알아 보는 경우가 많다.

물론 소프트웨어 개발자는 프로그램의 동작에 신경을 써야하지만, 그 코드를 자신도 이해 못하고 허둥지둥하는 모습을 보인다면 분명히 몇 달 뒤에는 자신도 해당 코드를 수정하지 못할 것이다.

즉, 궁극적인 목표는 프로그램의 최적화가 아닌 자신 그리고 남이 해당 코드를 보고 바로 이해할 수 있도록 리팩터링하는 것

#### 리팩터링하면 버그를 쉽게 찾을 수 있다

리팩터링하면 코드가 하는 일을 깊이 파악할 수 있게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.

프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도로 명확해진다.

> 난 뛰어난 프로그래머가 아니에요, 단지 뛰어난 습관을 지닌 프로그래머일 뿐이에요

#### 리팩터링하면 프로그래밍의 속도를 높일 수 있다

지금까지 제시한 장점을 한 마디로 요약하면 리팩터링하면 코드 개발 속도를 높일 수 있다.

그 반대라고 생각할 수 있지만, 리팩터링을 통해 품질을 높일 수 있다는 점은 결국 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다.

품질 향상은 결국 뒤로 가게되면 속도 자체에 영향을 크게 주게 된다.

사실 다들 알고 있지만 간과하거나 무시하는 부분이기는 하다.

잘 개발되었다면 새로운 시스템을 도입할 때 전혀 문제가 없어야 하지만 초기 개발 속도보다 느려진다면 아슬아슬한 모형탑을 쌓고 있음을 직감해야 한다.

**즉, 가장 느린 길이 가장 빠른 길이다.**

### 2.4 언제 리팩터링해야 할까?

저자는 프로그래밍할 때 거의 한 시간 간격으로 리팩터링을 한다.

#### 3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 발생), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

**리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.**

구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

> 비유하면 지금 위치에서 동쪽으로 100km를 이동하려는데 그 사이를 숲이 가로막고 있다면, 좀 둘러가더라도 20km 북쪽에 있는 고속도로를 타는 편이 세 배나 빠를 수 있다..  
> 다들 "직진!"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 길을 찾아보자"고 말할 줄 알아야 한다.  
> 준비를 위한 리팩터링이 바로 이런 역항을 한다.

버그를 잡을 때도 마찬가지로 여기 저기 흩어져 있는 버그보다 한 곳에 합쳐져 있는 버그를 잡는 것이 훨씬 쉽다.

#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.  

그 코드를 작성한 사람은 자신일 수도 있고, 다른 사람일 수도 있다.

코드가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

이런 리팩터링 과정에서 선수 작업으로 무조건 테스트 코드는 작성되어 있어야 한다.

#### 쓰레기 줍기 리팩터링

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다.

이때, 약간의 타협점이 필요하다.

원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다.

좋은 방법은 간단한 수정은 바로바로 수정하고 시간이 좀 걸리는 일은 메모를 남겨놓고 이후에 처리한다.

이것이 **쓰레기 줍기 리팩터링**이다.

물론 수정하려면 몇 시간이나 걸리고 당장은 더 급한 일이 있을 수 있지만, 조금이나마 개선해두는 것이 좋다.

캠핑장 규칙처럼 조금씩 개선하다 보면 결국 문제를 해결할 수 있게 될 것이다.

리팩터링은 외부에 보이는 작업이 아니기 때문에 몇 달에 걸쳐 진행하더라도 코드가 깨지지 않는다.(테스트만 완벽하다면..)

#### 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 리팩터링 방법은 모두 기회가 될 때만 진행하고 개발에 들어가기 전 일정을 따로 잡지 않고 리팩터링을 진행한다.

기능을 추가하거나 버그를 잡을 때도 함께 한다.

> 보기 싫은 코드를 발견하면 리팩터링하자.  
> 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

리팩터링을 과거에 저지를 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해할 수 있다.

보기 싫은 코드는 리팩터링해야 함이 당연하지만, 잘 작성된 코드 또한 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자

오랫동안 사람들은 소프트웨어 개발이란 뭔가 '추가'하는 과정으로 여겼다.

하지만 뛰어난 개발자들은 새 기능을 추가하기 쉽도록 코드를 수정하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.

소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다.

새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다.

```
생각

이런 리팩터링은 게임의 스킬과 같이 동작하며 갈고 닦을 수록 더욱 강해지는 도구이자 기술이다.

다른 언어와 개발 툴도 마찬가지라고 생각하며 가장 중요한 것은 마음가짐과 꾸준함정도라고 생각한다.
```

#### 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분 안에 끝난다.

길어야 몇 시간 정도이지만, 간혹 팀 전체가 달라붙어 몇 주가 걸리는 리팩터링도 있다.

라이브러리를 교체하는 작업일 수도 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼는 작업일 수 있다.

또는 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다.

이런 상황에서 팀 전체가 매달리는 리팩터링 보단 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.

누구든지 리팩터링해야할 코드와 관련된 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다.

#### 코드 리뷰에 리팩터링 활용하기

코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다.

경험이 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있따.

이 외에도 코드 리뷰는 이점이 다양하다.

리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 된다.

리팩터링을 활용하기 전에는 코드를 읽고, 그럭저럭 이해한 뒤, 몇 가지 개선 사항을 제시했다.

지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해 넣을 수 있는지부터 살펴본다.(쉽다면 리팩터링한다.)

이 과정을 몇 번 반복하면 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다.

머리로만 상상하는 것이 아니라 눈으로 직접 확인하는 것이다.

그러다 보면 리팩터링해보지 않고는 절대 떠올릴 수 없던 한 차원 높은 아이디어가 떠오르기도 한다.

가장 추천하는 리팩터링 코드 리뷰 방식은 짝 프로그래밍이다.

```
생각

과거 42서울에서 짝 프로그래밍을 경험해본적이 있는데 같은 코드라도 생각이 전혀 달라서 신기했던 경험이 있다.

지금 이 책으로 진행중인 북 클럽도 짝 프로그래밍의 일종이라고 생각한다.

각자 책을 읽고 느낀점과 생각을 토론하는 과정에서 내가 생각하지 못한 인사이트를 얻기 때문이다.
```

#### 관리자에게는 뭐라고 말해야 할까?

게임으로 따지자면... 기획자, pm, 디렉터에게 뭐라고 해야할까?

기획자는 눈에 보이는 작업을 원하지만, 리팩터링은 전혀 눈에 보이지 않기 때문에 기획자입장에선 이해하기 어렵다.

몇 주를 잡고 리팩터링을 진행하다가 틀어져서 좀 더 시간이 필요하지만 프로젝트 마일스톤이 다가오면서 급하게 작업하다 보면 결국 **어설픈 재구성**에 빠지고 코드 베이스 전체에 악 영향을 미친다.

소프트웨어 개발자는 효과적인 소프트웨어를 빠르게 만들어 내는 것이다.

경험상 리팩터링하면 소프트웨어를 빠르게 만드는데 아주 효과적이다.

하지만 왜 하지 않을까??

역사가 증명하듯 이 질문에 대한 답은 그냥 "하지 않아서"이다.

> 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.

#### 리팩터링하지 말아야 할 때

리팩터링도 하지 말아야 할 때가 있다.

외부 API의 경우 지저분한 코드를 볼 수 있는데 이는 내부 동작을 이해하는 시점에서야 리팩터링 효과를 제대로 볼 수 있다.

리팩터링을 하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.  

~~경험해본적이 있다..~~

### 2.5 리팩터링 시 고려할 문제

특정한 기술, 도구, 아키텍처등이 등장할 때 마다 우리는 비판적인 시각으로 바라봐야 한다.

*유니티를 사용중이라면 새로운 엔진과 장점,단점을 파악하고 이해해야 한다.*

똑같이 리팩터링도 하나의 기법이기 때문에 이에 딸려오는 트레이트 오프는 당연하다.

#### 새 기능 개발 속도 저하

리팩터링이 개발 속도를 저하시킨다고 하지만, 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다.

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

기능 개발과 당장 눈 앞에 보이는 리팩터링에서 균형을 잘 잡아야 한다.

저자는 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다.

그래서 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다.

**리팩터링을 더 자주 하도록 노력해야 한다.**

건강한 코드의 위력을 충분히 경험해보지 않고서는 코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다.

코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.

가장 위함한 오류는 리팩터링을 `클린 코드`나 `바람직한 엔지니어링 습관`처럼 도덕적인 이유로 정당화하는 것이다.

리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다.(부가적으로 따라오는 것)

오로지 경제적인 이유로 하는 것이다.

![image](https://github.com/fkdl0048/Algorithm/assets/84510455/b1e754f2-28ec-4757-aba0-d13e42c8f4b2)

#### 코드 소유권

리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다.

함수의 이름을 바꾸고 싶고 그 함수를 호출하는 곳을 모두 찾을 수 있다면, 간단히 **함수 선언 바꾸기**를 통해 변경할 수 있다.

함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있다.

또는 바꾸려는 함수가 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지를 고사하고, 실제로 쓰이기나 하는지조차 모를 수 있다.

이런 함수는 인터페이스를 누가 선언했는지에 관계없이 클라이언트가 사용하는 `공개된 인터페이스`에 속한다.

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.

클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다.

이 상황에서 개선을 하기 위해선 약간의 제약이 따르게 된다.

함수 이름을 바꾸기 위해선 기존 함수는 그대로 유지하되 본문에서 새로운 함수를 호출하도록 변경하거나 기존함수를 래퍼로 감싸서 처리할 수 있다.

이처럼 복잡해지기 때문에 코드 소유권을 세분화하여 철저하게 나누는 것에는 그만큼 비용이 따른다.

#### 브랜치

흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느정도 쌓이면 마스터 브랜치에 통합해서 공유하는 것이다.

기능별로 브랜치를 두고 작업을 하다보면 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다.

따라서 수시로 merge하거나 rebase하는데 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다.

따라서 단방향 병합과 양방향 통합을 구분하여 작업하는 것이 좋다.

지속적 통합(CI)에 따라 하루에 최소 한 번은 마스터와 통합하여 머지의 복잡도를 낮출 수 있다.

궁극적으로 리팩터링과의 궁합도 매우 뛰어나다.

리팩터링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있다.

프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우가 이러한 예이다.

해당 경우 머지 과정에서 충돌이 생기기 쉽고 특히 기능별 브랜치 방식에서는 리팩터링을 도저히 진행할 수 없을 정도로 심각한 머지 문제가 발생하기 쉽다.

CI와 리팩터링을 합쳐 익스트림 프로그래밍(XP)라고 부른다.

#### 테스팅

리팩터링을 하기 위해선 자가 테스트 코드가 필요하다.

리팩터링에 관한 유용한 이유, 테스트 코드가 필요한 이유를 수도 없이 말하지만, 왜 실천하지 못하는 걸까?

저자 또한 테스트 코드의 유용성, 실제 사용 사례를 보여주며 효과에 대하 말하지만 쉽게 실천하지 못하는 이유는 객체지향에 대한 이해 부족도 한 원인이라고 본다.

많은 고전 개발책이나 뛰어난 프로젝트에서도 볼 수 있지만 실제 공부하는 학생 레벨의 코드에서는 테스트 코드를 보기 힘들다.

안해봐서 그렇고 몰랐기 때문이라고 생각한다.

#### 레거시 코드

사람들은 물려 받는 것을 좋아하지만, 코드는 그렇지 않다.

레거시 코드는 대체로 복잡하고 제대로 갖춰지지 않은 것이 많다.

*하지만 그 당시에 최선을 다한 코드이기 때문에 함부로 욕해선 안된다.*

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다.(단련하기에..)

이 문제의 정답 또한 테스트 코드이다.

테스트를 보강하고 레거시의 시스템을 파악하여 리팩터링을 진행한다.

하지만 테스트가 있다고 해서 레거시 코드가 한번에 깨끗해지는 것은 아니며, 그런 낙관적인 시선도 좋지 못하다.

앞서 말한 캠핑장 규칙과 같이 조금씩 꾸준하게 리팩터링을 진행해야 한다.

#### 데이터베이스

리팩터링 1판에서는 데이터베이스는 리팩터링하기 까다롭다고 했었는데 2판이 출시되고 진화형 데이터베이스 설계, 데이터베이스 리팩터링기법이 등장하며 어렵지 않게 바뀌었다.

다른 리팩터링과 마찬가지로 이 기법도 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.

그래야 마이그레이션 후에도 정상 작동할 수 있다.

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.

### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

과거에는 코드를 작성한 뒤에는 아키텍처를 변경할 수 없다는 인식이 지배적이였는데, 리팩터링은 이런 관점을 크게 바꿔놓았다.

이 책의 부제처럼 리팩터링으로 기존 코드의 설계를 개선할 수 있다.  

하지만 앞서 말한 레거시 코드는 변경하기 어려울 때가 많기 때문에 탄탄한 테스트 코드가 뒷받침해줘야 한다.

리팩터링이 아키텍처에 미치는 실질적인 효과는 **요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계**해준다는 데 있다.

코딩 전에 아키텍처를 확정지으려 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다.

하지만 막상 해보면 실현할 수 없는 목표일 때가 많다..

**우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.**

한 가지 방법으로 유연성 메커니즘을 소프트웨어에 심어두는 것이다.

가령 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있다.

Mathf나 다른 라이브러리와 같이 사용자가 사용할 함수를 미리 오버로딩, 선택적 매개변수 등을 통해 범용성을 늘리는 방법도 있지만, 다른 책에서 말하듯이 오용될 수 있는 부분은 제한하는 것이 좋다.

필요에 의해서만 만들어야 하고 모든 경우의 수를 생각해 만들면 캡슐화의 의미 자체가 변질된다.

리팩터링을 활용하면 다르게 접근할 수 있다.

유연성에 대응되는 부분을 생각하지 않고 현재까지 파악된 요구사항만을 해결하는 소프트웨어를 구축한다.

진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.

이런 식으로 설계하는 방식을 간결한 설계, 점직적 설계, YAGNI(You Aren't Gonna Need It)라고 한다.

문자 그대로 적용할 때도 있지만, 아키텍처를 전혀 고려하지 말라는 뜻은 아니다.

이를 받아들인다고 해서 아키텍처를 완전히 소홀해도 된다는 뜻은 아니다.

리팩터링으로는 변경하기 어려워서 미리 생각해두면 시간이 절약되는 경우도 얼마든지 있다.

### 2.7 리팩터링과 소프트웨어 개발 프로세스

XP, TDD와 같이 애자일의 원칙을 따르는 개발 방법론들이 있다.

```
생각  
나는 개발을 진행할 때 애자일 비스무리하게 따라가는 편인데, 하루의 Todo를 정하고 해당 일정에 맞춰 움직인다.

점직적으로 스케줄을 늘려나가며 나의 가용시간을 판단하기도 하는데.. 이런 방식이 애자일과 비슷한 것 같다.
```

리팩터링의 첫 번째 토대는 자가 테스트 코드이다. (매우 매우 중요..)

팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링을 할 수 있어야 한다.

*지속적 통합을 강조하는 이유도 이 때문이다.*

이러한 순환 구조? 핵심 실천법을 갖췄다면 애자일의 다른 요소가 주는 이점까지 취할 수 있는 토대를 마련한 셈이다.

### 2.8 리팩터링과 성능

직관적인 설계 vs 성능은 중요한 주제는 다양한 의견이 있지만 앞서 말한 것과 같이 리팩터링을 하면 느려질 수 있는 것은 사실이나 그와 동시에 성능을 튜닝하기는 더 쉬워진다.

#### 빠른 소프트웨어를 작성하는 방법 세 가지

첫 번째는 예산 분배방식으로, 하드 리얼타임 시스템에서 많이 사용한다.

이 방식에 따르면 설계를 여러 컴포넌트로 나눠서 컴포넌트 마다 자원 예산을 할당한다.(초과할 수 없다.)

두 번째는 끊임없이 관심을 기울이는 것이다.

프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다.

직관적이어서 흔히 사용하는 방식이지만 실제 효과는 변변치 않다.

성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌진다.

> 아무것도 안 만드는 데도 시간이 걸린다.  
> 이 이야기의 교훈은 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다.  
> 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

### 2.9 리팩터링의 유래

리팩터링의 유래에 관한 이야기이다.

리팩터링이 어떻게 이 업계에 주류 개발 기법을 남게 되었는지

### 2.10 리팩터링 자동화

지금 내가 사용중인 IDE Rider역시 리팩터링을 지원한다.

메서드 이름을 변경하거나 문제가 되는 부분을 지적해주며 좀 더 좋은 구조로 변경할 수 있도록 도와준다.

자동화가 되었음에도 꼭 테스트는 해볼 것.

또한 자동화로는 따라 갈 수 없는 구조적인 리팩터링은 직접 해야 한다.

### 2.11 더 알고 싶다면

### 느낀점

클린코드도 그렇고, 좋은 코드 나쁜 코드, 객체지향 책 등등 모든 책에서 테스트 코드의 중요성을 매우 많이 언급한다.

아직도 배우고 있는 단계이지만 테스트 코드는 짜면 짤 수록 경험이 정말 중요하다는 것을 알게 되기도 하고 리팩터링이라는 과정을 따로 시간을 할애하는 것이 아닌 의식적으로 행해야 함을 배운 것 같다.

이번 장은 대체적으로 리팩터링에 대한 개념?(해야하는 이유, 방법, 효과 등등)에 대해 다뤘는데 기억에 남는 부분은 **두 개의 모자** 부분..

#### 논의사항

따로 기획자분이나 PM에게 리팩터링을 해야함을 설명하여 시간을 할애할 때 어떤 식으로 말을 하실지 궁금합니다!
