## 10. 조건부 로직 간소화

조건부 로직은 프로그램의 힘을 강화하는 데 크게 기여하지만, 반대로 프로그램을 복잡하게 만드는 주요 원흉이기도 하다.

### 10.1 조건문 분해하기

```csharp
if (date.before(SUMMER_START) || date.after(SUMMER_END))
    charge = quantity * winterRate + winterServiceCharge;
else 
    charge = quantity * summerRate;
```

```csharp
if (Summer())
    charge = winterCharge();
else 
    charge = summerCharge();
```

#### 배경

다양한 조건, 그에 따라 동작도 다양한 코드를 작성하면 순식간에 꽤 긴 함수가 탄생한다.

긴 함수는 그 자체로 읽기가 어렵지만, 조건문은 그 어려움을 한층 가중시킨다.

조건을 검사하고 그 결과에 따른 동작을 표현한 코드는 무슨 일이 일어나는지는 이야기해주지만 `왜` 일어나는지는 제대로 말해주지 않을 때가 많은 것이 문제다.

거대한 코드 블록이 주어지면 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수 호출로 바꿔주자.

그러면 전체적인 의도가 더 확실히 드러난다.

#### 절차

- 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출한다.

### 10.2 조건식 통합하기

```csharp
if (anEmployee.seniority < 2) return 0;
if (anEmployee.monthsDisabled > 12) return 0;
if (anEmployee.isPartTime) return 0;
```

```csharp
if (isNotEligibleForDisability()) return 0;

function isNotEligibleForDisability() {
    return ((anEmployee.seniority < 2)
        || (anEmployee.monthsDisabled > 12)
        || (anEmployee.isPartTime));
}
```

#### 배경

비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 더러 있는데, 어차피 같은 일을 할 거라면 조건 검사도 하나로 통합하는게 낫다.

이럴 때 `and` 연산자나 `or` 연산자를 사용하면 여러 개의 비교 로직을 하나로 합칠 수 있다.

조건부 코드를 통합하는 게 중요한 이유는 두 가지다.

첫째, 여러 조각으로 나뉜 조건들을 하나로 통합함으로써 내가 하려는 일이 더 명확해진다.

나눠서 순서대로 비교해도 결과는 같지만, 읽는 사람은 독립된 검사들이 우연히 함께 나열된 것으로 오해할 수 있다.

두 번째 이유는 이 작업이 함수 추출하기까지 이어질 가능성이 높기 때문이다.

복잡한 조건식을 함수로 추출하면 코드의 의도가 훨씬 분명하게 드러나는 경우가 많다.

함수 추출하기는 `무엇`을 하는지를 기술하던 코드를 `왜`하는지를 말해주는 코드로 바꿔주는 효과적인 도구임을 기억하자.

#### 절차

- 해당 조건식들 모두에 부수효과가 없는지 확인한다.
- 조건문 두 개를 선택하여 두 조건문의 조건식을 논리 연산자로 결합한다.
- 테스트한다.
- 조건이 하나만 남을 때까지 과정을 반복한다.
- 하나로 합쳐진 조건식을 함수로 추출할지 고려해본다.

### 10.3 중첩 조건문을 보호 구문으로 바꾸기

```csharp
public int GetPayAmount() {
    int result;
    if (isDead) result = deadAmount();
    else {
        if (isSeparated) result = separatedAmount();
        else {
            if (isRetired) result = retiredAmount();
            else result = normalPayAmount();
        }
    }
    return result;
}
```

```csharp
public int GetPayAmount() {
    if (isDead) return deadAmount();
    if (isSeparated) return separatedAmount();
    if (isRetired) return retiredAmount();
    return normalPayAmount();
}
```

#### 배경

조건문은 주로 두가지 형태로 쓰인다.

참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태, 한쪽만 정상인 형태다.

두 형태는 의도하는 바가 서로 다르므로 그 의도가 코드에 드러나야 한다.

두 경로 모두 정상 동작이라면 if와 else절을 사용한다.

한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음, 조건이 참(비정상이면) 함수에서 빠져나온다.

두 번째 검사 형태를 흔히 보호 구문이라고 한다.

중첩 조건문을 보호 구문으로 바꾸기 리팩터링의 핵심은 의도를 부각하는 데 있다.

#### 절차

- 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꾼다.
- 테스트한다.
- 위 과정을 필요한 만큼 반복한다.
- 모든 보호 구문이 같은 결과를 반환한다면 보호 구문들의 조건식을 통합한다.

### 10.4 조건부 로직을 다형성으로 바꾸기

```csharp
switch (bird.Type) {
    case '유럽제비':
        return "보통이다"
    case '아프리카 제비':
        return (bird.NumberOfCoconuts > 2) ? "지쳤다" : "보통이다";
    case '노르웨이 파랑 앵무':
        return (bird.Voltage > 100) ? "그을렸다" : "예쁘다";
    default:
        return "알 수 없다";
}
```

```csharp
class EuropeanSwallow {
    GetPlumb() {
        return "보통이다";
    }
}

...

class NorwegianBlueParrot {
    GetPlumb() {
        return (bird.Voltage > 100) ? "그을렸다" : "예쁘다";
    }
}

...

class AfricanSwallow {
    GetPlumb() {
        return (bird.NumberOfCoconuts > 2) ? "지쳤다" : "보통이다";
    }
}
```

#### 배경

복잡한 조건부 로직은 프로그래밍에서 해석하기 가장 난해한 대상에 속한다.

종종 더 높은 수준의 개념을 도입하여 이 조건들을 분리해낼 수 있다.

조건문 구조를 그대로 둔 채 해결될 때도 있지만, 클래스와 다형성을 이용하면 더 확실하게 분리할 수도 있다.

흔한 예로, 타입을 여러 개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 처리하도록 구성하는 방법이 있다.

switch문을 구성해 case별로 클래스를 각각 만들어 공통된 로직으로 만들어 중복을 없앨 수 있다.

또 다른 예로, 기본 동작을 위한 case문과 그 변형 동작으로 구성된 로직을 떠올릴 수 있다.

기본 동작은 가장 일반적이거나 가장 직관적인 동작일 것이다.

먼저 이 로직을 슈퍼클래스로 넣어서 변형 동작에 신경 쓰지 않고 기본에 집중하게 한다.

그런 다음 변형 동작을 뜻하는 case들을 각각의 서브클래스로 만든다.

이 서브클래스들은 기본 동작과의 차이를 표현하는 코드로 채워질 것이다.

**다형성은 객체 지향 프로그래밍의 핵심이다.**

하지만 (유용한 기능들이 늘 그렇듯) 남용하기 쉽다. 실제로 모든 조건부 로직을 다형성으로 대체해야 한다고 주장하는 사람도 있지만, 그 견해에 동의하지 않는다..

조건부 로직 대부분의 기본문인 if, else, switch는 기본 도구로 이뤄지기 때문이다.

물론 앞서 이야기 한 방법대로 복잡한 조건부 로직을 발견한다면 다형성이 얼마나 막강한 도구인지 알게 될 수 있다.

*개인적인 의견도 동의한다. 유용한 도구이긴 하지만 남발해선 안된다. 오히려 거버넌스나 엔트로피가 증가해 보기에 안좋을 수 있음*

#### 절차

- 다형적 동작을 표현하는 클래스들이 아직 없다면 만들어준다. 이왕이면 적합한 인스턴스를 알아서 만들어 반환하는 팩터리 함수도 함께 만든다.
- 호출하는 코드에서 팩터리 함수를 사용하게 한다.
- 조건부 로직 함수를 슈퍼클래스로 옮긴다.
- 서브클래스 중 하나를 선택한다. 서브클래스에서 슈퍼클래스의 조건부 로직 메서드를 오버라이드한다. 조건부 문장 중 선택된 서브 클래스에 해당하는 조건절을 서브클래스 메서드로 복사한 다음 적절히 수정한다.
- 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다.
- 슈퍼클래스 메서드에는 기본 동작 부분만 남긴다. 혹은 슈퍼클래스가 추상 클래스여야 한다면, 이 메서드를 추상으로 선언하거나 서브 클래스로 처리해야 함을 알리는 에러를 던진다.

### 10.5 특이 케이스 추가하기

```csharp
if (customer == "미확인 고객") customerName = "거주자";
```

```csharp
class UnknownCustomer {
    public string GetName {
        return "거주자";
    }
}
```

#### 배경

데이터 구조의 특정 값을 확인한 후 똑같은 동작을 수행하는 코드가 곳곳에 등장하는 경우가 더러 있는데, 흔히 볼 수 있는 중복 코드 중 하나다.

이처럼 코드베이스에서 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이라면 그 반응들을 한 데로 모으는 게 효율적이다.

특수한 경우의 공통 동작을 요소 하나에 모아서 사용하는 특이 케이스 패턴이라는 것이 있는데, 바로 이럴 때 적용하면 좋은 메커니즘이다.

이 패턴을 활용하면 특이 케이스를 확인하는 코드 대부분을 단순한 함수 호출로 바꿀 수 있다.

널은 특이 케이스로 처리해야할 때가 만다. 그래서 이 패턴을 **넉 객체 패턴**이라고도 한다.

과거 널 객체 패턴에 대한 정리를 한적이 있어서 해당 글을 첨부한다.

[널 객체 패턴](https://fkdl0048.github.io/patterns/Patterns_NullObject/)

하지만 널 외의 다른 특이 케이스에도 같은 패턴을 적용할 수 있으니, 널 객체가 특이 케이스의 특수한 예라고 보는 것이 맞다.

#### 절차

- 컨테이너에 특이 케이스인지를 검사하는 속성을 추가하고, false를 반환하게 한다.
- 특이 케이스 객체를 만든다. 이 객체는 특이 케이스인지를 검사하는 속성만 포함하며, 이 속성은 true를 반환하게 한다.
- 클라이언트에서 특이 케이스인지를 검사하는 코드를 함수로 추출한다. 모든 클라이언트가 값을 직접 비교하는 대신 방금 추출한 함수를 사용하도록 고친다.
- 코드에 새로운 특이 케이스 대상을 추가한다. 함수의 반환 값으로 받거나 변환 함수를 적용하면 된다.
- 특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용하도록 한다.
- 테스트한다.
- 여러 함수를 클래스로 묶기나 여러 함수를 변환 함수로 묶기를 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다.
- 아직도 특이 케이스 검사를 이용하는 곳이 남아 있다면 검사 함수를 인라인 한다.

### 10.6 어서션 추가하기

```csharp
if (this.discountRate) {
    basePrice -= basePrice * this.discountRate;
}
```

```csharp
Assert.IsTrue(this.discountRate >= 0);
if (this.discountRate) {
    basePrice -= basePrice * this.discountRate;
}
```

#### 배경

특정 조건이 참일 때만 제대로 동작하는 코드 영역이 있을 수 있다.

단순한 예로, 제곱근 계산은 입력이 양수일 때만 정상 동작한다.

객체로 눈을 돌리면 여러 필드 중 최소 하나에는 값이 들어 있어야 동작하는 경우를 생각할 수 있다.

이런 가정이 코드에 항상 명시적으로 기술되어 있지는 않아서 알고리즘을 보고 연역해서 알아내야 할 때도 있다.

좋은 방법으로 어서션을 이용해서 코드 자체에 삽입해놓는 것이다.

어서션은 항상 참이라고 가정하는 조건부 문장으로, 어서션에 실패했다는 건 프로그래머가 잘못했다는 뜻이다.

#### 절차

- 참이라고 가정하는 조건이 보이면 그 조건을 명시하는 어서션을 추가한다.

### 10.7 제어 플래그를 탈출문으로 바꾸기

```csharp
foreach (var p in people) {
    if (!found) {
        if (p == "조커") {
            SendAlert();
            found = true;
        }
    }
}
```

```csharp
foreach (var p in people) {
    if (p == "조커") {
        SendAlert();
        break;
    }
}
```

#### 배경

제어 플래그란 코드의 동작을 변경하는 데 사용되는 변수를 말하며, 어딘가에서 값을 계산해 제어 플래그에 설정한 후 다른 어딘가의 조건문에서 검사하는 형태로 쓰인다.

플래그 자체는 코드 악취로 볼 수 있다.

리팩터링으로 충분히 간소화가 가능할 수 있음에도 복잡하게 작성된 코드에서 흔히 나타나기 때문이다.

제어 플래그의 주 서식지는 반복문 안이다.

break문이나 continue문 활용에 익숙하지 않은 사람이 심어놓기도 하고 함수의 return을 하나로 유지하고자 노력하는 사람이 심기도 한다.

#### 절차

- 제어 플래그를 사용하는 코드를 함수로 추출할지 고려한다.
- 제어 플래그를 갱신하는 코드를 각각을 적절한 제어문으로 바꾼다. 하나 바꿀 때마다 테스트한다.
- 모두 수정했다면 제어 플래그를 제거한다.

### 느낀점

이번 장이 제일 얻어가는게 많은 장이라고 생각된다.

객체지향의 적인 부분과 기본 조건식에서 자주 나오게 되는 문제점을 배경을 통해 알 수 있었다.

#### 논의사항

- x
