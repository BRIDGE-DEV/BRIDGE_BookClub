드디어 엔진 내용이 나온다. 심지어 그마저도 개론적인 내용이라 직접 연구하고 찾아보지 않으면 딱히 배우는 게 없다는 생각이 들어 직접 파보기로 했다.

# 5.2.2 API 해결.
C의 헤더 파일의 교과서적인 사용 예시라고 생각이 든다. header file은 인터페이스만 제공하고, 실제 동작은 어떤 object file을 링크하느냐에 따라서 달라진다. 이게 바로 .c, .h가 나누어진 이유면서 동시에 컴파일, 링크 단계가 나눠져 있는 이유이다. 

기본적으로 .h 파일에 들어있는 녀석들은 oop의 public member랑 같은 역할을 한다고 볼 수 있다. 그런데 c++에서는 클래스를 새로 만드는 바람에 .h파일의 존재 자체가 다소 무색해진 면이 있다고 본다. 결국 활용이 c랑은 완전 딴판으로 가 버렸다. 단순히 선행 정의(foward declaration)를 만족하기 위한 수준으로 전락해 버린 것 같다는 생각이다. 이를 해결하기 위해서 c++20에 모듈이 괜히 나온건 아닌 것 같다.
지금 하고 있는 컴파일러 프로젝트에 여러 아키텍쳐, 여러 object 파일 포맷을 지원할 때 써먹기 좋다고 생각이 든다.

지금 깃헙에 올라온 버젼을 맥으로 포팅하는 것을 해 봐야겠다는 생각도 들었다.

# 5.4 고정 시간 단계(fixed time step)

1초에 35틱.

# 5.6 고정 소수점 산술

msb를 sf(sign flag)로 사용하고, 비트 15~0까지를 소수 부분을 표시하는데 사용했다.
alu가 그냥 다른 연산 하듯이 그냥 하면 된다는 점이 굉장히 흥미로웠다.

소수 부분의 msb부터 1이 채워진다.
1   ->  .5

01  ->  .25
11  ->  .75

001 ->  .125
011 ->  .375
111 ->  .875

간단하고 아름다운 고정 소수점 구현이 아닌가 싶다.
overflow에 취약한 점, 그것이 단점으로 지적되었다.

# 5.7 memory manager

일단 리눅스둠의 경우는 6 * 1024 * 1024, 즉 6MiB를 할당했다. 그 부분은 책에서 말한 넥스트둠의 4MiB랑은 달랐다.

사실 직접 구현한 이 'zone allocator'는 좀 깊게 들여다볼 가치가 있는 것 같아서 코드를 따라 입력해 보면서 깊게 들여다봤다.

### 스타일에 관하여

우선 97년도 코드이기 때문에 c99도 아니고 ansi c로 작성되었다.
변수의 선언이 스코프의 맨 앞에 몰아놔야 했던 제약이 c99에 와서야 사라졌기 때문에 그렇게 돼 있음을 확인할 수 있다.

```c
void*
Z_Malloc
( int		size,
  int		tag,
  void*		user )
```
진짜 옛날식의 함수 시그니처이다. 파라미터가 원래 스코프의 '{' 전에 선언되어야 했던 시절이 있는데, 그때의 관습이 여전히 남아있는 과도기적이 코드다. 이 때문에 현대적으로 코드를 좀 다시 포매팅할 필요가 있다고 생각되어서 정리하면서 코드를 확인하였다.

## Z_Init

우선 책에 나온대로 엔트리 포인트에서 호출되는 부분이다. 우선 여기 코드에서 중요한 것이 memblock_t와 memzone_t라는 두 struct이다.

memzone_t는 해당 파일에 mainzone으로 하나 존재한다. mainzone은 헤더 파일에 들어가지 않았다.

```c
    int size;
    mainzone = (memzone_t *)I_ZoneBase(&size);
```

I_ZoneBase로 훌륭히 인터페이스화된 함수로 운영체제에 메모리 할당을 요구한다. 그리고 *mainzone이 가리키게 한다.
할당된 메모리의 맨 앞에 memzone_t struct가 위치하고, 바로 뒤에 이어서 memblock_t 하나를 생성하는 식이다. memzone_t 안에도 memblock_t가 하나 들어있는데, 여기가 doubly linked list의 head이다. 책에서는 이 head 부분을 의도적으로 생략한 것 같긴 한데, 정확히는 다음과 같은 모습이다.


```
//  (next)  <->
//  mainzone    first_block
//  (prev)  <-> ^
//              rover
```

mainzone, first_block이 서로를 next, prev으로 가리키고 있으며, rover는 첫 번째 블록을 가리키고 있다. 이렇게 초기화가 끝난다.

## Z_Malloc

맨 처음부터 신기하게 생긴 코드가 하나 있다.
```
    size = (size + 3) & ~3;
```
~3은 11의 1의 보수이고, 그것과 &를 하므로 lsb 2개를 0으로 만들겠다는 소리다.
동작은 아래 코드와 같다.
```
    ((size + 3) / 4) * 4
```
결국 해당 size를 4에 align시켜주는 역할을 한다.

Z_Malloc은 2단계로 이루어진다.

첫 번째는 rover로부터 시작해서 이중 연결 리스트를 순회한다. 사용 중이지 않으면서 동시에 size 큰 블럭을 찾아낸다.

사용 중이더라도 PU_PURGELEVEL, 즉 캐시거나 아무튼 막 지워도 된다고 태그에 쓰여있으면, 그 태그를 Z_Free 해버린다.

한 바퀴를 다 돌았다면 실패한다.


두 번째는 새 블럭을 만드는 것이다. 현재 블럭과 데이터를 지나 새 블럭을 만든다. 그리고 이중 연결 리스트를 업데이트한다. rover는 이제 새 블럭을 가리킨다.

근데 만약에 남은 블럭 크기가 0x40바이트보다 작다면 새 블럭을 만들지 않는다. 로버는 mainzone->blocklist를 다시 가리키게 된다.

이걸 버그 없이 깔끔하게 만들었다는게 사실 놀랍다. oop나 그 무슨 기술이 들어가지 않았다. 그저 컴퓨터 메모리를 원하는데로 조정하는 절차적인 코드일 뿐이다.

## Z_Free

여기는 사실 어렵지 않다. 다들 아는 방법으로 이중 연결 리스트를 해제하고, 만약 로버가 여기를 가리키고 있었다면 옮겨준다.
앞뒤로 블럭이 사용 중이 아니라면(user == NULL) 같이 합친다.

## 기타

id가 메모리 오버플로우를 막아준다는 말이 있다.
id는 매직넘버인 0x1D4A11의 값을 갖는데, 이 값이 다르다면 다른 무언가에 의해 버퍼 오버플로우가 일어났다는 것을 감지하기 위함인 것 같다. 소스에서는 d_net.c:569, Z_Free, Z_ChangeTag에서 체크한다. 근데 사실 해커가 코드를 충분히 파악만 했다면 해당 값은 그대로 매직 넘버로 남겨두면 알 수 없지 않을까 싶긴 한다.

https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries

일단 위 링크에서 여러 카나리들의 종류를 알려주는데, 저 중에서 어떻게 만들었는지는 잘 모르겠다..
double free를 막는 것은, user가 NULL이면 그냥 에러가 뜨게끔 해 뒀다. 근데 사실 그 메모리 페이지가 다른 프로세스와 공유되지 않는다는 점에서 보면 그렇게까지 대단한 기능은 아니지 않을까 싶다.
CheckHeap의 경우도 깔끔하고 간단히 구현돼 있다.

정말 배울점이 많은 malloc 구현이었다고 생각이 들었다.

이 당시에 게임 개발은 하나의 미니 os를 만드는 것과 같았다고 하는데, 정말 그렇다는 생각도 든다. 메모리 관리, 아래 lump와 같은 파일 시스템, 렌더링, io 등등...

요즘 os들은 어떨까..?
이걸 보고 macOS의 malloc을 살펴봤는데.. 간단히 보면 256바이트 이하는 nanov2_malloc이 호출된다. 이 알고리즘을 보아 현대 운영체제들은 둠 개발자들이 걱정한 작은 alloc에 의한 메모리 파편화가 덜 일어나지 않을까 싶다. 마지막으로 사용한 블럭 하나 안에서 최대한 나노 할당을 하려고 하는 듯 하다.
https://github.com/apple-open-source-mirror/libmalloc/blob/master/src/nanov2_malloc.c#L2506

역시 동시성/멀티프로세서 프로그래밍을 고려하지 않을 수 없다. 코드를 보면 락도 걸고 atomic load store가 보인다.

리눅스의 malloc은..

https://github.com/lewischeng-ms/linux/blob/master/lib/malloc.c

비교적 단순해 보이긴 한다. 하지만 여기도 깊게 파보면 분명 무언가 있을 것 같다. 신기한 점은 어셈블리어로 많은 부분이 짜여 있다는 것이었다. get_free_page()가 malloc의 핵심 부분인데, 관련 코드가 어셈블리다.

그만 알아보자..

# 5.8.1 덩어리 (lump)

union을 이용한 타입 변환과 그걸로 strcmp를 하는 방법이 소개됐다. 존 카맥이 이런 비트 핵을 정말 좋아하고 여러 번 사용한다는 생각이 든다. 사실 최근의 memcmp는 다 이런 방식으로 구현돼있기 때문에 굳이 이런 해킹이 현대에 필요하지는 않겠다.

전에도 스터디때 얘기를 했던 것 같은데, hashmap 대신에 그냥 배열 순회 방식으로 되어 있다. 존 카맥에 아마 그냥 이렇게 해도 충분히 빨랐기 때문이라고 했던 것 같다..

# 5.9 비디오 관리자

사실 게임 엔진에서 가장 중요한 부분이 아닐까.

(다만 책이 불친절하고 번역이 좀 읽기 쉽지 않게 된 부분이 있는 것 같다..)

5.


