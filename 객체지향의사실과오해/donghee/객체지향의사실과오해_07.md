# 7장 함께 모으기
## 정리

객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점을 개념 관점, 명세 관점, 구현 관점이라고 부른다.

- 개념 관점: 개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.
- 명세 관점: 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다. 명세 관점은 도메인의 개념이 아니라 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 이 관점에서 프로그래머는 객체가 협력을 위해 ‘무엇’을 할 수 있는가에 초점을 맞춘다.
- 구현 관점: 프로그래머인 우리에게 가장 익숙한 관점으로, 실제 작업을 수행하는 코드와 연관돼 있다. 프로그래머는 객체의 책임을 ‘어떻게’ 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

이 세 관점은 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다. 클래스는 세 가지 관점이라는 안경을 통해 설계와 관련된 다양한 측면을 드러낼 수 있다.

클래스가 은유하는 개념은 도메인 관점을 반영한다. 클래스의 공용 인터페이스는 명세 관점을 반영한다. 클래스의 속성과 메서드는 구현관점을 반영한다.

클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

아래부터는 커피 전문점과 관련된 예제로, 두 가지 목표를 달성한다.

1. 도메인 모델에서 시작해서 최종 코드까지의 구현 과정을 간력하게 설명한다.
2. 구현 클래스를 위의 세 가지 관점에서 바라본다는 것이 무엇을 의미하는지를 설명한다.

### 커피 전문점 도메인

**커피 주문**

예제의 목적은 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현하는 것이다.

**커피 전문점이라는 세상**

커피 전문점을 객체들로 구성된 작은 세상으로 바라보자.

- 메뉴판은 네 개의 메뉴 항목 개체를 포함하는 개체이다.
- 손님은 메뉴판을 보고 바리스타에게 원하는 커피를 주문하는 객체이다.
- 바리스타는 주문을 받은 메뉴에 따라 적절한 커피를 제조하는 객체이다.

종합하면, 커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성된 작은 세상이다.

메뉴 항목은 메뉴판에 포함되며, 이것은 **포함 관계** 또는 **합성 관계**를 의미한다.

손님 타입은 메뉴판 타입을 알고 있어야 원하는 커피를 선택한다. 합성 관계는 아니지만 서로 알고 있어야 하는 이런 경우를 **연관 관계**라고 한다.

바리스타 타입은 커피를 제조해야 하므로 커피 타입을 알고 있어야 한다.

위 정보들을 이용해 도메인을 단순화해서 표현한 모델인 도메인 모델을 구성할 수 있다.

실제로 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이고 어떤 관계가 연관 관계인지는 중요하지 않다. 초점은 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.

### 설계하고 구현하기

**커피를 주문하기 위한 협력 찾기**

객체지향 설계의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아니라 훌륭한 협력을 설계하는 것이다.

협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택해야 한다.

이 예제에서 첫 번째 메시지는 ‘커피를 주문하라’일 것이다. 메시지를 찾았으니 처리하기에 적합한 객체를 선택해야 한다.

메시지를 처리할 객체를 찾고 있다면 먼저 도메인 모델 안에 책임을 수행하기에 적절한 타입이 존재하는지 살펴보라. 적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들어라.

현실과 소프트웨어의 객체가 완전 동일할 수는 없겠지만 유사한 이름을 붙여놓으면, 유사성을 통해 소프트웨어 객체가 수행해야 하는 책임과 상태를 더 쉽게 유추할 수 있다.

여기서는 손님 객체에게 주문할 책임을 할당한다. 이제 손님이 커피를 주문하는 중에 스스로 할 수 없는 일을 생각해 본다. 손님은 메뉴 항목에 대해서는 알지 못한다. ‘메뉴 항목을 찾아라’라는 새로운 메시지의 등장이다.

메뉴 항목을 찾을 책임은 메뉴 항목 객체를 포함하는 메뉴판 객체에게 할당하는 것이 적절할 것이다. 이제 손님은 메뉴 항목을 얻었으니, 메뉴 항목에 맞는 커피를 제조해달라고 요청할 수 있다. 

손님은 커피를 제조하는 메시지의 인자로 메뉴 항목을 전달하고 반환값으로 제조된 커피를 받아야 한다. 바리스타는 커피를 제조하는 데 필요한 모든 정보를 알고 있다. 커피 주문을 위한 협력은 이제 바리스타가 새로운 커피를 만드는 것으로 끝난다.

이 예제에서 협력을 가시화하기 위해 UML을 이용한다. 그렇지만 UML은 의사소통을 위한 표기법이지 반드시 지켜야 하는 법칙이 아니다. 의사소통이라는 목적에 부합한다면 용도에 맞게 얼마든지 UML을 수정하고 뒤틀어라.

협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 대략적인 윤곽이 잡혔다. 남은 일은 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 것이다.

**인터페이스 정리하기**

객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것이다.

실제로 소프트웨어의 구현은 동적인 객체가 아닌 정적인 타입을 이용해 이뤄진다. 

협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부이다. 따라서 인터페이스에 포함된 오퍼레이션 역시 외부에서 접근 가능하도록 공용(public)으로 선언돼 있어야 한다.

- 손님: Customer 클래스. 주문 책임을 수행하는 order 메서드.
- 메뉴 항목: 메뉴판에 포함되는 MenuItem 클래스.
- 메뉴판: Menu 클래스.  메뉴 항목 선택 책임을 수행하는 choose 메서드.
- 바리스타: Barista 클래스. 커피 제조 책임을 수행하는 makeCoffee 메서드.
- 커피: Coffee 클래스. 메뉴라는 상태 보유.

**구현하기**

Customer는 Menu에게 MenuItem을 찾아달라고 요청하고, 이를 받아 Barista에게 원하는 커피를 제조해달라고 요청해야 한다.

문제는 Customer가 어떻게 Menu 객체와 Barista 객체에 접근할 것이냐다. 여기서는 order 메서드의 인자로 Menu 객체와 Barista 객체를 전달받는 방법을 이용한다.

이 결정으로 인터페이스의 구조가 구현 도중 변경된다. 이는 당연한 일이다.

협력을 구상하는 단계에서 너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 한다. 코드를 통한 피드백 없이는 깔끔한 설계를 얻을 수 없다.

인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다. 설계를 간단히 끝내고 빨리 구현에 도입하라.

설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코들르 작성해가면서 협력의 전체적인 밑그림을 그려라.

### 코드의 세 가지 관점

**코드는 세 가지 관점을 모두 제공해야 한다**

개념 관점에서 코드를 바라보면 Customer, Menu, MenuItem, Barista, Coffee 클래스가 보인다. 이 클래스들은 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다.

소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다.

명세 관점은 클래스의 인터페이스를 바라본다. 객체의 인터페이스는 수정하기 어렵다는 사실을 명심하라. 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

구현 관점은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다. 따라서 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다.

훌륭한 객체지향 프로그래머는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.

**도메인 개념을 참조하는 이유**

어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가?

첫 번째 전략은 도메인 개념 중에서 가장 적절한 것을 선택하는 것이다. 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.

소프트웨어는 항상 변한다. 설계는 변경을 위해 존재한다. 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

**인터페이스와 구현을 분리하라**

인터페이스와 구현을 분리하라.

명세 관점은 클래스의 안정적인 측면을 드러내야 한다. 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.

프로그래머의 입장에서 가장 많이 접하게 되는 것은 코드이므로 구현 관점을 가장 빈번하게 사용하겠지만, 실제로 훌륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스다.

중요한 것은 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다는 것이다. 결국 세 가지 관점 모두에서 클래스를 바라볼 수 있으려면 훌륭한 설계가 뒷받침되어야 한다.

---

## 느낀 점

‘함께 모으기’ 라는 장의 제목처럼, 지금까지 배웠던 개념들을 ‘커피 전문점에서 주문하기’ 라는 예제로 한 곳에 모아 설명하는 듯해 보였다. 처음 설계할 때 협력과 공용 인터페이스에 대해 생각하는 것이 중요한건 맞지만, 결국 세 가지 관점에서 다 볼 수 있도록 설계하는 것이 가장 중요하다고 느꼈다.

---

## 논의사항

- 코드 구조를 설계할 때 UML를 활용하시나요? 꼭 필수라고 생각하시나요?

전 존재만 알고 아직까지 활용해본적은 없습니다. 다른 프로젝트 팀들을 보다보니 규모가 커지고 나서 정리하는 경우도 있고, 아니면 아예 쓰지 않는 경우도 봤습니다. 프로젝트 규모가 커지면 커질수록 가시적으로 볼 수 있는 UML이 있지 않다면 좀 어려울 것 같다는 생각이 있는데, 이에 대한 여러분의 의견이 궁금합니다!